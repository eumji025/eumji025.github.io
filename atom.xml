<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EumJi Talk</title>
  
  <subtitle>just write some tech blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.eumji.cn/"/>
  <updated>2018-10-21T15:23:41.986Z</updated>
  <id>http://blog.eumji.cn/</id>
  
  <author>
    <name>EumJi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-beanfactory-autowired</title>
    <link href="http://blog.eumji.cn/2018/10/09/spring-beanfactory-autowired/"/>
    <id>http://blog.eumji.cn/2018/10/09/spring-beanfactory-autowired/</id>
    <published>2018-10-09T15:32:28.000Z</published>
    <updated>2018-10-21T15:23:41.986Z</updated>
    
    <summary type="html">
    
      本文将记录spring是如何使用Autowired进行bean的依赖注入的，目的是更加清楚和细致的了解spring bean的构造过程，加深对spring的理解
    
    </summary>
    
      <category term="Spring源码" scheme="http://blog.eumji.cn/categories/Spring%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring源码" scheme="http://blog.eumji.cn/tags/spring%E6%BA%90%E7%A0%81/"/>
    
      <category term="spring bean" scheme="http://blog.eumji.cn/tags/spring-bean/"/>
    
  </entry>
  
  <entry>
    <title>spring-beanfactory-getbean</title>
    <link href="http://blog.eumji.cn/2018/10/09/spring-beanfactory-getbean/"/>
    <id>http://blog.eumji.cn/2018/10/09/spring-beanfactory-getbean/</id>
    <published>2018-10-09T15:02:26.000Z</published>
    <updated>2018-10-09T15:02:26.069Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>springMVC-HandlerMapping初探</title>
    <link href="http://blog.eumji.cn/2018/06/15/springmvc-handlermapping/"/>
    <id>http://blog.eumji.cn/2018/06/15/springmvc-handlermapping/</id>
    <published>2018-06-15T00:45:00.000Z</published>
    <updated>2018-06-21T00:35:59.883Z</updated>
    
    <summary type="html">
    
      在之前的文章里，已经简单分析完了spring MVC的整体流程,但是并没有对Spring MVC的9大组件进行细节的分析。本文的主要目的就是去分析handlerMapping在Spring的加载和使用流程。当然本文主要还是以RequestMappingHandlerMapping为主要目标进行分析，因为他的优先级最高且绝大多数情况下我们使用的都是RequestMappingHandlerMapping来映射请求
    
    </summary>
    
      <category term="Spring专栏" scheme="http://blog.eumji.cn/categories/Spring%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Spring MVC" scheme="http://blog.eumji.cn/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>CORS注解扩展配置的理解</title>
    <link href="http://blog.eumji.cn/2018/06/02/cors-second/"/>
    <id>http://blog.eumji.cn/2018/06/02/cors-second/</id>
    <published>2018-06-02T13:25:08.000Z</published>
    <updated>2018-06-21T00:21:34.775Z</updated>
    
    <summary type="html">
    
      在上一篇我们分析了spring MVC中如何通过配置全局的CORS配置，使我们的浏览器支持跨域的访问。这一篇我们将介绍另外通过注解的方式实现CORS跨域访问，当然你也可以理解为本篇是个性化配置的一篇。这篇 主要是介绍@CrossOrigin的使用和原理解析。@CrossOrigin的作用方法非常类似@RequestMapping注解。所以@CrossOrigin注解主要作用于当前类和当前方法的一种配置方式
    
    </summary>
    
      <category term="Spring专栏" scheme="http://blog.eumji.cn/categories/Spring%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="CORS" scheme="http://blog.eumji.cn/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>CORS在spring mvc中的使用</title>
    <link href="http://blog.eumji.cn/2018/05/25/cors-init/"/>
    <id>http://blog.eumji.cn/2018/05/25/cors-init/</id>
    <published>2018-05-25T04:45:00.000Z</published>
    <updated>2018-06-21T00:23:57.888Z</updated>
    
    <summary type="html">
    
      ORS全称Cross-Origin Resource Sharing，表示跨源资源共享。表示一种允许当前域的资源被其他域直接访问。通俗的例子就是localhost：8081使用httpclient调用localhost：8082. 两个是在不同的web服务下。此时就存在跨域域进行访问的情况。我想在很久以前，那时候由于同域安全策略（the same-origin security policy）浏览器会禁止这种跨域请求。那是还是用iframe进行这种跨域的访问方式
    
    </summary>
    
      <category term="Spring专栏" scheme="http://blog.eumji.cn/categories/Spring%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="CORS" scheme="http://blog.eumji.cn/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>springMVC-DispatcherServlet源码初探</title>
    <link href="http://blog.eumji.cn/2018/05/15/springmvc-review/"/>
    <id>http://blog.eumji.cn/2018/05/15/springmvc-review/</id>
    <published>2018-05-15T00:45:00.000Z</published>
    <updated>2018-06-21T00:24:34.823Z</updated>
    
    <summary type="html">
    
      Spring MVC是非常优秀的MVC框架，而且是非常轻量级的，我带着我好奇心想研究一下Spring MVC的原理，通过很多的文章和官方文档我们知道的了其基本流程，所以本文则主要集合其流程对其源码进行简单的追踪，去了解Spring MVC的基本原理
    
    </summary>
    
      <category term="Spring专栏" scheme="http://blog.eumji.cn/categories/Spring%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Spring MVC" scheme="http://blog.eumji.cn/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>mysql8.0解压版本安装和配置</title>
    <link href="http://blog.eumji.cn/2018/05/01/mysql-8-install/"/>
    <id>http://blog.eumji.cn/2018/05/01/mysql-8-install/</id>
    <published>2018-05-01T04:28:14.000Z</published>
    <updated>2018-05-27T01:50:47.944Z</updated>
    
    <summary type="html">
    
      本文主要讲述MySQL8.11版本解压版的操作过程。因为和之前自己使用的5.6版本有一些差距，而且百度了多次也没有什么比较好的答案，所以记录一下以备不时之需。
    
    </summary>
    
      <category term="数据库" scheme="http://blog.eumji.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://blog.eumji.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java8 - 时间API记录</title>
    <link href="http://blog.eumji.cn/2018/03/19/localdatetime-api/"/>
    <id>http://blog.eumji.cn/2018/03/19/localdatetime-api/</id>
    <published>2018-03-19T11:15:51.000Z</published>
    <updated>2018-03-21T14:38:26.800Z</updated>
    
    <summary type="html">
    
      本文主要介绍Java8中新时间API的案例，来快速掌握Java8中时间API，个人感觉其中的改进使我们能更加轻松的使用这些API来满足我们平时的使用需求，特别是在时间的处理修改上更加的细致和丰富，通过本文算是对个人使用过程中的一些记录和总结
    
    </summary>
    
      <category term="Java基础" scheme="http://blog.eumji.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LocalDateTime" scheme="http://blog.eumji.cn/tags/LocalDateTime/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal扩展 - InheritableThreadLocal的原理</title>
    <link href="http://blog.eumji.cn/2018/03/18/inheritableThreadLocal/"/>
    <id>http://blog.eumji.cn/2018/03/18/inheritableThreadLocal/</id>
    <published>2018-03-18T02:15:35.000Z</published>
    <updated>2018-03-18T02:18:58.934Z</updated>
    
    <summary type="html">
    
      本文是在ThreadLocal的基础上，分析其子类InheritableThreadLocal。从名称应该也可以看出，其作用是为了继承ThreadLocal里的东西。简单来说就是为了在子线程中继承父线程中设置的值。举个很简单的例子，如果我想传递父线程的某个对象，我不用为每个子线程都设置构造函数，而子线程的任何地方都可以获取。不过需要注意的是，一旦子线程初始化，父线程再更换对象，子线程将不受影响
    
    </summary>
    
      <category term="Java基础" scheme="http://blog.eumji.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ThreadLocal" scheme="http://blog.eumji.cn/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis分析 - SQL参数绑定【初稿】</title>
    <link href="http://blog.eumji.cn/2018/03/08/mybatis-paramter-binder/"/>
    <id>http://blog.eumji.cn/2018/03/08/mybatis-paramter-binder/</id>
    <published>2018-03-08T14:49:12.000Z</published>
    <updated>2018-03-13T12:25:39.064Z</updated>
    
    <summary type="html">
    
      相信我们在使用过mybatis多参数查询时，又不使用@param注释的时候，将无法和我们xml中参数绑定的情况，因为mybatis在我们没有使用param注解时候，默认使用的param1，param2等名称表示我们的请求参数。今天主要追要追踪一下mybatis到底是怎么进行处理的
    
    </summary>
    
      <category term="Mybatis解析专栏" scheme="http://blog.eumji.cn/categories/Mybatis%E8%A7%A3%E6%9E%90%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Mybatis参数" scheme="http://blog.eumji.cn/tags/Mybatis%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis分析 - 插件的加载和使用</title>
    <link href="http://blog.eumji.cn/2018/03/02/mybatis-interceptor-analysis/"/>
    <id>http://blog.eumji.cn/2018/03/02/mybatis-interceptor-analysis/</id>
    <published>2018-03-02T12:17:43.000Z</published>
    <updated>2018-03-02T12:24:15.444Z</updated>
    
    <summary type="html">
    
      前面也陆陆续续的介绍了一些mybatis相关的内容，今天介绍一点mybatis里非常有用的拓展功能`插件`，我们都知道mybatis的pagehelper分页插件，可是有没有想过是怎么实现的呢，大概的我想应该就是在查询之前拦截mybatis的sql加上分页的语句。今天抱着学习的态度一起来探究一下mybatis插件原理
    
    </summary>
    
      <category term="Mybatis解析专栏" scheme="http://blog.eumji.cn/categories/Mybatis%E8%A7%A3%E6%9E%90%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Mybatis 插件" scheme="http://blog.eumji.cn/tags/Mybatis-%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>聊聊cglib动态代理的实现</title>
    <link href="http://blog.eumji.cn/2018/02/23/cglib-proxy-analysis/"/>
    <id>http://blog.eumji.cn/2018/02/23/cglib-proxy-analysis/</id>
    <published>2018-02-23T02:18:22.000Z</published>
    <updated>2018-03-17T02:47:22.771Z</updated>
    
    <summary type="html">
    
      cglib是另外一种动态代理的方法，他和jdk动态代理的实现是有区别的，我们在之前见过jdk动态代理类是必须实现了接口的，而cglib不需要实现接口，但是必须保证类不含有final关键字，否则是无法代理的
    
    </summary>
    
      <category term="Java基础" scheme="http://blog.eumji.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="proxy" scheme="http://blog.eumji.cn/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis分析 - Mapper加载使用分析</title>
    <link href="http://blog.eumji.cn/2018/02/21/mybatis-mapper-info/"/>
    <id>http://blog.eumji.cn/2018/02/21/mybatis-mapper-info/</id>
    <published>2018-02-21T07:01:30.000Z</published>
    <updated>2018-03-05T23:43:43.684Z</updated>
    
    <summary type="html">
    
      本文主要讲述mybatis的mapper加载和使用流程。在之前的配置文件加载分析中我们已经讲解了在mybatis构建sqlSessionFactory的时候就会加载mybatis的配置文件，其中当然包含了mybatis的alias，typeHandler，settings，mapper。但是我们并没有对其深入的去讲解，本文则主要通过细节去了解到底是如何进行mapper实例化
    
    </summary>
    
      <category term="Mybatis解析专栏" scheme="http://blog.eumji.cn/categories/Mybatis%E8%A7%A3%E6%9E%90%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Mybatis Mapper加载" scheme="http://blog.eumji.cn/tags/Mybatis-Mapper%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis分析 - 二级缓存</title>
    <link href="http://blog.eumji.cn/2018/02/16/mybatis-second-cache/"/>
    <id>http://blog.eumji.cn/2018/02/16/mybatis-second-cache/</id>
    <published>2018-02-16T03:29:18.000Z</published>
    <updated>2018-03-02T12:35:03.424Z</updated>
    
    <summary type="html">
    
      本文同一个实例展示mybatis集成redis做二级缓存，并从源码的解读解析了整个流程，了解其工作原理
    
    </summary>
    
      <category term="Mybatis解析专栏" scheme="http://blog.eumji.cn/categories/Mybatis%E8%A7%A3%E6%9E%90%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Mybatis缓存" scheme="http://blog.eumji.cn/tags/Mybatis%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>独占锁ReentrantLock分析</title>
    <link href="http://blog.eumji.cn/2018/02/11/reentrantLock-analysis/"/>
    <id>http://blog.eumji.cn/2018/02/11/reentrantLock-analysis/</id>
    <published>2018-02-11T11:58:18.000Z</published>
    <updated>2018-02-16T03:43:15.461Z</updated>
    
    <summary type="html">
    
      为什么会诞生lock,我想我们也是很容理解的,因为JDK6之前的synchronized关键字不够高效,而且synchronized不够灵活(比如无法使用尝试在规定时间内获取锁)等,所以就诞生了lock. lock改善了很多同步上的性能问题,而且有非常灵活的API
    
    </summary>
    
      <category term="Java基础" scheme="http://blog.eumji.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://blog.eumji.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis分析 - 一级缓存</title>
    <link href="http://blog.eumji.cn/2018/02/10/mybatis-first-cache/"/>
    <id>http://blog.eumji.cn/2018/02/10/mybatis-first-cache/</id>
    <published>2018-02-10T15:30:30.000Z</published>
    <updated>2018-03-11T02:26:57.622Z</updated>
    
    <summary type="html">
    
      本文主要通过实例的方式解决自己心中对于mybatis一级缓存得疑惑，也通过源码追踪的方式最终验证这些问题产生的原因，非常的值得我们去领会
    
    </summary>
    
      <category term="Mybatis解析专栏" scheme="http://blog.eumji.cn/categories/Mybatis%E8%A7%A3%E6%9E%90%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Mybatis缓存" scheme="http://blog.eumji.cn/tags/Mybatis%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask源码实现</title>
    <link href="http://blog.eumji.cn/2018/02/06/futureTask-analysis/"/>
    <id>http://blog.eumji.cn/2018/02/06/futureTask-analysis/</id>
    <published>2018-02-06T05:23:46.000Z</published>
    <updated>2018-02-16T03:43:19.573Z</updated>
    
    <summary type="html">
    
      FutureTask是一种支持取消的异步任务包装类，也就是说FutureTask执行的时候不立即返回结果，自己可以通过异步调用get方法获取结果，也可以中途调用cancel方法取消任务。而且必须要知道的就是FutureTask只是任务的包装类，并不是真正的任务类
    
    </summary>
    
      <category term="Java基础" scheme="http://blog.eumji.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://blog.eumji.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>不得不懂的线程池 - ThreadPoolExecutor</title>
    <link href="http://blog.eumji.cn/2018/02/01/threadPool-analysis/"/>
    <id>http://blog.eumji.cn/2018/02/01/threadPool-analysis/</id>
    <published>2018-02-01T00:41:37.000Z</published>
    <updated>2018-03-02T12:36:20.776Z</updated>
    
    <summary type="html">
    
      线程池的诞生于JDK1.5，主要的目的是解决我们在使用线程的时候通常都是重复的创建和销毁，为了让线程能够得到复用，避免我们重复的创建和销毁，提高我们的效率，降低内存的开销。
    
    </summary>
    
      <category term="Java基础" scheme="http://blog.eumji.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://blog.eumji.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis专栏 - 总体流程回顾</title>
    <link href="http://blog.eumji.cn/2018/01/21/mybatis-epitome/"/>
    <id>http://blog.eumji.cn/2018/01/21/mybatis-epitome/</id>
    <published>2018-01-21T01:35:17.000Z</published>
    <updated>2018-11-04T03:50:36.978Z</updated>
    
    <summary type="html">
    
      本文主要回顾mybatis的整体执行流程，走马观花去看一下mybatis是如何进行加载和使用的，为后续的文章分析做铺垫
    
    </summary>
    
      <category term="Mybatis解析专栏" scheme="http://blog.eumji.cn/categories/Mybatis%E8%A7%A3%E6%9E%90%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="Mybatis概括" scheme="http://blog.eumji.cn/tags/Mybatis%E6%A6%82%E6%8B%AC/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer源码分析</title>
    <link href="http://blog.eumji.cn/2018/01/18/AbstractQueuedSynchronizer-analysis/"/>
    <id>http://blog.eumji.cn/2018/01/18/AbstractQueuedSynchronizer-analysis/</id>
    <published>2018-01-18T13:56:36.000Z</published>
    <updated>2018-02-16T03:43:22.161Z</updated>
    
    <summary type="html">
    
      AbstractQueuedSynchronizer是一个基于first-in-first-out (FIFO)队列实现阻塞锁和同步器功能的框架。此类的设计目标是成为依靠单个原子 int 值来表示状态。子类必须定义更改此状态的受保护方法（如tryReleaseShared），并定义哪种状态对于此对象意味着被获取或被释放
    
    </summary>
    
      <category term="Java基础" scheme="http://blog.eumji.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://blog.eumji.cn/tags/java/"/>
    
  </entry>
  
</feed>
