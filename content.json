{"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-01-01T08:52:14.476Z","updated":"2018-01-01T08:52:14.476Z","comments":false,"path":"/404.html","permalink":"http://www.eumji025.com//404.html","excerpt":"","text":""},{"title":"About","date":"2017-12-31T16:08:16.299Z","updated":"2017-09-16T11:09:26.071Z","comments":false,"path":"about/index.html","permalink":"http://www.eumji025.com/about/index.html","excerpt":"","text":"个人简介"},{"title":"Books","date":"2017-12-31T16:08:16.343Z","updated":"2017-09-16T11:09:26.074Z","comments":false,"path":"books/index.html","permalink":"http://www.eumji025.com/books/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-12-31T16:08:16.379Z","updated":"2017-09-16T11:09:26.077Z","comments":false,"path":"categories/index.html","permalink":"http://www.eumji025.com/categories/index.html","excerpt":"","text":""},{"title":"Repository","date":"2017-12-31T16:08:16.107Z","updated":"2017-09-16T11:09:26.085Z","comments":false,"path":"repository/index.html","permalink":"http://www.eumji025.com/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-31T16:08:16.163Z","updated":"2017-09-16T11:09:26.090Z","comments":false,"path":"tags/index.html","permalink":"http://www.eumji025.com/tags/index.html","excerpt":"","text":""},{"title":"Links","date":"2018-02-03T11:09:29.448Z","updated":"2017-09-16T11:09:26.081Z","comments":true,"path":"links/index.html","permalink":"http://www.eumji025.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"动态代理及Proxy源码分析","slug":"futureTask-analysis","date":"2018-02-06T05:23:46.000Z","updated":"2018-02-06T12:05:53.594Z","comments":true,"path":"2018/02/06/futureTask-analysis/","link":"","permalink":"http://www.eumji025.com/2018/02/06/futureTask-analysis/","excerpt":"","text":"简介FutureTask是一种支持取消的异步任务包装类，也就是说FutureTask执行的时候不立即返回结果，自己可以通过异步调用get方法获取结果，也可以中途调用cancel方法取消任务。而且必须要知道的就是FutureTask只是任务的包装类，并不是真正的任务类。 FutureTask实现RunnableFuture接口，而RunnableFuture继承了Runnable, Future接口。 实现下面我们将介绍一下FutureTask的具体实现。 FutureTask状态正是因为FutureTask只是任务执行的包装类，所以他肯定是需要很多的状态来维护任务运行的状态，不然怎么能cancel，get呢，下面我们具体来看一下。 12345678private volatile int state;private static final int NEW = 0; //新建任务的状态private static final int COMPLETING = 1; //我觉得可以称作进行中private static final int NORMAL = 2; //正常执行完毕private static final int EXCEPTIONAL = 3; //发生异常时private static final int CANCELLED = 4; //任务取消private static final int INTERRUPTING = 5; //中断中private static final int INTERRUPTED = 6; //中断完成 根据代码注释中的描述,上述的状态很有可能发生以下四种可能性： 过程 含义 NEW -&gt; COMPLETING -&gt; NORMAL 正常的执行过程，从开始到结束 NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 执行过程中发生了异常 NEW -&gt; CANCELLED 任务被取消 NEW -&gt; INTERRUPTING -&gt; INTERRUPTED 任务被中断 FutureTask构造方法FutureTask的构造方法主要有两个，和我们之前讲线程池的很相似，主要是为了针对不同的任务类型 12345678910public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; 很简单，就是强行把runable包装成callble对象，并且返回值为传入的result。 run方法在FutureTask中有两种执行的方式，run方法和runAndReset方法，先看一下run方法的实现。 1234567891011121314151617181920212223242526272829public void run() &#123; //不是NEW状态的任务无法执行 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; //再次判断 if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); //执行 ran = true; //正常状态下设置状态为true &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); //发生异常时，状态修改 &#125; if (ran) //正常情况下 set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) //如果是有中断发生 handlePossibleCancellationInterrupt(s); &#125;&#125; 方法的逻辑非常的简单，就三件事情 1.首先就是判断任务是不是可执行的状态，如果不可以那么就结束，否则 2.执行任务，如果发生异常，进行异常状态下的设置，否则正常逻辑状态设置 3.最后在返回前进行状态设置，如果处于中断状态，设置更新状态。 异常处理接下来我们需要看一下异常状态下的处理。 12345678protected void setException(Throwable t) &#123; //尝试设置到COMPLETING状态 if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = t; //设置outcome为异常对象 UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // 最终的状态 finishCompletion(); &#125;&#125; 这里就满足了我们在上面表格中介绍到的异常状态下的状态的变化过程。发生异常后还需要执行finishCompletion方法，finishCompletion的主要目的其实是唤醒所有等待获取结果的线程，所以我们把放在get方法的后面再讲。 正常结束下面我们看一下set方法的干的事情，根据我们之前在表格中的介绍应该很容易才出来。 1234567protected void set(V v) &#123; if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); finishCompletion(); &#125;&#125; set方法逻辑和setException逻辑类似，只是他们设置的最终状态值和outcome值不同而已。就不多说了。 发生中断我们接着看run方法中finally中的方法 12345private void handlePossibleCancellationInterrupt(int s) &#123; if (s == INTERRUPTING) while (state == INTERRUPTING) Thread.yield();&#125; 这里做的事情很简单，就是假如发生了中断的事件，那么此时就是释放锁，一直重试到状态变成了INTERRUPTED。 runAndReset方法我们再看一下runAndReset方法和run方法的异同。 123456789101112131415161718192021222324protected boolean runAndReset() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread())) return false; boolean ran = false; int s = state; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; s == NEW) &#123; try &#123; c.call(); // don't set result ran = true; &#125; catch (Throwable ex) &#123; setException(ex); &#125; &#125; &#125; finally &#123; runner = null; s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; return ran &amp;&amp; s == NEW;&#125; 很容易看出，runAndReset在正常执行结束后是不会更改状态的，这样的话势必会造成正常情况下是无法获取程序的结果的。之所以这么做也是因为任务是要复用的，因为这个方法是用来做周期循环调度的。所以也不会改变状态，也不会设置结果值。具体的体现我们可以再ScheduleThreadPoolExecutor中具体查看。 cancel方法上面我们介绍了中断时的状态的改变，但是我们没介绍到底是怎么产生中断的，接下来我们看一下，先说明一下其实中断和取消的方法是使用同一个方法，只是状态值不同 1234567891011121314151617181920212223public boolean cancel(boolean mayInterruptIfRunning) &#123; //mayInterruptIfRunning true代表中断，false代表取消 //如果是NEW状态又执行了中断或取消，跳过，否则直接结束 if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; //中断的情况，设置线程中断 if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) t.interrupt(); &#125; finally &#123; // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); &#125; &#125; &#125; finally &#123; finishCompletion(); &#125; return true;&#125; 我们可以看到，cancel同时具有取消和中断两种功能， 1.当我们的任务还是NEW状态，又改变状态成功，这说明任务已经无法执行了，设置线程状态，如果不处于NEW状态，或者修改状态失败则直接结束方法。 2.不满足的情况下就会判断任务是否为中断，如果中断的话就把线程的状态也设置为中断，并改变最终的状态。 3.最终也都要释放等待的线程（具体留在后面说明）。 get方法get方法主要有两种，一种是一直等待，一种是设置超时的时间。 1234567891011121314public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s);&#125;private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); &#125; 如果任务的状态还小于COMPLETING，说明任务还没有完成，不管是有没有发生意外的情况。此时都要把获取结果的线程加入到等待结果的链表中，如果是已完成则直接获取结果，很简单就不多描述了。 我们在继续看看带超时时间的get方法 12345678910public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (unit == null) throw new NullPointerException(); int s = state; if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); return report(s);&#125; 其实抛开awaitDone方法都是一致的，所以我们直接来看一下awaitDone方法。 awaitDone方法1234567891011121314151617181920212223242526272829303132333435363738private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) &#123; //如果线程被中断，直接移除 if (Thread.interrupted()) &#123; removeWaiter(q); throw new InterruptedException(); &#125; int s = state; //再次检测状态，不满足就直接返回了 if (s &gt; COMPLETING) &#123; if (q != null) q.thread = null; return s; &#125; else if (s == COMPLETING) //说明马上状态就改变了，那么此时肯定不会入队了，所以让出时间片 Thread.yield(); else if (q == null) //说明还在NEW状态， q = new WaitNode(); else if (!queued) //入队 queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); //设置到队列头 else if (timed) &#123; //如果是设置了超时时间的 nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123; removeWaiter(q); //移除等待的线程 return state; &#125; LockSupport.parkNanos(this, nanos); //否则挂起指定时间 &#125; else LockSupport.park(this); &#125; &#125; 好，这里的所及还算是比较复杂，在这里我们简单的总结一下 1.判断线程是否有被中断，如果被中断了直接结束等待。否则 2.判断state的状态是否COMPLETING，如果大于说明要么执行完要么出了状况，可以去拿值了。直接返回，如果不满足 3.在判断是否为COMPLETING，也说明该执行的也执行了，现在在修改状态中，马上就可以拿值，所以放弃时间片，等下次来再判断。如果不满足 4.否则没有入队就入队，否则如果是设置超时时间，就判断是否已经超时，超时就移除，否则就把线程挂起指定时间。 说了那么多，很多方法都调用了finishCompletion方法，都需要释放等待结果的线程，接下来我们就一起看看其中的逻辑。 finishCompletion方法其实实现的逻辑还是很简单的， 123456789101112131415161718192021222324private void finishCompletion() &#123; // 处理等待的线程链表 for (WaitNode q; (q = waiters) != null;) &#123; //清除等待线程 if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123; for (;;) &#123; //解锁等待的线程 Thread t = q.thread; if (t != null) &#123; q.thread = null; LockSupport.unpark(t); &#125; WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; &#125; break; &#125; &#125; done(); //留着扩展的，什么都没做 callable = null; // to reduce footprint &#125; 这里的逻辑也是非常简单就是唤醒所有等待的线程，如果还没处理完毕，又会被挂起。 总结本文从run方法，get方法，cancel方法以及他们所涉及到的方法总体上弄清楚了FutureTask的功能。 1.FutureTask只是任务的包装类，真正的执行的逻辑不在其中。 2.一定要弄清楚FutureTask的几种状态值，非常重要。 3.只有NEW状态的任务才能被执行，run方法运行后正常情况下会改变state的值，而runAndReset不会，因为两种方法的场景不同。 4.runAndReset调度任务，发生异常任务就会终止后面的调度。 目前FutureTask主要是用于线程池中，用于异步获取执行结果和线程池的调度上。 最后此文章都是个人的理解并整理，如果存在什么逻辑上的疏漏或者表述不当，欢迎吐槽反馈！！ 与君共勉！！！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"不得不懂的线程池 - ThreadPoolExecutor","slug":"threadPool-analysis","date":"2018-02-01T00:41:37.000Z","updated":"2018-02-01T12:07:28.368Z","comments":true,"path":"2018/02/01/threadPool-analysis/","link":"","permalink":"http://www.eumji025.com/2018/02/01/threadPool-analysis/","excerpt":"","text":"简介线程池的诞生于JDK1.5，主要的目的是解决我们在使用线程的时候通常都是重复的创建和销毁，为了让线程能够得到复用，避免我们重复的创建和销毁，提高我们的效率，降低内存的开销。没错又是Doug Lea大神又搞出了线程池这一强力工具。 我们最熟悉的线程池使用案例应该就是数据库连接池，以及我们任务调度都是会使用线程池的。 Executors用来创建和管理我们具体的ThreadPoolExecutor，这里使用了典型的设计模式 - 工厂模式。ThreadPoolExecutor是真正线程池，继承了AbstractExecutorService类，Java集合类和并发类都大量的使用了抽象类实现部分通用的功能。此处的AbstractExecutorService就实现了ExecutorService部分接口功能。最关键的execute方法交给子类去实现。和集合类的套路基本上是一模一样。 看一下Executors的具体实现。 123456789public static ExecutorService newFixedThreadPool(int var0) &#123; return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());&#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory var0) &#123; return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0));&#125;public static ScheduledExecutorService newScheduledThreadPool(int var0) &#123; return new ScheduledThreadPoolExecutor(var0);&#125; 随便列举了其中的几个例子，这里具体描述一下构造函数的几个参数作用。 1public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123; corePoolSize =&gt; 指代默认创建的线程数。 maximumPoolSize =&gt; 创建线程的最大数量。 keepAliveTime =&gt; 线程存活时间 unit =&gt; 存活的时间，应该都很熟悉，包含日，时，分，秒等 workQueue =&gt; 存放线程的阻塞队列 threadFactory =&gt; 创建线程的工厂，默认为DefaultThreadFactory，主要是重写ThreadFactory接口的newThread的方法。 handler =&gt; 拒绝策略，主要是指工作任务超过了workQueue的大小后，该执行哪种策略进行处理。主要有一下几种： 1.AbortPolicy =&gt; 默认的策略，直接抛出异常 2.DiscardPolicy =&gt; 放弃被拒绝的任务，其实就是啥也不干 3.DiscardOldestPolicy =&gt; 放弃最老的任务，也就是马上要执行的任务 4.CallerRunsPolicy =&gt; 直接执行被放弃的任务，个人不喜欢，赤裸裸的插队（而且根本就没有拒绝） 上面简单的介绍了线程池的各个参数，现在就看一下到底可以生成哪些线程池。 fixedThreadPoolfixedThreadPool =&gt; 固定大小线程池，一旦创建，数量就不会再改变，如果任务超过线程的数量，就会进入等待的队列,使用的LinkedBlockingQueue就可以认为是无界的队列了因为capacity等于Integer.MAX_VALUE 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 我们简单的测试一下就可以发现其中的功能 1234567891011121314151617static class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; Thread.sleep(500L); System.out.println(Thread.currentThread().getName() +\" running !!!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;static void fixedThreadPoolTest()&#123; ExecutorService executorService = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 20; i++) &#123; executorService.submit(new MyThread()); &#125;&#125; 执行这个test方法的时候，会发现只会有5种线程名称被打印。说明没有没有获得线程的任务就等待，而且是复用的。后续的例子都将使用MyThread做测试。 cachedThreadPoolnewCachedThreadPool =&gt; 大小不固定，为达到最大值时可以动态生成线程，默认使用的是SynchronousQueue队列，是一种同步队列，指只能存放一个元素，添加了必须被消费了才能再添加。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 下面简单的使用一个例子进行说明。 1234567891011static void cachedThreadPoolTest() throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.submit(new MyThread()); &#125; Thread.sleep(1000L); for (int i = 0; i &lt; 20; i++) &#123; executorService.submit(new MyThread()); &#125;&#125; 上面测试的例子将复用前五个线程，并再新建15个线程，结果就不展示了。 singleThreadExecutorsingleThreadExecutor =&gt; 大小固定的且只有一个线程的线程池，可以理解为一个元素的fixedThreadPool。 12345public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 就不进行测试代码的展示了，因为和fixedThreadPool的道理相同,只不过只有一个线程。 scheduledThreadPoolscheduledThreadPool =&gt; 是一种大小不固定的定时任务线程池。使用的DelayedWorkQueue延时队列进行任务记录。DelayedWorkQueue是ScheduledThreadPoolExecutor的内部类 1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 下面演示一个简单的例子演示如何。需要注意的是延时任务调用的方法会有点不同。 123456789static void singleThreadScheduledTest()&#123; ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); for (int i = 0; i &lt; 2; i++) &#123; //延迟5秒执行,只执行一次 executorService.schedule(new MyThread(),1,TimeUnit.SECONDS); //延迟5秒 执行5个周期执行 //executorService.scheduleAtFixedRate(new MyThread(),5,3, TimeUnit.SECONDS); &#125;&#125; 上面测试里的1代表延时1秒执行，且只执行一次，如果想周期执行，可调用下面注释的方法scheduleAtFixedRate方法，表示第一次延时5秒执行，后面的是以3秒为一个周期的执行。 需要注意的是： 1.不会自动出现停止，除非发生异常或者手动的取消掉。 2.假如执行的周期比线程的执行时间短，则会以延时的任务的执行时间长度为准。 singleThreadScheduledExecutor1234public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));&#125; 可以看出来singleThreadScheduledExecutor和ScheduledThreadPoolExecutor还是有一定的区别的，singleThreadScheduledExecutor是单独的一个实现类，不过本文不做具体分析。 方法解读上面大概的介绍了线程池中的几种线程池，接下来我们将介绍一下如何其中到底是如何实现的。我们只说一下常规的线程池的执行逻辑。 从上面的代码我们可以看到，各种线程池的不同主要体现在线程的数量范围和使用的workQueue不同。最终都会调用submit方法，首先看一下线程池中几种不同参数的submit方法。 1234567891011121314public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125; submit方法支持多种类型的任务，最终都会包装成RunnableFuture的task。这里体现了一个重要的设计模式 - 适配器模式，下面看一下详细代码 123456789101112protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125; 其实目的很简单就是把Runnable最终包装成Callable。 在介绍具体的方法之前，首先我们看一下线程池中几种状态，因为后续会使用到。 12345678910111213141516 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); //最小的负数 private static final int COUNT_BITS = Integer.SIZE - 3; public static final int SIZE = 32;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;//29个1 // runState is stored in the high-order bits private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; //11100000000000000000000000000000 private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//0 private static final int STOP = 1 &lt;&lt; COUNT_BITS;//100000000000000000000000000000 private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//1000000000000000000000000000000 private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;//1100000000000000000000000000000 // c &amp; 29个0 其实就是获取高三位 private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 这是一个非常经典的设计，我们可以看出，我们的低29位都是用来记录任务的。高3位表示状态 RUNNING =&gt; 高3位值是111。 此状态表示可以接受新任务 SHUTDOWN =&gt; 高3位值是000。 此状态不能接受新任务，但会继续已有的任务 STOP =&gt; 高3位值是001。 此状态的线程不接受也不处理任务，并且会中断处理中的任务 TIDYING =&gt; 高3位值是010。 线程池所有的任务都已经终止，并且worker数量为0，即将运行terminated方法 TERMINATED =&gt; 高3位值是011。在TIDYING状态上，已经运行了terminated方法，线程池完全的停止。 上面的这些数字很重要，一定要记住。 接着上面的讲，最终不管是哪种submit的方法，都会交给execute方法去执行真正的逻辑。 12345678910111213141516171819202122public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //如果还没有超过线程池的线程容量，直接分配线程执行 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; //否则判断线程池的状态，如果是正在运行状态，加入到workQueue等待执行 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //再次校验状态，如果线程池不在运行状态，移除任务，并执行拒绝策略。 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果没有正在运行的线程，添加一个线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); //直接开启一个线程，因为任务已经在workQueue上了 &#125; //如果workQueue添加失败，尝试直接起一个worker，用于coreSize和MaxSize不等的情况 else if (!addWorker(command, false)) reject(command);&#125; 简单的概述一下上述代码所做的事情： 1.如果当前的活动的线程小于设置的线程数，则直接启动新线程执行任务，否则 2.如果线程池是处于运行状态，且线程数为corePoolSize，且workQueue没满，把任务加入到等待队列中，如果执行成功，再次检查线程的运行状态，到第三步，否则到第四步 3.再次校验状态，如果没有处于运行的状态，把添加的任务剔除。 4.线程池如果不处于运行状态，或者workQueue已经满了，workQueue满了，还可以再次尝试执行分配一个线程（用于corePoolSize不等于maximumPoolSize的情况下），如果还是失败，说明线程池已经到极限了和或者是已经关闭了线程池。 接下来需要看一下第一步中的addWorker方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // 线程的状态，running状态的无法进入 //需要注意其中不能添加一个woker的条件。SHUTDOWN状态下且不同时满足firstTask为null，workQueue为空的条件 if (rs &gt;= SHUTDOWN &amp;&amp;! (rs == SHUTDOWN &amp;&amp;firstTask == null &amp;&amp;! workQueue.isEmpty())) return false; //思考能够到达这里的条件 for (;;) &#123; //线程的数量 int wc = workerCountOf(c); //超出了最大容量，或者线程超过规定的数量，失败 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //数量+1，跳出循环 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //添加一个worker 里面有玄机，后面介绍 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //再次检查线程池的状态 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // 如果线程已经在运行中， throw new IllegalThreadStateException(); //添加一个worker记录 workers.add(w); int s = workers.size(); //增加最大数量 ，默认为0 if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // 添加成功则启动任务 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; addWorker方法看起来比较长，其实做的事情非常简单。 1.判断线程池的状态，如果不是正常状态（rs &gt;= SHUTDOWN &amp;&amp;! (rs == SHUTDOWN &amp;&amp;firstTask == null &amp;&amp;! workQueue.isEmpty())）则添加失败，否则进行第二步 2.根据条件判断是否还能在添加线程，可以则workCount加1成功跳出循环，执行worker逻辑，否则重试或者结束。 3.第二步成功，配置Worker，并在此检查线程池的状态，如果没有问题，则设置worker相关信息，并启动线程。 然后我们在来看一下execute方法中的remove方法，我相信remove方法不仅仅是从workQueue移除元素，不然也不会单独写个方法。 12345public boolean remove(Runnable task) &#123; boolean removed = workQueue.remove(task); tryTerminate(); // In case SHUTDOWN and now empty return removed;&#125; 首先从workQueue移除元素，然后尝试关闭线程池。具体逻辑还是在tryTerminate方法中。 12345678910111213141516171819202122232425262728293031323334final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get(); //如果是运行状态，或者已经停止，或者是存于shutdown状态，但是任务没有处理完，都直接结束，也就证明尝试停止失败 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; //如果还有工作的线程，把worker的中断状态设为true，ONLY_ONE表示只中断一个 if (workerCountOf(c) != 0) &#123; // Eligible to terminate interruptIdleWorkers(ONLY_ONE); return; &#125; //没有工作的线程了真的药停止了 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //设置为TIDYING状态 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; //留给子类扩展的 terminated(); &#125; finally &#123; //最终设置为TERMINATED状态 ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125; &#125; tryTerminate是任何从workerQueue移除任务都会调用的方法，用来判断当前线程池是否已经没有活着的线程了，如果没有了就关闭线程池。 再次回到execute方法中，reject方法就是调用拒绝策略中的rejectedExecution方法，默认的AbortPolicy就是抛个异常仅此而已。 后面也只是一些相同的方法就不再多介绍了，最重要的还是条件判断。 shutdown方法在看一下线程池的shutdown相关的方法。 主要包含三个方法： 1.shutdown方法 =&gt; 将线程池的状态设置为shutdown状态 2.shutdownNow方法 =&gt; 直接停止线程池。 3.isShutdown方法 =&gt; 判断当前线程池的状态是否不是running状态 下面跟随着源码分别看看这几个方法的详情。 123456public boolean isShutdown() &#123; return ! isRunning(ctl.get());&#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; isShutdown方法还是老套路，直接判断是否小于SHUTDOWN状态就可以判断是否为Running状态。 12345678910111213public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); //检查权限， advanceRunState(SHUTDOWN); //设置为SHUTDOWN状态 interruptIdleWorkers(); //中断等待任务的线程 onShutdown(); // 空方法，为ScheduledThreadPoolExecutor留的方法 &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); //尝试关闭线程池&#125; shutdown方法是将线程池的状态设置为SHUTDOWN,并且设置线程的中断状态，注意这里的中断只会中断在等待中的线程（没有上锁的线程）。比较简单里面的详情就不展示出来了。 123456789101112131415public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); //设置为STOP状态 interruptWorkers(); //中断所有运行中的且没有被设置中断标志的线程 tasks = drainQueue(); //获取等待中的任务列表 &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks;&#125; shutdownNow方法和上面的shutdown方法很相似，只是不同的是，shutdownNow更彻底，直接将线程池的状态设置为STOP，并且会移除有所有的等待中的task，而且这里设置的是所有运行中线程的中断状态。下面看一下drainQueue方法 12345678910111213private List&lt;Runnable&gt; drainQueue() &#123; BlockingQueue&lt;Runnable&gt; q = workQueue; ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;(); q.drainTo(taskList);//将workQueue的对象转移到taskList（会清空q里的元素） if (!q.isEmpty()) &#123; //如果q还有新offer的元素 for (Runnable r : q.toArray(new Runnable[0])) &#123; if (q.remove(r)) taskList.add(r); //添加到taskList中 &#125; &#125; return taskList;&#125; 主要做的事情就是从workQueue中获取所有的任务放到taskList中，并从workQueue中删除。 补充前面我们了解线程是如何执行任务和关闭线程池的方法，但是我们需要思考这样一个场景，就是当我们有任务被放在workQueue里的时候，上述的方法并没有讲述这样的情况下是如何执行的，这里需要介绍一下其中的逻辑。这时候就可以看一下留在addWorker的玄机了。。。 123456 private final class Worker extends AbstractQueuedSynchronizer implements RunnableWorker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this);&#125; 可以从构造函数看出，thread对象其实指向的就是当前的worker，所以addWorker方法后面的thread.start就会调用worker.run方法。还有一点值得注意的是Worker继承了AbstractQueuedSynchronizer，下面详细看一下run方法中的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public void run() &#123; runWorker(this);&#125;final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; //取出worker中的任务 w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //获取任务， while (task != null || (task = getTask()) != null) &#123; w.lock(); //如果线程池停止了，当前 线程没有终端，将当前线程设为中断状态 if ((runStateAtLeast(ctl.get(), STOP) ||(Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //空方法，留给子类的 beforeExecute(wt, task); Throwable thrown = null; try &#123; //执行task的逻辑 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 从上面的方法可以看出，worker的run方法主要做了几件事。 1.循环获取任务，并执行，发生异常则抛出异常 2.如果没有问题最终关闭worker。 首先看一下getTask方法是如何操作的。 123456789101112131415161718192021222324252627282930313233343536373839private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //检查队列是否为空，或者线程池是否处理关闭状态 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; //递减worker的数量 decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // 判断是否已经设置超时 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //线程超过了最大数量或者超时，说明不可用了，干掉 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //获取任务 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; //否则获取任务超时 timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 上述获取任务的方法还是比较复杂的，特别是状态的判断，简单的总结一下： 1.如果线程池的状态是STOP或者工作的队列为空，循环去一个一个的减少worker的数量，此处只是减少数量。并没有结束里面的worker。 2.如果不满足第一条，开始校验是否设置了超时关闭线程或者说线程数超过了设置的值。这时候判断去判断线程1.是否超过了线程数的最大值或者满足了超时的条件 2.线程数大于1或者已经没有待处理的工作了。满足这些条件就去掉一个worker 3.如果2也没有满足，就尝试获取task，获取到了就返回，否则就设置timeOut为true，说明取task失败了。 上面介绍了如何获取任务和管理worker的getTask方法，下面我们在看一下任务执行完后的processWorkerExit方法。 12345678910111213141516171819202122232425262728293031private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //如果completedAbruptly为true就减少worker的数量，产生于runWorker发生异常。 if (completedAbruptly) decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks; //删除这个worker workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; //完成任务了就尝试关闭线程池 tryTerminate(); int c = ctl.get(); if (runStateLessThan(c, STOP)) &#123; if (!completedAbruptly) &#123; //判断有没有设置超时 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) min = 1; //判断还有没有线程可以工作 if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; //执行addworker addWorker(null, false); &#125;&#125; 上述的方法主要是worker进行退出，主要做的几件事如下 1.判断是否正常的结束，如果不是就要删减worker。 2.记录完成任务的数量并移除worker。 3.尝试关闭线程池，然后判断线程池的状态，如果还没有处于停止的状态，继续判断是不是正常的结束，如果是的话去检查线程池里线程的状态，如果正常就结束，如果不满足最好都添加一个worker。 总结1.本文首先介绍了线程池的几种类型的线程池，从代码都可以看到其实共用用的同一个构造方法，不同的只是参数的不用。 2.分析了线程池的几种状态，这里是比较重要的，特别是高三位表示状态，低29位表示线程数。 3.分析了submit和execute方法，通过corePoolSize，maximumPoolSize，workQueue来判断新任务是新启一个线程还是加入到workQueue中，或是执行拒绝策略。 4.分析了shutdown相关的方法逻辑 5.分析了worker到底是如何工作的，这里主要是对内部类worker的run及其涉及的方法进行解读。 本篇只是个人看源码的一些观点，如果存在不清晰或者表述错误的观点欢迎大家反馈。 与君共勉！！！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"AbstractQueuedSynchronizer源码分析","slug":"AbstractQueuedSynchronizer-analysis","date":"2018-01-18T13:56:36.000Z","updated":"2018-01-28T05:28:34.639Z","comments":true,"path":"2018/01/18/AbstractQueuedSynchronizer-analysis/","link":"","permalink":"http://www.eumji025.com/2018/01/18/AbstractQueuedSynchronizer-analysis/","excerpt":"","text":"AQS简介AbstractQueuedSynchronizer是一个基于first-in-first-out (FIFO)队列实现阻塞锁和同步器功能的框架。简称AQS,此类的设计目标是成为依靠单个原子 int 值来表示状态。子类必须定义更改此状态的方法（如tryReleaseShared），并定义哪种状态对于此对象意味着被获取或被释放。 我们首先看一下AQS类中FIFO队列的真实面貌 12345678910111213static final class Node &#123; static final AbstractQueuedSynchronizer.Node SHARED = new AbstractQueuedSynchronizer.Node(); static final AbstractQueuedSynchronizer.Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; volatile AbstractQueuedSynchronizer.Node prev; volatile AbstractQueuedSynchronizer.Node next; volatile Thread thread; AbstractQueuedSynchronizer.Node nextWaiter;&#125; 可以看出其实就是一个双向队列，应该是非常容易理解的。在这个对象里面设置了好几种状态值，这主要用于设置锁的状态值。 CANCELLED =&gt; 取消状态 SIGNAL =&gt; 等待触发状态 CONDITION =&gt; 等待条件状态 PROPAGATE =&gt; 状态需要向后传播 后面具体在介绍其中的含义，不过我倒是觉得这几个状态值应该自己用个枚举维护会更好。。。 而SHARED对象是用于共享锁如(CountDownLatch),EXCLUSIVE则是用于独占锁(ReentrantLock) 方法原理本文将从独占式和非独占是锁两部分分别讲述一下AQS的工作原理。 独占式锁首先介绍一下acquire方法，此方法是以独占模式获取对象，忽略中断。tryAcquire方法尝试获取锁，需要子类自己实现。 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 这里主要是三个步骤： 1.首先直接先尝试获取锁(tryAcquire)，如果获取到就结束了，如果获取不到;2.则会将这个线程加入到等待队列(addWaiter(Node.EXCLUSIVE), arg));3.进行自旋，尝试获取锁(acquireQueued)。这也是和synchronized方法不同的地方。 当获取失败的时候就需要将线程加入到等待的队列中，看一下addWaiter方法的具体实现。 1234567891011121314151617private Node addWaiter(Node mode) &#123; //将当前线程包装成一个节点 Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // 如果存在等待的队列，直接加入到队尾 if (pred != null) &#123; node.prev = pred; //使用CAS方式设置tail节点 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //不存在的时候创建队列 enq(node); return node;&#125; 这里总共做了三件事情 1.首先把当前对象包装成一个node 2.判断等待队列是否为空，如果等待队列已经存在，直接添加到队列末尾 3.如果为空的话，需要尝试新建一个等待队列 为什么说是尝试新建队列，下面看一下具体enq方法的实现就能知道 12345678910111213141516private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; //初始化队列头 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //如果已经初始化了就添加到队尾 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 此处为什么要这么设计，因为AQS的方法都是没有加锁的，所以很有可能进入enq方法的时候别的线程初始化过等待队列了。所以此处也是用CAS操作，都是为了防止发生错误的可能性。关于CAS的详细介绍，可以自己查阅相关的资料。 上面介绍完加入队列后，下面就要看一下acquireQueued方法的实现了，大概也能猜到是怎么进行自旋的。 123456789101112131415161718192021222324final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取node的前一个元素，满足条件就直接设置为新的队头，p就要被干掉 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; //如果不满足条件，就需要把线程挂起并检查中断状态 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; //如果最终都没有找到合适的，取消等待的节点 if (failed) cancelAcquire(node); &#125;&#125; 上面的方法是线程自旋获取锁的方法,主要做了一下几件事情 1.首先检查当前节点是否为head的下一个节点,如果是=&gt;第二步,否则=&gt;第三步2.尝试获取锁,如果获取失败则可能被别人插队了…则进行第三步,如果成功将当前线程设置为头节点,返回3.如果没有获得锁,则挂起当前线程并检查中断状态,此状态主要用于wait方法 此处节点会一直检查当前是否为下一个被唤醒的位置。如果没有到就会检测中间元素是否已经被取消，如果取消了就去除中间这个节点。 具体看一下实现shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法的实现 1234567891011121314151617181920212223private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //获取前面节点的状态值 int ws = pred.waitStatus; //表示等待被唤醒，直接返回 if (ws == Node.SIGNAL) return true; //大于0代表CANCELLED状态，将会被取消，此处就会移除节点， if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //否则设置为SIGNAL状态，表示等待被唤醒，获取锁 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;//真正的挂起锁，并检测是否被中断了private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 此处就是使用到了文章开始所说的那几个状态值， 1.当node前一个节点的状态值为SIGNAL，表示这个节点是可以等待锁的。 2.如果不满足ws&gt;0，表示前一个节点已经被取消，则干掉取消的节点。（他只管在他前面的那个节点，至于更前面的，就交给前面节点的线程去检测了） 3.否则就把pred的状态设置为SIGNAL。 最后如果失败了，会执行finally中的cancelAquire方法,先用一张图来看一下（来自百度） 1234567891011121314151617181920212223242526272829303132private void cancelAcquire(Node node) &#123; if (node == null) return; node.thread = null; Node pred = node.prev; //清除节点前面的已经取消的节点 while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; Node predNext = pred.next; node.waitStatus = Node.CANCELLED; //如果节点在末尾，直接将前一个不为cancel的节点设置为末尾节点 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; int ws; //前节点不是队头，并且是等待的状态，设置连接的状态 if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; //pred.next的pred =&gt; node.pred if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; //否则就是获得锁 unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125; 在自旋中发生意外进入到finally的取消方法，其中的主要逻辑再次梳理一下： 1.如果当前的节点是空的，直接返回 2.如果上一个节点被取消，改变节点的连接状态，如果当前元素是tail，尝试将pred的下一个节点设置为null 3.如果不是tail元素，当前元素也不是head，将pred.next设置为node.next 4.否则帮助一下个元素获取锁(处于队列头了)。 具体看一下我们的unparkSuccessor方法 12345678910111213141516171819private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; //如果node小于0 设置为0，为什么有这一步？ if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; //如果当前节点的下一个节点也是被取消的 if (s == null || s.waitStatus &gt; 0) &#123; s = null; //从后往前找到node后的第一个没取消的节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //解锁这个节点 if (s != null) LockSupport.unpark(s.thread);&#125; 自己到了下一个被唤醒的线程时，需要分情况的进行解锁，因为unparkSuccessor方法是多个地方都要被使用的，所以虽然在我们的cancelAquire方法中，node已经设置为CANCEL状态，但是其他方法调用的时候node的状态就不确认了，所以这也是为什么还要继续判断状态的理由。 并且找到自己的下一个元素没被取消的节点，让他获得锁。需要注意的是如果下一个节点取消的话,就会采取从后往前找的方式,知道排列在最前面的那个节点.为什么采用这种方式,因为我们在之前的代码也可以看到,在进行设置next节点的时候都上用CAS的方式,所以next节点设置成不成功也都是不确定的,而且没有一直进行尝试.从后往前保证了不会出现问题. 释放锁看完获得锁之后，我们看一下如何进行锁释放的。 12345678910public final boolean release(int arg) &#123; //尝试释放锁 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 和获得锁一样tryRelease方法也是需要子类自己进行实现的。如果释放锁成功的话，就开始unparkSuccessor 方法为head的下一个节点获得锁。 这里就也用到了unparkSuccessor方法。同时我们再次看unparkSuccessor方法就会清晰很多,明白为什么要那么多判断了。 非独占式锁1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 和上面独占式锁的流程非常类似，我们再看一下doAcquireShared方法所做的事情。 1234567891011121314151617181920212223private void doAcquireShared(int arg) &#123; //添加一个非独占式的节点 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); //判断是否到了一下个解锁的位置了 if (p == head) &#123; int r = tryAcquireShared(arg); //如果成功获取锁，就设置head并传播 if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; ...省略&#125; 此处和独占式不同的地方主要在setHeadAndPropagate方法，因为独占式获取了只会更改自己的状态。共享式则会传播到其他的节点。 1234567891011private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); //满足条件调用doReleaseShared方法 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125; &#125; 哈哈看到这里，就直接到释放锁的方法了 12345678910111213141516171819private void doReleaseShared() &#123; //循环释放锁 for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; 看懂了独占式，看非独占式就很简单了。 结语为什么我们需要了解AQS，这是因为Lock锁，线程池，信号量（Semaphore）就是基于AQS实现的。 所以AQS是基础，当时我看ReentrantLock的时候就是一脸懵逼，当看完AQS之后再次看的时候就清晰很多了。同时不得不佩服Doug Lea大神。 本文主要的是基于自己的一些观点写的，如有表达不当或者描述错误的地方，欢迎给我反馈。 与君共勉！！ 参考文献 占小狼-深入浅出java同步器AQS java8-AbstractQueuedSynchronizer文档","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"Go 初学者成长之路","slug":"go-learn-material","date":"2018-01-12T05:36:18.000Z","updated":"2018-01-12T06:09:19.312Z","comments":true,"path":"2018/01/12/go-learn-material/","link":"","permalink":"http://www.eumji025.com/2018/01/12/go-learn-material/","excerpt":"","text":"本文转载自Halfrost-Field 冰霜之地,以获取授权 开源书籍 书籍名 地址 推荐理由 Go 指南 https://tour.go-zh.org/ 初学者熟悉 Go 语法的 palyground,无须搭建本地 Go 的环境，在线就编写 Go 的代码 Go实战开发 https://github.com/astaxie/go-best-practice 这本书还没有完成，但是基础的基本都讲完了，这个书的作者就是著名的 Go 开源项目 beego 的作者 @astaxie，他的最佳实践非常值得阅读 Go Web 编程 https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md gitbooks地址 这个本的作者也是上本书的作者 @astaxie，从开发环境搭建到构建一个 Web 应用，讲解的都非常详细，@astaxie 的这两本书非常值得深度学习和阅读，本书已经完全写完了 GO 命令教程 https://github.com/hyper0x/go_command_tutorial 《Go并发编程实战》作者郝林书中的示例 Go入门指南 https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md 这本书也非常适合初学者，不过看了上面几本书以后，看这本书，前面一些基础内容都可以很快的刷过去了，这本书可以主要看高级编程和实际应用这两大部分 Go语言圣经 http://docs.ruanjiadeng.com/gopl-zh/index.html 这本书是 Go 语言著名书籍《The Go Programming Language》的中文翻译版，如果觉得翻译的书不好，可以直接去看原著 Go by Example https://gobyexample.com/ 推荐这个网站的原因是这里有好多值得初学者学习的例子，这里可以作为初学者“抄”(学习)代码的地方 Go-SCP https://checkmarx.gitbooks.io/go-scp/content/ 这本书是关于 Go 安全相关的，本人还没有读过，为何放在这里？因为是我老大推荐的? 编译器1. Vim党Vim党当然是不需要 IDE 的，直接 Vim + Vim-go（或者 Emacs） 2. 文本编辑器 + 插件目前最常用最火的文本编辑器有 VSCode、Sublime、Atom 他们都可以安装相应的插件，就可以支持 Go 的编码了。我暂时用的是 Atom + go-plus，界面还比较美，如下图： 3. IDE目前用的比较多的 IDE 有：IntelliJ idea、Goland、LiteIDE。 学习网站 网站名 地址 推荐理由 The Go Programming Language https://golang.org/ Go 的官方网站 Go 编程语言 https://go-zh.org/ Go 官网对应的中文网站 The Go Blog https://blog.golang.org/ Go 的官方博客 The Go Packages https://golang.org/pkg/ Go 的包官方文档 Go 标准库中文文档 http://cngolib.com/ Go 标准库中文文档 视频这个也看个人吧，有些人不喜欢看文档，或者有时候文档看累了看会视频。下面这些视频本人看过开头的，觉得讲的还可以，不过后面的我没有继续看下去了，因为觉得看视频学习有点慢，我还是选择看刷书刷题啦~? 网站名 地址 推荐理由 Go 编程基础 https://github.com/Unknwon/go-fundamental-programming 这套视频适合初学者 Go Web 基础 https://github.com/Unknwon/go-web-foundation 这是一套针对 Google 出品的 Go 语言的视频语音教程，主要面向完成《Go 编程基础》教程后希望进一步了解有关 Go Web 开发的学习者。 Go名库讲解 https://github.com/Unknwon/go-rock-libraries-showcases 这是一套针对 Google 出品的 Go 语言的第三方库进行评测讲解的集博客、示例与语音视频为一体的综合教程，适合完成学习完成《Go编程基础》教程的学习者。 Go语言第一课 慕课网上的课程 这个课程的录制者是郝林，如果你是他的粉丝，可能你就不想错过这个课程 社区 Go语言社区（排名不分先后） https://gocn.io http://studygolang.com http://www.golangtc.com http://www.golangweb.com 最后，多多练习，多多实践 Go，只要功夫深，铁杵磨成针！ GitHub Repo：Halfrost-Field Follow: halfrost · GitHub Source: https://halfrost.com/new_gopher/ 结语go语言初学者,个人喜欢goland. 与君共勉!!!","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.eumji025.com/tags/golang/"}]},{"title":"HashMap源码分析","slug":"hashmap-analysis","date":"2018-01-06T03:06:50.000Z","updated":"2018-01-21T11:29:56.441Z","comments":true,"path":"2018/01/06/hashmap-analysis/","link":"","permalink":"http://www.eumji025.com/2018/01/06/hashmap-analysis/","excerpt":"","text":"HashMap介绍HashMap是基于hash表的map的实现,使用key-value形式存储键值对，并允许使用 null 值和 null 键,但是key只能有一个为null. Map不保证映射的顺序，其内部是根据hash值去模运算去排列的。HashMap内部使用entry数组作为存储的介质. 本文是基于Java8版本写的,因为Java8对HashMap有较大的改变,采用数组+链表+红黑树方式来记录键值对.而且Java8还重写了resize方法,Java8之前很有可能造成扩容时,链表的循环问题. 源码解读本文中的代码比较多,大多数的说明都在注释上体现了,所以可能文字上表述的不是很多,本文也尽可能介绍了一些java8中的新方法.需要注意的是其中很多地方都进行了修改和补充,看完本篇文章一定和之前看的Java7 HashMap有非常多的不同之处,也可以思考一下为什么Java8要做这么多改变. Node介绍Node是map的接口中的内部接口Map.Entry的实现类,用于存储HashMap中键值对的对象,是HashMap中非常重要的一个内部类,随便提一下,HashMap中有非常多的内部类,本文没做过多的介绍,读者可以自己翻看一下源码,因为篇幅实在太长了…在这里就简单的讲一下,大部分的内部类都是用于集合操作的,如keySet,values,entrySet等方法. 内部组成 12345678910static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//key是不可变的final K key;//valueV value;//指向下一个entry对象,具体作用后面介绍Node&lt;K,V&gt; next;//hash值int hash;&#125; HashMap组成HashMap主要参数 12345678static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //默认初始容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认负载因子,相当于只有多少可用transient Node&lt;K,V&gt;[] table;//要存储值的hash表transient int size; //实际大小int threshold; //阈值final float loadFactor;//负载因子transient int modCount; //记录操作次数的 相比之前版本的HashMap,Java8更钟爱与位操作.>&gt; 表示逻辑右移>&gt;&gt; 表示无符号逻辑右移.高位补零 HashMap构造方法 123456789101112131415161718//为空时候使用默认分配的大小16,负载因子0.75f,默认的容量为12,当size&gt;threshold默认容量时候就会去扩容public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;//构造方法 初始化负载因子和阈值public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + //容量判断 initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //负载银子判断 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; HashMap方法本文主要挑选几个比较常用且重要的方法进行分析.因为这写方法已经涵盖了大部分的方法调用关系. hash方法使用hashcode 异或 hashcode右移16位 得到hash值,等同于高位都取零随带提一句,int类型的hashcode就是本身.1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; put方法解析put方法,是HashMap中非常重要的方法,其中牵涉到了非常多的知识点,需要仔细的阅读. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * onlyIfAbsent 是否替换,为true时,如果存在值则替换 * evict 主要用于LinkedHashMap移除最近未使用的节点 */final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //未初始化则扩容(扩容包括新建和扩容) if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果不存在,直接put if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //根据条件获取不同的node节点,有可能tab[i]就是存在的元素 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //否则判断是树,添加 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //否则普通的链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; //到尾都没找到,添加一个节点 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //判断是否转化为树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //转换成树的具体内容就不描述了,篇幅太长 treeifyBin(tab, hash); break; &#125; //找到记录 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //存在,替换 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //用于linkedHashMap,本文不做介绍 afterNodeAccess(e); return oldValue; &#125; &#125; //添加成功,判断是否要扩容 ++modCount; if (++size &gt; threshold) resize(); //用于linkedHashMap afterNodeInsertion(evict); return null;&#125; 下面详细介绍一下扩容的方法.看起来非常庞大.其实逻辑不复杂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 有几种情况 * 1.当为空的时候,也就是没有初始化的时候 * 2.当到达最大值时候 * 3.普通扩容时候 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //存在旧值 if (oldCap &gt; 0) &#123; //大于2&lt;&lt;30 最大容量设置为2&lt;&lt;32 - 1 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //但是不移动.,没有空间移动 threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果属于正常范围的扩容 容量 x2 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //用户自己设定了初始化大小 else if (oldThr &gt; 0) &#123; newCap = oldThr; &#125; //如果没使用,使用默认值初始化 else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //用户自定义了map的初始化操作 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //新的容量 threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果是扩容操作 if (oldTab != null) &#123; //遍历map的数据 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果当前位置只有一个元素,直接移动到新的位置 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果是红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //如果没超过8个 是链表 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; //此处的操作是这样子的 因为是扩容一倍的操作,所以与旧的容量进行与操作后只有两个值0 和 1 //如果是0就位置不变,如果是1就移动n+old的位置, //个人认为这么做的好处是: /** * 1.不会像之前1.7发生循环依赖的问题 * 2.从概率的角度上来看可以均匀分配,(一般来说高位和低位比例差不多) * 3.提高效率 */ do &#123; next = e.next; //如果和旧容量位运算后的值是0,记得当前节点和存放在链表的尾部 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //同上 else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //为0的还是存放在当前位置 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //为1的就放在扩容的j + oldCap那边去 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 因为不像Java8之前的HashMap有初始化操作,此处选择将初始化和扩容放在了一起,并且又增加了红黑树的概念,所以导致整个方法的判断次数非常多,也是这个方法比较庞大的主要原因. 值得一体的是,在扩容后重新计算位置的时候,对链表进行优化,有兴趣可以搜索一下HashMap导致cpu百分之百的问题而在Java中通过巧妙的进行&amp;操作,然后获得高位是为0还是1.最终移动的位置就是低位的链表留在原地,高位的放在index+oldsize的地方就可以了,不用为每一个元素计算hash值,然后移动到对应的位置,再判断是否是链表,是否需要转换成树的操作.如下所示.12hashcode: 1111111111111101212oldcap: 0000000000000010000 很容易知道这个&amp;操作之后就是为0,因为oldcap都是2的倍数,只有高位为1,所以通过&amp;确认高位要比%取余高效.此时在看一下上面的扩容操作也许就更清晰了. 下面介绍一些newNode方法.就是新建一个节点.可以思考一下为什么要把newNode抽离出来?文章末尾给答案.123Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next);&#125; 添加节点到红黑树的方法是Java8中新添加的,需要满足链表的长度到8,才会转换成红黑树,其主要目的是防止某个下标处的链表太长,导致在找到的时候速度很慢,下面看一下实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//尝试着往树节点添加值final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; //找到根节点 TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; //存在的话直接返回,用于替换 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; //判断节点类型是否相同,不相同 else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; //没有搜索过,搜索子节点,搜过了说明没有就跳过. if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; //去子节点去找 if (((ch = p.left) != null &amp;&amp;(q = ch.find(h, k, kc)) != null) ||((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; //对比hash值,决定查找的方向 dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; //找到子节点为空,就可以加进去,设置层级关系 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125;&#125; 这里简单的梳理一下流程.1.从根节点查找,找到了返回,如果没找到,找字节点2.判断往哪个方向去查找3.如果不存在,在子节点末端添加新节点 下面再看一下树的split方法,主要是扩容操作,重新结算位置需要分裂树,之前讲过,扩容会根据和旧map容量进行&amp;操作,移动高位为1的节点.并且验证新的节点列表是否需要重新转换成链表的形式. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // 设置记录高低位的node,和链表一样都是计算高位是0还是1 TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; //还是和旧的容量做位运算,为0的放在lo中 if ((e.hash &amp; bit) == 0) &#123; //判断是否为头部 if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; //获取为1的放在hi中 else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; //lo链表的处理 if (loHead != null) &#123; //如果小于7,那么当做链表处理 if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; //转换成树 tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; //同上 if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125;//把树转换成链表final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd;&#125; 转化成红黑树的详情本文就没详细介绍了,我相信很容易看懂.这里借｀美团点评技术团队｀的一张图来展示一下put方法的流程 get方法 逻辑其实很简单,就是首先通过hashcode确认位置,然后分数据结构类型继续不同方式的查找1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //找到位置,并且当且位置存在元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp;((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //链表或者树,遍历子节点 if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; remove方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;/** * 1.寻找是否存在,如果存在分数据类型分别处理 * 2.如果为树,稍微复杂一点,需要判断是否要转换成链表,然后就是树的移动 */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //找到节点 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; //从树节点获取 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //找到了对应的节点 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; //树节点处理 主要是两点,存在删除,删除了是否需要转换成链表 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); //一个元素 else if (node == p) tab[index] = node.next; else //指向node的下一个 p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 本文就不看树的详细删除过程了,内容太多太长.可以自己想象一下树的删除过程.replace方法12345678910111213@Overridepublic V replace(K key, V value) &#123; Node&lt;K,V&gt; e; //找到节点替换 if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; //与linkedHashMap有关 afterNodeAccess(e); return oldValue; &#125; return null;&#125; 从基本的方法中我们可以看出,最复杂的就是put方法,put方法设计非常多的方法,后续的get,replace,remove都是建立在put方法基础之上. 补充方法上面介绍了几个基本的方法,另外现在介绍一些有用的小方法.都是在Java8新增的. merge方法merge方法的主要作用是如果不存在就进行添加,如果存在的话按照自己指定的remappingFunction进行操作,如果操作之后value为null的话删除元素,否则替换,下面是代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public V merge(K key, V value,BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; //扩容操作 if (size &gt; threshold || (tab = table) == null ||(n = tab.length) == 0) n = (tab = resize()).length; //通过key找到元素,分为树和链表两种情况 if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; //存在旧的结点,进行合并操作 if (old != null) &#123; V v; if (old.value != null) //具体的合并操作 v = remappingFunction.apply(old.value, value); else v = value; //合并成功,执行afterNodeAccess方法,子类linkedHashMap有用 if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; //合并之后没有值,删除元素 else removeNode(hash, key, null, false, true); return v; &#125; //没有旧结点,直接添加,考虑扩容,链表和树的情况 if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value;&#125; compute方法123456789101112131415161718192021public V compute(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; //省略部分基本和merge方法的前半段一直,不重复展示 //获取旧元素 V oldValue = (old == null) ? null : old.value; //计算出新值 V v = remappingFunction.apply(key, oldValue); //存在旧元素,旧赋值到旧元素上 if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; //计算结果为空则删除 else removeNode(hash, key, null, false, true); &#125; //r如果没有旧元素,但计算出的值不为空,添加操作,和merge方法相同,省略 return v;&#125; 看到这里我相信大家都有疑问,为什么要放两个几乎相同的两个方法, 我们详细对比一下两个方法,发现会有几点不同: 参数不同,merge方法要求value不为null,compute方法没有要求; merge方法要求old.value也不为null.compute的方法依然没有要求. 另外compute还有两个扩展方法,简单介绍一下. computeIfAbsent方法如果oldvalue不为null就不替换,如果计算后的值不存在直接返回,否则如果old不为null,通过key计算出值替换,否则添加到map中12345678910111213141516171819public V computeIfAbsent(K key,Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; //扩容等操作省略,同上 V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; //注意这里 V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; //添加操作省略&#125; computeIfPresent方法不进行扩容的判断(因为不存在找不到就添加这样的操作).直接通过key查找,如果找到,且计算的结果不为null,替换,否则就直接删除12345678910111213141516171819public V computeIfPresent(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; //注意这里 V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; 再次总结一下三个compute方法的异同点 compute方法和computeIfPresent方法都需要oldValue,computeIfAbsent不需要 compute的remappingFunction.apply方法不限制oldvalue是否为null,但是computeIfPresent限制必须不为null才进行,computeIfAbsent方法必须要old或者oldvalue为null才会进行后续操作 computeIfPresent只有oldvalue存在则进行apply方法,然后根据条件替换或者删除操作,而compute和computeIfAbsent方法则是如果old不存在,还会根据条件额外进行添加操作 简单点说就是: 如果是不存在oldvalue才进行操作,这也可以认为我们在声明了String a = null这样的操作,现在需要进行初始化,选择computeIfAbsent方法, 如果必须存在oldvalue才操作,而且只进行删除或者修改的操作则选择computeIfPresent方法,类似看看还有没有修改的价值,没价值就干掉了. 其他选择compute方法 快速失败和安全失败问题 12345678910一：快速失败（fail—fast） 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。二：安全失败（fail—safe） 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 解答解释一下刚才在文章设置的悬念,为什么要把newNode方法单独提出来,其实这里很大一部分原因是因为Linkedhashnap会需要重写此方法进行额外的操作.具体是什么可以自己查看一下源码,或者看我的另一篇文章,map集合类总结. 总结改版后的HashMap看起来更加的庞大和神秘了,因为相比之前看起来可能方法更大而且还有红黑树这个数据结构,看到代码就会让人感觉好难受,同时也呼吁每个人都不要写这么庞大的方法.尽可能将方法拆小.变得更加的简洁明了.但是Java8对HashMap的改变,使得HashMap在一定程度上提升了性能,并且还新填了不少的方法. 当然本文只是个人的一些看法,如果存在不足或者错误的地方,欢迎大家指正!!! 结语与君共勉!!!","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"动态代理及Proxy源码分析","slug":"dynamic-proxy","date":"2018-01-02T03:23:46.000Z","updated":"2018-01-04T12:40:21.614Z","comments":true,"path":"2018/01/02/dynamic-proxy/","link":"","permalink":"http://www.eumji025.com/2018/01/02/dynamic-proxy/","excerpt":"","text":"前言 代理是java中非常重要的一种设计模式,动态代理则可以认为是一种动态代理的最佳实践,本文将由浅及深的介绍动态代理及其proxy源码分析,文章写的不一定都对,请各位看官带着批判的态度阅读此文章. 代理模式是设计模式中的一种,而且在实际的开发中使用的频率非常高 ,比如spring AOP,mybatis代理都是我们经常使用的. 代理模式的定义: 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。 静态代理从上面的介绍中可以看出代理模式其实本意是为了解决访问存在困难或者为了保证透明性的一种工具,有点类似于我们无法访问google,需要一个中间代理商的帮助是一致的.下面通过一个简单的例子来介绍: 12345678910111213141516171819202122232425262728293031323334353637383940public class ProxyDemo &#123; static interface BaseUser&#123; void info(); void real(); &#125; static class ProxyUser implements BaseUser&#123; BaseUser baseUser; public ProxyUser(BaseUser baseUser) &#123; this.baseUser = baseUser; &#125; public void info() &#123; System.out.println(\"I'm Proxy,I can help you\"); &#125; public void real() &#123; System.out.println(\"I will help you visit google\"); baseUser.real(); System.out.println(\"I had help you visit google\"); &#125; &#125; static class TargetUser implements BaseUser&#123; public void info() &#123; System.out.println(\"I'm google,what you what do?\"); &#125; public void real() &#123; System.out.println(\"I.m google,this is searched info\"); &#125; &#125; public static void main(String[] args) &#123; BaseUser targetUser = new TargetUser(); BaseUser proxyUser = new ProxyUser(targetUser); proxyUser.info(); proxyUser.real(); &#125;&#125; 在这里我们也可以认为代理者是两者访问或者交互的载体,需要对双方都非常的熟悉,才能帮你做具体的事,就像如果我现在需要代购,可能就需要找新的代理人!!! 这里也就是我们所说的静态代理 虽然静态代理也能帮我实现一些功能,但是只能说不够强大,此时我们就可以使用动态代理来帮我们更加灵活的去搞事情 动态代理动态代理的优势：1. 降低各个功能模块之间的耦合度，提高开发的效率和方便程序的维护度。 2. 减少代码量。 3. 不关注目标的具体实现。 动态代理的实现JDK动态代理 jdk自带的动态代理主要是通过实现InvocationHandler InvocationHandler的主要方法 Object invoke(Object proxy, Method method,Object[] args)throws Throwable 在代理实例上处理方法调用并返回结果。在与方法关联的代理实例上调用方法时，将在调用处理程序上调用此方法。即调用真实业务的方法都会进入到此invoke方法,至于为什么,稍后再说明 方法详细介绍 参数：proxy - 调用方法的代理实例对象 method - 代理实例对象调用的接口方法的 Method 实例对象。 Method-指代具体被代理的方法。 args -包含传入代理实例上方法调用的参数，如果接口方法不使用参数，则为 null。 return：从代理实例的方法调用返回的值。 throws： Throwable - 从代理实例上的方法调用抛出的异常。 ​ 案例本案例演示的是最常用的拦截方法然后记录日志的功能。 3.1 业务接口 123public interface Base &#123; public void hello(String name);&#125; 3.2 业务实现类 LoginImpl 123456public class LoginImpl implements Base&#123; @Override public void hello(String name) &#123; System.out.println(&quot;welcome &quot;+name+&quot;, success !!1&quot;); &#125;&#125; 3.3 代理类 LoginProxy 123456789101112131415161718192021222324252627282930313233343536373839404142class DynamicProxy implements InvocationHandler &#123; Object originalObj; Object bind(Object originalObj) &#123; this.originalObj = originalObj; return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this); &#125; /** * 切入点 对所有对象的方法都进行调用 * method.invoke方法对应代理对象调用login方法 * @param proxy 代理对象 * @param method 代理对象的方法 * @param args 代理对象调用接口方法的参数值 * @return 代理对象调用方法的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object invoke = method.invoke(originalObj, args); if (invoke != null)&#123; result(invoke); &#125; after(); return invoke; &#125; private void before() &#123; System.out.println(&quot;方法执行之前&quot;); &#125; private void after() &#123; System.out.println(&quot;方法执行之后&quot;); &#125; private void result(Object o) &#123; o.toString(); &#125;&#125; 3.4 测试类 LoginClient 1234567public class LoginClient &#123; public static void main(String[] args) &#123; //用于生成代理文件 //System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;); Base hello = (Base) new DynamicProxy().bind(new LoginImpl()); hello.hello(&quot;zhangsan&quot;); &#125;&#125; 3.5 执行结果： 123方法执行之前Hello zhangsan方法执行之后 从上面的例子我们可以看到动态代理有效的减少了各个模块的耦合度,用于实现日志功能的代码和用于实现登陆功能的代码相互隔离。对两者都没有条件限制,.只有在真正调用业务的时候并需要日志功能时候二者才发生联系。任何业务需要日志功能只需要通过代理类创建代理对象即可,不需要重复创建代理类. 究其原理System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);取消掉此方法的注释,我们运行或编译代码后将生成代理的文件,默认是项目根目录下的于包名同名的文件夹下。下面我们看一下生成的代理类反编译后的内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import ProxyDemo.Base;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;//$Proxy0是生成代理的格式决定的final class $Proxy0 extends Proxy implements Base &#123; //将基础的tostring,equils,hashcode,还有base接口的方法生成method的对象 private static Method m1; private static Method m2; private static Method m4; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void out() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; //具体的实现 static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m4 = Class.forName(\"ProxyDemo$Base\").getMethod(\"hello\", Class.forName(\"java.lang.String\")); m3 = Class.forName(\"ProxyDemo$Base\").getMethod(\"out\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 首先从类的继承关系就很容易理解Proxy.newProxyInstance(originalObj.getClass().getClassLoader(),originalObj.getClass().getInterfaces(), this);方法的作用了. 即继承了proxy类也实现了Base接口.这也是Base hello = (Base) new DynamicProxy().bind(new LoginImpl());这也是为什么可以强转为Base对象的原因.同时在代理中将object类中的equils,tostring,hashcode以及所有base接口的方法生成对应的代理方法. 以hello方法为例介绍一下,h表示的是proxy类中的InvocationHandler其实也就是指代我们之前的DynamicProxy对象,然后调用invoke方法就回到DynamicProxy的invoke方法.我们就可以再次做很多中间的操作。 12345678910public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125;&#125; Proxy解读看完了代理类的内容后,接下来我们就需要去详细的看一下Proxy是如何生成$Proxy0这个代理类的.了解一下其中的工作流程和原理。 首先看newProxyInstance方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); //获取需要代理类的所有实现的接口 final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; //检查是否有生成代理类的权限 checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; //查找或者生成代理类 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //生成构造函数 try &#123; if (sm != null) &#123; //检查是否有权限 checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; //public $Proxy0(InvocationHandler var1) final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; //访问修饰符设置 if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; //返回代理类的对象 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException | InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; 具体的实现逻辑在getProxyClass0方法中，最外面的方法只是描述了生成代理后然后创建对应的代理对象。首先看一下checkProxyAccess方法的具体内容 123456789101112131415161718192021222324252627282930//主要作用检查权限是否可以操作 private static void checkProxyAccess(Class&lt;?&gt; caller, ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader ccl = caller.getClassLoader(); //classloader验证 if (VM.isSystemDomainLoader(loader) &amp;&amp; !VM.isSystemDomainLoader(ccl)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; // ReflectUtil.checkProxyPackageAccess(ccl, interfaces); &#125; &#125; //检查接口的包权限 public static void checkProxyPackageAccess(ClassLoader var0, Class... var1) &#123; SecurityManager var2 = System.getSecurityManager(); if (var2 != null) &#123; Class[] var3 = var1; int var4 = var1.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; Class var6 = var3[var5]; ClassLoader var7 = var6.getClassLoader(); if (needsPackageAccessCheck(var0, var7)) &#123; checkPackageAccess(var6); &#125; &#125; &#125; &#125; 当验证完权限之后,查看如何获取代理类的getProxyClass0方法123456789private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; //从缓存中获取,如果不存在就创建 return proxyClassCache.get(loader, interfaces); &#125; 使用proxyClassCache做缓存，其目的是为了复用，同时防止多线程重复创建。在weekCache类中使用了多个map进行记录,稍后我们再做详细介绍. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//获取或生成代理类 此处因为不是线程安全的做了多次判断public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); //删除过期条目 expungeStaleEntries(); //创建cacheKey Object cacheKey = CacheKey.valueOf(key, refQueue); //查看key是否已经存在valuemaps中 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; //不存在的话通过,再次尝试尝试获取,如果没有就插入 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; //生成代理对象的key 为弱引用类型 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); //尝试从valuemap中获取 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; //如果确实已经有线程创建了 if (supplier != null) &#123; //直接获取 supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; //最终返回value return value; &#125; &#125; // 不存在创建一个supplier factory实现了supplier if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; //如果不存在则保存到valuemap中 supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // 添加成功 supplier = factory; &#125; // 创建的时候发现已经有了,尝试替换 &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; //替换成功 supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125;&#125; get方法首先去查看是否存在缓存过期的情况,存在则清除掉.如果不存在,尝试的生成key和value的相关元数据, 下面介绍key的生成方法KeyFactory.apply方法123456789//根据接口个数的不同选择生成不同的key对象public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125;&#125; 然后在判断是否存在同时其他线程生成,然后就是尝试着保存添加信息,如果已经有了就尝试替换.最终通过supplier.get()方法获取,最终实际的逻辑在supplier.get()方法中,下面看一下具体的过程123456789101112131415161718192021222324252627282930313233public synchronized V get() &#123; // serialize access // 再次检查是否匹配 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; //因为此方法调用之前有可能发生valuesMap.replace(subKey, supplier, factory) return null; &#125; // 创建 V value = null; try &#123; //真正的逻辑,重点方法 value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // 如果最终没能生成代理对象,从valuemap移除 valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; //包装value为acacheValue CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // 保存到reverseMap reverseMap.put(cacheValue, Boolean.TRUE); // 尝试这替换valuemap中的cacheValue if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError(\"Should not reach here\"); &#125; return value; &#125; 下面详细介绍value的ProxyClassFactory.apply方法.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 //apply方法详解public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; Class&lt;?&gt; interfaceClass = null; try &#123; //使用给定的类加载器加载接口 interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; //验证是否为接口 if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; //验证接口不是重复的 if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; //修饰符 int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * 验证接口的可见性 * 如果不是public类型的接口又不在同一个包下抛出异常 */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; //如果不是public类型的接口又不在同一个包下抛出异常 else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // 没有包使用默认的包 com.sun.proxy proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * 代理类的名称 按顺序递增 =&gt; $proxy0 */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * 生成代理类的字节数组 */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; //调用native方法生成Class return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125; 主要的步骤如下 1.尝试着用现有的类加载器加载接口,如果成功 2.验证是否为接口,接口是否重复 ,如果成功 3.验证接口访问权限,如果成功 4.获取包的信息,和类名设置, 5.生成代理的字节数组 6.通过native方法defineClass0获取字节数字的具体的Class 这里着重讲解一下如何生成字节数组的 1234567891011121314151617181920212223242526272829303132333435363738394041 //生成代理类public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123; ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2); /** * 生成具体文件字节数组 * 1.找到所有接口的方法 * 2.添加object类的三个方法 tostring hashcode equils * 3.遍历生成具体的代理方法,代理方法的逻辑都想似,回调我们的代理类 */ final byte[] var4 = var3.generateClassFile(); // private static final boolean saveGeneratedFiles = GetBooleanAction(\"sun.misc.ProxyGenerator.saveGeneratedFiles\"))).booleanValue(); //这就是我们为什么设置sun.misc.ProxyGenerator.saveGeneratedFiles = true的原因,设置后就会生成代理类的文件 if (saveGeneratedFiles) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int var1 = var0.lastIndexOf(46); Path var2; if (var1 &gt; 0) &#123; //生成path 将.替换成系统文件分隔符 Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar)); //创建文件夹 Files.createDirectories(var3); //具体文件 var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + \".class\"); &#125; else &#123; //没包就放在项目根目录下 var2 = Paths.get(var0 + \".class\"); &#125; //写入到文件中 Files.write(var2, var4, new OpenOption[0]); return null; &#125; catch (IOException var4x) &#123; throw new InternalError(\"I/O exception saving generated file: \" + var4x); &#125; &#125; &#125;); &#125; return var4;&#125; 主要的方法是通过ProxyGenerator对象生成字节数组,具体生成的步骤可以如下几步: 1231.找到所有接口的方法2.添加object类的三个方法 tostring hashcode equils3.遍历生成具体的代理方法,代理方法的逻辑都想似,回调我们的代理类 我可以通过之前展示的一个代理方法即可才想到其中的大概流程. 123456789public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; 最主要不同的地方就是方法名,方法参数,invoke方法的参数。其他的几乎都相同。本文就不做代码上的具体介绍. 然后通过sun.misc.ProxyGenerator.saveGeneratedFiles 的值,来决定是否生成代理文件到磁盘. 如果生成,则生成包信息,类信息,然后将字节数组写入到文件中.默认情况下和在项目的根据下,创建和包名的文件夹和$proxy+i的代理文件. 缓存从我们的代码中我们可以看到WeekCache中使用多个map进行记录12345678910111213//cachekey的引用队列,于JVM关系密切详细介绍请看这篇文章http://blog.csdn.net/u012332679/article/details/57489179private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;(); // 最外层map,key=&gt;cacheKey,value =&gt; valueMap private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;(); //记录保存value的Supplier对象map private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;(); //key生成对象 private final BiFunction&lt;K, P, ?&gt; subKeyFactory; //value生成对象 private final BiFunction&lt;K, P, V&gt; valueFactory; map中的key是cacheKey,是一种弱应用类型的对象,reverseMap的key是cacheValue,同为一种弱应用类型的对象.两者也同时为内存回收的主要对象,当某个map中的key失效的时候,在下一次进行get,containsValue,size三个方法的时候都会触发expungeStaleEntries方法,然后将value从reverseMap中清除,valuemap从map中清除.而refQueue的回收,是由Reference中ReferenceHandler轮询去回收的.如果回收了,refQueue.poll会成功触发,然后就想清除操作.1234567891011121314151617181920private void expungeStaleEntries() &#123; CacheKey&lt;K&gt; cacheKey; while ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != null) &#123; cacheKey.expungeFrom(map, reverseMap); &#125;&#125;void expungeFrom(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map, ConcurrentMap&lt;?, Boolean&gt; reverseMap) &#123; // removing just by key is always safe here because after a CacheKey // is cleared and enqueue-ed it is only equal to itself // (see equals method)... ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(this); // remove also from reverseMap if needed if (valuesMap != null) &#123; for (Object cacheValue : valuesMap.values()) &#123; //移除弱应用CacheValue reverseMap.remove(cacheValue); &#125; &#125;&#125; valueMap是回记录真正的代理类相关信息key =&gt; subKeyFactory.apply(key, parameter) 通过classLoader和interface[]组成value=&gt; supplier=&gt;Factory 或者 CacheValue valuemap中value的两种形式1.刚创建时为factory对象2.factory.applay方法执行后会替换为CacheValue,并且将CacheValue保存到reverseMap中 小结总体的逻辑就是这样子, 通过源代码的阅读,对JDK的动态代理实现清晰很多。也从根本上对动态代理的实现过程有了更深的理解，我们此时就可以自己尝试着思考Spring AOP的具体实现。本文没有对缓存和代理生成的细节做详细分析和总结,还需要深入的研究 结语由于个人的能力有限，文章中存在错误的地方或者有宝贵的意见，欢迎大家留言评论。 之后会写Spring AOP 和 cglib动态代理的相关文章。 与君共勉！！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"展望2018","slug":"2018-target","date":"2017-12-31T16:08:47.000Z","updated":"2018-02-02T13:06:10.040Z","comments":true,"path":"2018/01/01/2018-target/","link":"","permalink":"http://www.eumji025.com/2018/01/01/2018-target/","excerpt":"","text":"总结2017 懵懵懂懂又一年,总的来说离目标还有一些距离. 展望2018往往都是计划赶不上变化,18年,还是把自己关键的主题方向列出来,某些具体的技术栈就随时间推荐进行学习.go和docker是必须要掌握的. 概括 该做的事情还是得做 该看的书籍还是得看 该敲的代码还是得敲 该学的东西还是得学 基础目标1go语言及爬虫 2.docker三件套学习 3.java虚拟机 4.spring源码阅读 5.还是开发一个开源项目 6.技术类文章30篇(保质保量) 7.沉淀自己 总结新的一年,新的开始,也应该做一些新的尝试. 前路漫漫,且行且思.","categories":[{"name":"其他","slug":"其他","permalink":"http://www.eumji025.com/categories/其他/"}],"tags":[{"name":"target","slug":"target","permalink":"http://www.eumji025.com/tags/target/"}]},{"title":"spring-boot跳转页面","slug":"springboot-indexPage","date":"2017-03-26T00:04:54.000Z","updated":"2018-01-02T03:29:09.176Z","comments":true,"path":"2017/03/26/springboot-indexPage/","link":"","permalink":"http://www.eumji025.com/2017/03/26/springboot-indexPage/","excerpt":"","text":"前言 本篇博客记录spring boot如何跳转到静态首页.因为是初学的关系很多知识点都不懂,而且spring boot的项目没有webapp也没有配置文件.所以思考蛮久,经过查阅资料最终找到方法,做一次学习记录. Demo其实配置起来相对简单,只是一直没有找到配置的方法,翻看了官方文档,眼拙也没找到. 其实只需要在resources目录下新建static文件夹,并把html文件放在其中即可. 目录配置 Controller12345678@Controllerpublic class PageController &#123; @RequestMapping(\"indexPage\") public String indexPage()&#123; return \"index.html\"; &#125;&#125; 注: 在我暂时的尝试中,只能跳转一个页面,配多个也没用,可能是我自己学习的不够到位.后续学习中再做修改. 结果展示 结语与君共勉! BGM","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-customport","slug":"spring-boot-customport","date":"2017-02-26T12:19:56.000Z","updated":"2018-01-02T03:29:09.184Z","comments":true,"path":"2017/02/26/spring-boot-customport/","link":"","permalink":"http://www.eumji025.com/2017/02/26/spring-boot-customport/","excerpt":"","text":"Spring boot 自定义端口前言spring boot本身内置tomcat,我们不需要进行tomcat的配置,只需要引入tomcat的依赖即可. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt; 自定义端口1.spring boot中自定义端口需要入口类实现ConfigurableEmbeddedServletContainer接口.如下代码 1234567891011121314151617181920@RestController@EnableAutoConfigurationpublic class CustomPortController implements EmbeddedServletContainerCustomizer &#123; /** * 自定义端口 * @param container */ public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8888); &#125; @RequestMapping(\"/\") public String setPort()&#123; return \"自定义端口:8888\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(CustomPortController.class,args); &#125;&#125; 2.直接自定义ConfigurableEmbeddedServletContainer.通过自己注册TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory 12345678@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory(); factory.setPort(9000); factory.setSessionTimeout(10, TimeUnit.MINUTES); factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, \"/notfound.html\"); return factory;&#125; 结语长路漫漫,与君共勉!","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-helloworld","slug":"spring-boot-helloworld","date":"2017-02-26T02:32:34.000Z","updated":"2018-01-02T03:29:09.180Z","comments":true,"path":"2017/02/26/spring-boot-helloworld/","link":"","permalink":"http://www.eumji025.com/2017/02/26/spring-boot-helloworld/","excerpt":"","text":"Spring boot介绍 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 Spring boot 特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 Spring boot第一个demo说明本文采用maven方式构建项目.(maven学习地址) 开发环境 maven intellij idea java8 (推荐java7及以上版本) 构建项目第一个项目相对简单,我们不做过多的配置,只需要简单的引入spring-boot提供默认parent就可以了. 123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot.demo&lt;/groupId&gt; &lt;artifactId&gt;FirstDemo&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;FirstDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--内置tomcat和springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;FirstDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 代码编写123456789101112@RestController@EnableAutoConfigurationpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String helloWorld()&#123; return \"Hello world!\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldController.class,args); &#125;&#125; 注: 1.@RestController和@RequestMapping注解是springMVC的注解,分别用来注册controller类和映射对应地址的http请求. 2.@EnableAutoConfiguration注解,Spring Boot根据添加的jar依赖自动配置spring. 3.main方法通过调用run， 将业务委托给了Spring Boot的SpringApplication类。 SpringApplication将引导我们的应用， 启动Spring， 相应地启动被自动配置的Tomcat web服务器。 启动服务12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.4.1.RELEASE)2017-02-26 10:51:44.822 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Starting HelloWorldController on EumJi025 with PID 456 (E:\\workspace\\ideaWork\\Spring-boot\\FirstDemo\\target\\classes started by EumJi in E:\\workspace\\ideaWork\\Spring-boot)2017-02-26 10:51:44.833 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : No active profile set, falling back to default profiles: default2017-02-26 10:51:44.934 INFO 456 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:46.571 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-02-26 10:51:46.594 INFO 456 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-02-26 10:51:46.595 INFO 456 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.52017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1768 ms2017-02-26 10:51:46.813 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-02-26 10:51:47.044 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:47.099 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.springboot.demo.controller.HelloWorldController.helloWorld()2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.163 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.315 INFO 456 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-02-26 10:51:47.373 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-02-26 10:51:47.377 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Started HelloWorldController in 3.327 seconds (JVM running for 4.128) 测试 结语长路漫漫,与君共勉!","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"checksty配置","slug":"checkstyle","date":"2017-01-18T14:39:13.000Z","updated":"2018-01-02T03:29:09.164Z","comments":true,"path":"2017/01/18/checkstyle/","link":"","permalink":"http://www.eumji025.com/2017/01/18/checkstyle/","excerpt":"","text":"配置文件由于checkstyle默认是使用google的开发规范,相对来说比较严格,因此采用自定义的规范.本文的配置文件来源于网络,后续将会进行改动. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\" \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\"&gt;&lt;module name=\"Checker\"&gt; &lt;!-- 消息提示等级 --&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;!-- 字符集限制 --&gt; &lt;property name=\"charset\" value=\"UTF-8\"/&gt; &lt;module name=\"TreeWalker\"&gt; &lt;!-- javadoc的检查 --&gt; &lt;!-- 检查所有的interface和class --&gt; &lt;module name=\"JavadocType\"/&gt; &lt;!-- 检查所有方法的javadoc，可以不声明RuntimeException --&gt; &lt;module name=\"JavadocMethod\"&gt; &lt;property name=\"allowUndeclaredRTE\" value=\"true\"/&gt; &lt;property name=\"allowMissingPropertyJavadoc\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 检查变量的javadoc --&gt; &lt;module name=\"JavadocVariable\"&gt; &lt;property name=\"scope\" value=\"public\"/&gt; &lt;/module&gt; &lt;!-- 命名方面的检查，它们都使用了Sun官方定的规则。 --&gt; &lt;!-- 类名(class 或interface) 的检查 --&gt; &lt;module name=\"TypeName\"/&gt; &lt;!-- 变量的检查 --&gt; &lt;module name=\"MemberName\"/&gt; &lt;!-- 方法名的检查 --&gt; &lt;module name=\"MethodName\"/&gt; &lt;!-- 方法的参数名 --&gt; &lt;module name=\"ParameterName \"/&gt; &lt;!-- 常量名的检查 --&gt; &lt;module name=\"ConstantName\"/&gt; &lt;!-- 长度方面的检查 --&gt; &lt;!-- 文件长度不超过1500行 --&gt; &lt;!-- 每行不超过120个字--&gt; &lt;module name=\"LineLength\"&gt; &lt;property name=\"max\" value=\"120\"/&gt; &lt;/module&gt; &lt;!-- 方法不超过30行 --&gt; &lt;module name=\"MethodLength\"&gt; &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt; &lt;property name=\"max\" value=\"30\"/&gt; &lt;/module&gt; &lt;!-- 方法的参数个数不超过3个。 --&gt; &lt;module name=\"ParameterNumber\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 多余的关键字 --&gt; &lt;module name=\"RedundantModifier\"/&gt; &lt;!-- 对区域的检查 --&gt; &lt;!-- 不能出现空白区域 --&gt; &lt;module name=\"EmptyBlock\"/&gt; &lt;!-- 所有区域都要使用大括号。 --&gt; &lt;module name=\"NeedBraces\"/&gt; &lt;!-- 多余的括号 --&gt; &lt;module name=\"AvoidNestedBlocks\"&gt; &lt;property name= \"allowInSwitchCase\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 编码方面的检查 --&gt; &lt;!-- 不许出现空语句 --&gt; &lt;module name=\"EmptyStatement\"/&gt; &lt;!-- 每个类都实现了equals()和hashCode() --&gt; &lt;module name=\"EqualsHashCode\"/&gt; &lt;!-- 不许使用switch --&gt; &lt;module name=\"IllegalToken\"&gt; &lt;property name=\"tokens\" value=\"LITERAL_SWITCH\"/&gt; &lt;/module&gt; &lt;!-- 不许内部赋值 --&gt; &lt;module name=\"InnerAssignment\"/&gt; &lt;!-- 绝对不能容忍魔法数 --&gt; &lt;module name=\"MagicNumber\"/&gt; &lt;!-- 循环控制变量不能被修改 --&gt; &lt;module name=\"ModifiedControlVariable\"/&gt; &lt;!-- 多余的throw --&gt; &lt;!-- &lt;module name=\"RedundantThrows\"/&gt; --&gt; &lt;!-- 不许使用未被简化的条件表达式 --&gt; &lt;module name=\"SimplifyBooleanExpression\"/&gt; &lt;!-- 不许使用未被简化的布尔返回值 --&gt; &lt;module name=\"SimplifyBooleanReturn\"/&gt; &lt;!-- String的比较不能用!= 和 == --&gt; &lt;module name=\"StringLiteralEquality\"/&gt; &lt;!-- if最多嵌套3层 --&gt; &lt;module name=\"NestedIfDepth\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- try最多被嵌套1层 --&gt; &lt;module name=\"NestedTryDepth\"/&gt; &lt;!-- clone方法必须调用了super.clone() --&gt; &lt;module name=\"SuperClone\"/&gt; &lt;!-- finalize 必须调用了super.finalize() --&gt; &lt;module name=\"SuperFinalize\"/&gt; &lt;!-- 不能catch java.lang.Exception --&gt; &lt;module name=\"IllegalCatch\"&gt; &lt;property name=\"illegalClassNames\" value=\"java.lang.Exception\"/&gt; &lt;/module&gt; &lt;!-- JUnitTestCase 的核心方法存在。 --&gt; &lt;!-- &lt;module name=\"JUnitTestCase\"/&gt; --&gt; &lt;!-- 一个方法中最多有3个return --&gt; &lt;module name=\"ReturnCount\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 不许对方法的参数赋值 --&gt; &lt;module name=\"ParameterAssignment\"/&gt; &lt;!-- 不许有同样内容的String --&gt; &lt;module name=\"MultipleStringLiterals\"/&gt; &lt;!-- 同一行不能有多个声明 --&gt; &lt;module name=\"MultipleVariableDeclarations\"/&gt; &lt;!-- 各种量度 --&gt; &lt;!-- 布尔表达式的复杂度，不超过3 --&gt; &lt;module name=\"BooleanExpressionComplexity\"/&gt; &lt;!-- 类数据的抽象耦合，不超过7 --&gt; &lt;module name=\"ClassDataAbstractionCoupling\"/&gt; &lt;!-- 类的分散复杂度，不超过20 --&gt; &lt;module name=\"ClassFanOutComplexity\"/&gt; &lt;!-- 函数的分支复杂度，不超过10 --&gt; &lt;module name=\"CyclomaticComplexity\"/&gt; &lt;!-- NPath复杂度，不超过200 --&gt; &lt;module name=\"NPathComplexity\"/&gt; &lt;!-- 杂项 --&gt; &lt;!-- 禁止使用System.out.println --&gt; &lt;!-- &lt;module name=\"GenericIllegalRegexp\"&gt; &lt;property name=\"format\" value=\"System\\.out\\.println\"/&gt; &lt;property name=\"ignoreComments\" value=\"true\"/&gt; &lt;/module&gt; --&gt; &lt;!-- 不许使用与代码同行的注释 --&gt; &lt;module name=\"TrailingComment\"/&gt; &lt;!-- 不允许存在todo标签 --&gt; &lt;module name=\"TodoComment\"&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;property name=\"format\" value=\"TODO\"/&gt; &lt;/module&gt; &lt;/module&gt; &lt;module name=\"FileLength\"&gt; &lt;property name=\"max\" value=\"1500\"/&gt; &lt;/module&gt; &lt;!-- 检查翻译文件 --&gt; &lt;module name=\"Translation\"/&gt;&lt;/module&gt; 注未完待续","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://www.eumji025.com/tags/tools/"}]},{"title":"web开发常用注解","slug":"annotation","date":"2017-01-11T15:14:31.000Z","updated":"2018-01-14T02:56:23.850Z","comments":true,"path":"2017/01/11/annotation/","link":"","permalink":"http://www.eumji025.com/2017/01/11/annotation/","excerpt":"","text":"简介概念 Annotation(注解)是JDK1.5及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。另外，你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。 分类①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 WEB开发中常用的注解Spring篇@Controller@Controller 定义控制器，映射页面URL的请求,只有被@Controller声明的类才会到对应类下找到对应@Requestmapping配置的URL 开启扫描@Controller注解需要在spring-mvc.xml中配置 1234&lt;!-- 扫描web相关的Bean 使用Annotation自动注册Bean,只扫描@Controller --&gt; &lt;context:component-scan base-package=\"com.jsu.controller\" use-default-filters=\"false\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!-- 子标签是用来添加扫描注解的 --&gt; &lt;/context:component-scan&gt; 简化配置版 1&lt;context:component-scan base-package=\"com.jsu.controller\"/&gt; ### @RequestMapping @RequestMapping 注解将类似 “/index”这样的URL映射到整个类或特定的处理方法上。类级别的注解映射特定的请求路径到表单控制器上，而方法级别的注解只是映射为一个特定的HTTP方法请求（“GET”，“POST”等）或HTTP请求参数。简而言之,公共的请求路径使用@RequestMapping放在类声明上,而特有的请求放在方法上,如下例: 12345678910111213141516@RequestMapping(\"/perm/permission\")public class PermissionController extends BaseController &#123; @Autowired private IPermissionService permissionService; @RequestMapping(\"/list\") public String list(Model model) &#123; return \"/permission/list\"; &#125; @RequestMapping(\"/getPermissionList\") @ResponseBody public String getPermissionList() &#123; Page&lt;Permission&gt; page = getPage(); return jsonPage(permissionService.selectPage(page, null)); &#125;&#125; 补充:随着Spring的发展,在@RequestMapping的注解基础之上又发展了几个新的类似注解: @GetMapping =&gt; get方式的请求表示;@PustMapping =&gt; post方式的请求;@DeleteMapping =&gt; delete方式的请求;@PutMapping =&gt; put方式的请求;@PatchMapping =&gt; patch方式的请求. @PathVariableURI 模版是一个类似于 URI 的字符串，其中包含了一个或多个变量。当你将这些变量替换掉市，就变回了 URI。 URI 模版格式 proposed RFC 定义了如何参数化 URI。比如，URI 模版 http://www.example.com/users/{userId}，包含了变量 userId，设置此变量为 __fred，就会变成http://www.example.com/users/fred。 可在方法入参上使用注解 @PathVariable 绑定 URI 的模版参数: 123456@RequestMapping(value=\"/owners/&#123;ownerId&#125;\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) &#123; Owner owner = ownerService.findOwner(ownerId); model.addAttribute(\"owner\", owner); return \"displayOwner\";&#125; @PathVariable 参数可以是任意的简单类型（如 int，long，Date 等），Spring 会自动将其进行类型转换，转换出错会抛出 TypeMismatchException. @RequestBody常用语接受前台请求的json格式数据,可以转化成对象接受. 12345@Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) &#123; // 实现省略&#125; @ResponseBody@ResponseBody 的使用类似于 @RequestBody。此注解用在方法上，用来表示直接将返回数据写到 HTTP 响应体里。注意，不是将数据放到 Model 中，或解析为视图名称。如下例: 12345@RequestMapping(value = \"/something\", method = RequestMethod.PUT)@ResponseBodypublic String helloWorld() &#123; return \"Hello World\";&#125; 常用于ajax请求. Bean相关@Service,@Controller,@Repository,@Component@Service =&gt; 通常用于服务层声明Bean@Controller =&gt; 通常用于控制层声明Bean@Repository =&gt; 用于持久层声明Bean(是JPA的注解)@Component =&gt; 声明通用Bean,也就是当你无法把一个Bean合理归类到上述三种情况时,使用此注解. @Bean@Bean是一种代替xml声明Bean的方式,具体如下所示:1234@Beanpublic HelloServiceImpl transferService()&#123; return new HelloServiceImpl();&#125; 上述描述就等同于如下的xml123&lt;beans&gt; &lt;bean id=\"helloServiceImpl\" class=\"com.eumji.HelloServiceImpl\"/&gt;&lt;/beans&gt; 因为Spring4之后,鼓励大家使用注解的方式去声明一些Bean. 详情请参考spring官方文档-bean @Autowire@Autowire是spring官方提供的一种装配方式。(默认byType) ＠Resource＠Resource是java自带的一种装配方式。默认按名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。 ## @Qualifier正因为＠Autowired注解使用的byType方式进行注入的,所以当如果一个Service有多个实现类的时候,就会出现不知所措的局面,因此@Qualifier的主要目的就是指定Bean的名称. 所以选择使用那种注解,需要自己去权衡. JPA实体类注解### @Entity 标注于实体类上，通常和@Table是结合使用的，代表是该类是实体类 @Table标注在实体类上,表示该实体类对应数据库中的一张表 @Id 标注于属性上，通常是在get方法上，也可以在属性的声明上。用于表示该属性作为ID主键. @GeneratedValue12345678910//源码@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface GeneratedValue &#123; GenerationType strategy() default AUTO; //默认是AUTO String generator() default \"\";&#125; 12345678910111213141516171819202122public enum GenerationType &#123; /** * 自增长 */ TABLE, /** * 通过序列 */ SEQUENCE, /** * 由数据库维护 */ IDENTITY, /** * 自动选择合适的方案分配 */ AUTO&#125; 即主键生成策略,通常和@Id配合使用. @Column标注于属性上，有很多功能，例如指定长度、是否为空，列名以及对应到数据库汇中的类型等,具体如下源码所示 12345678910111213141516@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface Column &#123; //设置对应数据库名 String name() default \"\"; //是否唯一 boolean unique() default false; //是否可以为空 boolean nullable() default true; //是否可以掺入 boolean insertable() default true; //设置长度 int precision() default 0; //精度 int scale() default 0;&#125; @OrderBy设置排序.ASC和DESC.默认ASC 12345@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface OrderBy &#123; String value() default \"\";&#125; ### @ManyToMany&amp;&amp;@OneToMany 设置对应关系,多对多,一对多 @DateTimeFormat格式化时间,放在属性上 1234567891011121314151617181920@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)public @interface DateTimeFormat &#123; String style() default \"SS\"; DateTimeFormat.ISO iso() default DateTimeFormat.ISO.NONE; String pattern() default \"\"; public static enum ISO &#123; DATE, //日期 TIME, //时间 DATE_TIME, //时间+日期 NONE; //无 private ISO() &#123; &#125; &#125;&#125; ## Jackson注解 JsonProperty设置某个属性在转成json后的名称 1234public class Name &#123; @JsonProperty(\"sex\") public String t_sex;&#125; 转化成json格式后是这样的: 将会生成如下所示的JSON数据结果：{ “sex” : “man” } @JsonIgnoreProperties此注解是类注解，作用是json序列化时将Java bean中的一些属性忽略掉，序列化和反序列化都受影响. @JsonIgnore 此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。示例: 12345public class KeyValue &#123; public int value; @JsonIgnore public int key;&#125; 12转成json字符串后://将会忽略key&#123; &quot;value&quot; : 42 &#125; @JsonFormat此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，比如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”) @JsonSerialize 此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码. @JsonDeserialize 此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码. Mybatis注解### @Alias ＠Alias是mybatis中一个注解,类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。xml中通常这样配置. 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"com.eumji025.vo.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"com.eumji025.vo.Blog\"/&gt;&lt;/typeAliases&gt; 也可以在xml中直接指定包名如下: 123&lt;typeAliases&gt; &lt;package name=\"com.eumji025.vo\"/&gt;&lt;/typeAliases&gt; 每一个在包 com.eumji025.vo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。比如 com.eumji025.vo.Author 的别名为 author 如通过注解已经设置别名则按照注解的别名来使用: 1234@Alias(\"author\")public class Author &#123; ...&#125; 当然mybatis为了使用方便,已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。具体如下: 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 注后续继续补充","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"Idea-Maven项目的创建和部署","slug":"Idea-Maven项目的创建和部署","date":"2016-11-21T12:12:40.000Z","updated":"2018-01-01T10:14:54.099Z","comments":true,"path":"2016/11/21/Idea-Maven项目的创建和部署/","link":"","permalink":"http://www.eumji025.com/2016/11/21/Idea-Maven项目的创建和部署/","excerpt":"","text":"前言由于Intellij Idea创建项目方式和eclipse有一定的区别，所有maven项目也是一样。 目的学会使用idea创建和部署Maven项目。 过程创建空的项目 创建maven module1.点击+号创建 2.选择maven webapp 3输入groupId和ArtifactId 4.陪著maven相关信息。 5设置名字 完成。6.等待一段时间，maven自动加载web项目相关的配置7 修改pom文件 注意添加packaging 8 修改项目配置 提示maven-tomcat插件配置 发布 右键项目 run maven-maven-tomcat即可 结语 与君共勉！","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://www.eumji025.com/tags/Intellij-Idea/"}]},{"title":"推荐的markdown编辑器","slug":"推荐的markdown编辑器","date":"2016-11-05T01:26:54.000Z","updated":"2018-01-02T03:29:09.172Z","comments":true,"path":"2016/11/05/推荐的markdown编辑器/","link":"","permalink":"http://www.eumji025.com/2016/11/05/推荐的markdown编辑器/","excerpt":"","text":"介绍Typora是一款非常优雅的markdown编辑器 因为它将「写字」和「预览」合并，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。 一切都变得如此干净、纯粹。 官网 传送门： hexo官网 安装windows 下载地址 安装没有难度 linux sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys BA300B7755AFCFAE sudo add-apt-repository ‘deb https://typora.io ./linux/‘ sudo apt-get update sudo apt-get install typora mac 解压安装 功能介绍表格编辑其他的markdown表格编辑方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 十分复杂的操作有木有 Typora表格操作方式 CTRL+T快捷键直接生成 图片操作插入图片的语法 1![logo](http://typora.io/img/favicon-128.png) typora语法 CTRL+SHIFT+I 更简单的直接将图片拖拽进来即可。 目录大纲 Typora 还可以根据当前文档的标题层级，自动生成显示大纲， 点击软件左下角圆圈即可，就会出现字数统计和大纲预览。 圆圈旁边是切换视图按钮。 主题 ypora 默认提供了六套主题样式： Github风格、 默认主题 Gothic、 出版风格的 Newsprint、 夜间模式 Night、 Pixyll、 Whitey. 结语与君共勉！！！","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"写作","slug":"写作","permalink":"http://www.eumji025.com/tags/写作/"}]},{"title":"springMVC 几种页面跳转方式","slug":"springMVC-几种页面跳转方式","date":"2016-10-28T04:45:00.000Z","updated":"2018-01-02T03:29:09.176Z","comments":true,"path":"2016/10/28/springMVC-几种页面跳转方式/","link":"","permalink":"http://www.eumji025.com/2016/10/28/springMVC-几种页面跳转方式/","excerpt":"","text":"前言前面已经了解了Controller的几种配置方式今天主要写一下响应界面跳转的几种方式 在注解的方式中通过HttpServletResponse的API直接输出（不需要配置渲染器）controller类的主要代码 12345678@Controllerpublic class RequestController&#123; @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.getWriter().println(\"hello HttpServletResponse\"); &#125; web.xml配置 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; dispatcher-servlet.xml主要代码 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--作用是扫描指定包下所有的包含注解的类--&gt; &lt;context:component-scan base-package=\"com.jsu.mvc\"/&gt;&lt;/beans&gt; 使用HttpServletResponse 重定向到另一个视图(其他不变 )1234567 @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.sendRedirect(\"index.jsp\"); &#125;&#125; 使用HttpServletRequest 转发（默认访问/下的index.jsp页面 不受渲染器的影响）12345@RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; req.setAttribute(\"message\",\"it's forword \"); req.getRequestDispatcher(\"index.jsp\").forward(req,resp); &#125; 直接返回jsp页面的名称（无渲染器）其他的配置不变 123456789@RequestMapping(\"/nice\") public String hello1()&#123;//转发方式1 return \"home.jsp\"; //转发方式2 return \"forward:index.jsp\"; //重定向方式 return \"redirect:index.jsp\"; &#125; 当有渲染器指定123456789@RequestMapping(\"/nice\") public String hello1()&#123; //转发方式1 return \"home\"; //转发方式2 return \"forward:index\"; //重定向方式 hello指的是requsrmapping return \"redirect:hello\"; &#125; 使用view使用modelandview需要视图解析器 能指定跳转页面 12345678910111213141516public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); //封装要显示到视图的数据 mv.addObject(\"msg\",\"hello myfirst mvc\"); //视图名 mv.setViewName(\"hello\"); return mv; &#125;&#125; [servlet-name]-servlet.xml 12345678910111213&lt;!--配置渲染器--&gt; &lt;!--配置hellocontroller中页面的位置--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--结果视图的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--结果视图的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; &lt;bean name=\"/hello.do\" class=\"com.jsu.mvc.HelloController\"&gt;&lt;/bean&gt; 使用modelview不需要视图解析器 不能指定跳转页面 12345678//通过modelmap方式 @RequestMapping(\"/modelmap\") public String modelHello(String name,ModelMap map)&#123; map.addAttribute(\"name\",name); System.out.println(name); return \"index.jsp\"; &#125; 结语与君共勉！","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.eumji025.com/tags/Spring-MVC/"}]},{"title":"使用idea开发srpingMVC第一个Demo","slug":"使用idea开发srpingMVC第一个Demo","date":"2016-10-28T04:24:48.000Z","updated":"2018-01-14T02:21:37.350Z","comments":true,"path":"2016/10/28/使用idea开发srpingMVC第一个Demo/","link":"","permalink":"http://www.eumji025.com/2016/10/28/使用idea开发srpingMVC第一个Demo/","excerpt":"","text":"主要目的是熟悉intellij的web项目操作和springMVC的基本概念,纯属个人学习的笔记,有写的不当的地方欢迎指正 ###操作环境说明操作系统： win10ide版本： 2017.1.5 开发过程本文原始的版本是在个人学习写的，所以很多东西写的不够详细。本次重新归纳总结，下面开始具体操作： 创建项目创建一个empty projectFile -&gt; new -&gt; project -&gt; empty project ###创建module说明一下，在实际开发中我们喜欢一个项目一个project，但是学习之中，为了方便来回切换，所以我们每一个demo都写成module的形式。 创建 module(在此之前需要创建entity project)在新版本中，会提示你是下载勾选的mvc的依赖。 然后填写module名 点击确认 module创建完毕（作者因为乱码的关系 ￥代表 /） 结构预览并修改配置在module的web-WEB-INF下新建 classes和lib文件夹（新版本中的lib在根目录下） 1.IDEA默认是不会像eclipse那样在web-inf下生成lib文件夹和classes文件夹的的，需要我们手动的创建，并将我们根目录下的lib目录下的内容复制到web-inf/lib文件夹内。并且还需要进行额外配置。 点击file-&gt;Project Struture 修改Modules下的paths 修改完毕点击OK（主要是为了跟ecilpse结构相似，也可以不改） 2.然后点击dependencis - &gt; 绿色的+ -&gt; 选择第一项，选择刚才我们在WEB-INF下创建的lib文件夹，和eclipse的导包一个性质。 3.回到主界面，配置tomcat 点击run-&gt;edit configurations‘点绿色的十字图标 创建tomcat并配置 选择自己的tomcat位置点击deployment -&gt; 绿色+号 -&gt; 选择我们的项目 代码编写 web,xml 不需要进行修改，有默认的就行了。 修改dispatcjer-servlet.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--对应src下的报名，需要自己新建--&gt; &lt;context:component-scan base-package=\"com.eumji.mvc\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;!--jsp文件夹需要自己手动创建--&gt; &lt;value&gt;/WEB-INF/jsp/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.在jsp目录下新建hello.jsp123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello mvc&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg &#125;&lt;/body&gt;&lt;/html&gt; 4.在src中编写controller类需要和dispatcher-servlet.xml配置的路径一致12345678@Controllerpublic class HelloController &#123; @RequestMapping(value=&quot;/hello&quot;,method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute(&quot;msg&quot;, &quot;Spring 3 MVC Hello World&quot;); return &quot;hello&quot;; &#125;&#125; 5.点击右上角的绿色三角形进行运行，最后进行测试 第一个小demo到此结束！ 最后说几句Intellij IDEA和eclipse的使用有很大的不同，本文只是带领着使用IDEA进行web项目的创建和测试。并没有对spring MVC框架本身的内容进行过多的讲解。IDEA创建普通的web 项目确实比较麻烦，使用maven的方式更佳。 补充还是补充一下创建maven项目的姿势 创建maven module 1.点击+号创建 2.选择maven webapp3输入groupId和ArtifactId4.陪著maven相关信息。最好是设置一下maven的setting文件,无论是自带的还是自己配置的maven,修改一下maven的镜像地址.在maven的settings.xml 文件里配置mirrors的子节点，添加如下mirror &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 5.文件夹名称,创建完成.6.加载 等待一段时间，maven自动加载web项目相关的配置 7 .修改pom文件注意添加packaging8 修改项目配置 maven-tomcat插件配置 发布右键项目 run maven-maven-tomcat即可 spring boot特别推荐一下使用spring boot,对新手非常友好,而且可以使用spring initialize生成项目,并且不需要配置tomcat. 源码地址https://github.com/eumji025/my-demo/tree/master/hello-mvc","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://www.eumji025.com/tags/Intellij-Idea/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.eumji025.com/tags/Spring-MVC/"}]}]}