{"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-01-01T08:52:14.476Z","updated":"2018-01-01T08:52:14.476Z","comments":false,"path":"/404.html","permalink":"http://www.eumji025.com//404.html","excerpt":"","text":""},{"title":"About","date":"2017-12-31T16:08:16.299Z","updated":"2017-09-16T11:09:26.071Z","comments":false,"path":"about/index.html","permalink":"http://www.eumji025.com/about/index.html","excerpt":"","text":"个人简介"},{"title":"Books","date":"2017-12-31T16:08:16.343Z","updated":"2017-09-16T11:09:26.074Z","comments":false,"path":"books/index.html","permalink":"http://www.eumji025.com/books/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-12-31T16:08:16.379Z","updated":"2017-09-16T11:09:26.077Z","comments":false,"path":"categories/index.html","permalink":"http://www.eumji025.com/categories/index.html","excerpt":"","text":""},{"title":"Repository","date":"2017-12-31T16:08:16.107Z","updated":"2017-09-16T11:09:26.085Z","comments":false,"path":"repository/index.html","permalink":"http://www.eumji025.com/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-31T16:08:16.163Z","updated":"2017-09-16T11:09:26.090Z","comments":false,"path":"tags/index.html","permalink":"http://www.eumji025.com/tags/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-12-31T16:08:16.411Z","updated":"2017-09-16T11:09:26.081Z","comments":true,"path":"links/index.html","permalink":"http://www.eumji025.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"AbstractQueuedSynchronizer源码分析","slug":"AbstractQueuedSynchronizer-analysis","date":"2018-01-18T13:56:36.000Z","updated":"2018-01-21T11:30:37.452Z","comments":true,"path":"2018/01/18/AbstractQueuedSynchronizer-analysis/","link":"","permalink":"http://www.eumji025.com/2018/01/18/AbstractQueuedSynchronizer-analysis/","excerpt":"","text":"AQS简介AbstractQueuedSynchronizer是一个基于first-in-first-out (FIFO)队列实现阻塞锁和同步器功能的框架。简称AQS,此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。子类必须定义更改此状态的受保护方法（如tryReleaseShared），并定义哪种状态对于此对象意味着被获取或被释放。 我们首先看一下FIFO队列的真实面貌 12345678910111213static final class Node &#123; static final AbstractQueuedSynchronizer.Node SHARED = new AbstractQueuedSynchronizer.Node(); static final AbstractQueuedSynchronizer.Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; volatile AbstractQueuedSynchronizer.Node prev; volatile AbstractQueuedSynchronizer.Node next; volatile Thread thread; AbstractQueuedSynchronizer.Node nextWaiter;&#125; 可以看出其实就是一个双向队列，应该是非常容易理解的。在这个对象里面设置了好几种状态值，这主要用于设置锁的状态值。 CANCELLED =&gt; 取消状态 SIGNAL =&gt; 等待触发状态 CONDITION =&gt; 等待条件状态 PROPAGATE =&gt; 状态需要向后传播 后面具体在介绍其中的含义，不过我倒是觉得这几个状态值应该自己用个枚举维护会更好。。。 方法原理首先介绍一下acquire方法，此方法是以独占模式获取对象，忽略中断。tryAcquire方法尝试获取锁，需要子类自己实现。 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 这里主要是三个步骤： 1.首先直接先尝试获取锁(tryAcquire)，如果获取不到;2.则会将这个线程加入到等待队列(addWaiter(Node.EXCLUSIVE), arg));3.进行自旋，尝试获取锁(acquireQueued)。这也是和synchronized方法不同的地方。 当获取失败的时候就需要将线程加入到等待的队列中，看一下addWaiter方法的具体实现。 1234567891011121314151617private Node addWaiter(Node mode) &#123; //将当前线程包装成一个节点 Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // 如果存在等待的队列，直接加入到队尾 if (pred != null) &#123; node.prev = pred; //使用CAS方式设置tail节点 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //不存在的时候创建队列 enq(node); return node;&#125; 这里总共做了三件事情 1.首先把当前对象包装成一个node 2.判断等待队列是否为空，如果等待队列已经存在，直接添加到队列末尾 3.如果为空的话，需要尝试新建一个等待队列 为什么说是尝试新建队列，下面看一下具体enq方法的实现就能知道 12345678910111213141516private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; //初始化队列头 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //如果已经初始化了就添加到队尾 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 此处为什么要这么设计，因为AQS的方法都是没有加锁的，所以很有可能进入enq方法的时候别的线程初始化过等待队列了。所以此处也是用CAS操作，都是为了防止发生错误的可能性。关于CAS的详细介绍，可以自己查阅相关的资料。 上面介绍完加入队列后，下面就要看一下acquireQueued方法的实现了，大概也能猜到是怎么进行自旋的。 123456789101112131415161718192021222324final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取node的前一个元素，满足条件就直接设置为新的队头，p就要被干掉 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; //如果不满足条件，就需要把线程挂起并检查中断状态 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; //如果最终都没有找到合适的，取消等待的节点 if (failed) cancelAcquire(node); &#125;&#125; 此处节点会一直检查当前是否到了下一个被唤醒的位置。如果没有到就会检测中间元素是否已经被取消，如果取消了就会更改队列的状态。 具体看一下实现shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法的实现 1234567891011121314151617181920212223private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //获取前面节点的状态值 int ws = pred.waitStatus; //表示等待被唤醒，直接返回 if (ws == Node.SIGNAL) return true; //大于0代表CANCELLED状态，将会被取消，此处就会移除节点， if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //否则设置为SIGNAL状态，表示等待被唤醒，获取锁 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;//真正的挂起锁，并检测是否被中断了private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 此处就是使用到了文章开始所说的那几个状态值， 1.当node前一个节点的状态值为SIGNAL，表示这个节点是可以等待锁的。 2.如果不满足ws&gt;0，表示前一个节点已经被取消，则干掉取消的节点。（他只管在他前面的那个节点，至于更前面的，就交给前面节点的线程去检测了） 3.否则就把pred的状态设置为SIGNAL。 最后都会执行finally中的cancelAquire方法,先用一张图来看一下（来自百度） 1234567891011121314151617181920212223242526272829303132private void cancelAcquire(Node node) &#123; if (node == null) return; node.thread = null; Node pred = node.prev; //清除节点前面的已经取消的节点 while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; Node predNext = pred.next; node.waitStatus = Node.CANCELLED; //如果节点在末尾，直接将前一个不为cancel的节点设置为末尾节点 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; int ws; //前节点不是队头，并且是等待的状态，设置连接的状态 if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; //pred.next的pred =&gt; node.pred if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; //否则就是获得锁 unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125; 在自旋中发生意外进入到finally的取消方法，其中的主要逻辑再次梳理一下： 1.如果当前的节点是空的，直接返回 2.如果上一个节点被取消，改变节点的连接状态，如果当前元素是tail，尝试将red的下一个节点设置为null 3.如果不是tail元素，当前元素也不是head，将pred.next链接到node.next 4.否则帮助一下个元素获取锁(处于队列头了)。 具体看一下我们的unparkSuccessor方法 12345678910111213141516171819private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; //如果node小于0 设置为0，为什么有这一步？ if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; //如果当前节点的下一个节点也是被取消的 if (s == null || s.waitStatus &gt; 0) &#123; s = null; //从后往前找到node后的第一个没取消的节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //解锁这个节点 if (s != null) LockSupport.unpark(s.thread);&#125; 自己到了下一个被唤醒的线程时，需要分情况的进行解锁，因为unparkSuccessor方法是多个地方都要被使用的，所以虽然在我们的cancelAquire方法中，node已经设置为CANCEL状态，但是其他方法调用的时候node的状态就不确认了，所以这也是为什么还要继续判断状态的理由。 并且找到自己的下一个元素没被取消的节点，让他获得锁。需要注意的是如果下一个节点取消的话,就会采取从后往前找的方式,知道排列在最前面的那个节点.为什么采用这种方式,因为我们在之前的代码也可以看到,在进行设置next节点的时候都上用CAS的方式,所以next节点设置成不成功也都是不确定的,而且有没有一直进行尝试.从后往前保证了不会出现问题. 释放锁看完获得锁之后，我们看一下如何进行锁释放的。 12345678910public final boolean release(int arg) &#123; //尝试释放锁 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 和获得锁一样tryRelease方法也是需要子类自己进行实现的。如果释放锁成功的话，就开始unparkSuccessor 方法为head的下一个节点获得锁。 这里就也用到了unparkSuccessor方法。同时我们再次看unparkSuccessor方法就会清晰很多,明白为什么要那么多判断了。 结语为什么我们需要了解AQS，这是因为Lock锁，线程池，信号量（Semaphore）就是基于AQS实现的。 所以AQS是基础，当时我看ReentrantLock的时候就是一脸懵逼，当看完AQS之后再次看的时候就清晰很多了。同时不得不佩服Doug Lea大神。 本文主要的是基于自己的一些观点写的，如有表达不当或者描述错误的地方，欢迎给我反馈。 与君共勉！！ 参考文献 占小狼-深入浅出java同步器AQS java8-AbstractQueuedSynchronizer文档","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"Go 初学者成长之路","slug":"go-learn-material","date":"2018-01-12T05:36:18.000Z","updated":"2018-01-12T06:09:19.312Z","comments":true,"path":"2018/01/12/go-learn-material/","link":"","permalink":"http://www.eumji025.com/2018/01/12/go-learn-material/","excerpt":"","text":"本文转载自Halfrost-Field 冰霜之地,以获取授权 开源书籍 书籍名 地址 推荐理由 Go 指南 https://tour.go-zh.org/ 初学者熟悉 Go 语法的 palyground,无须搭建本地 Go 的环境，在线就编写 Go 的代码 Go实战开发 https://github.com/astaxie/go-best-practice 这本书还没有完成，但是基础的基本都讲完了，这个书的作者就是著名的 Go 开源项目 beego 的作者 @astaxie，他的最佳实践非常值得阅读 Go Web 编程 https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md gitbooks地址 这个本的作者也是上本书的作者 @astaxie，从开发环境搭建到构建一个 Web 应用，讲解的都非常详细，@astaxie 的这两本书非常值得深度学习和阅读，本书已经完全写完了 GO 命令教程 https://github.com/hyper0x/go_command_tutorial 《Go并发编程实战》作者郝林书中的示例 Go入门指南 https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md 这本书也非常适合初学者，不过看了上面几本书以后，看这本书，前面一些基础内容都可以很快的刷过去了，这本书可以主要看高级编程和实际应用这两大部分 Go语言圣经 http://docs.ruanjiadeng.com/gopl-zh/index.html 这本书是 Go 语言著名书籍《The Go Programming Language》的中文翻译版，如果觉得翻译的书不好，可以直接去看原著 Go by Example https://gobyexample.com/ 推荐这个网站的原因是这里有好多值得初学者学习的例子，这里可以作为初学者“抄”(学习)代码的地方 Go-SCP https://checkmarx.gitbooks.io/go-scp/content/ 这本书是关于 Go 安全相关的，本人还没有读过，为何放在这里？因为是我老大推荐的? 编译器1. Vim党Vim党当然是不需要 IDE 的，直接 Vim + Vim-go（或者 Emacs） 2. 文本编辑器 + 插件目前最常用最火的文本编辑器有 VSCode、Sublime、Atom 他们都可以安装相应的插件，就可以支持 Go 的编码了。我暂时用的是 Atom + go-plus，界面还比较美，如下图： 3. IDE目前用的比较多的 IDE 有：IntelliJ idea、Goland、LiteIDE。 学习网站 网站名 地址 推荐理由 The Go Programming Language https://golang.org/ Go 的官方网站 Go 编程语言 https://go-zh.org/ Go 官网对应的中文网站 The Go Blog https://blog.golang.org/ Go 的官方博客 The Go Packages https://golang.org/pkg/ Go 的包官方文档 Go 标准库中文文档 http://cngolib.com/ Go 标准库中文文档 视频这个也看个人吧，有些人不喜欢看文档，或者有时候文档看累了看会视频。下面这些视频本人看过开头的，觉得讲的还可以，不过后面的我没有继续看下去了，因为觉得看视频学习有点慢，我还是选择看刷书刷题啦~? 网站名 地址 推荐理由 Go 编程基础 https://github.com/Unknwon/go-fundamental-programming 这套视频适合初学者 Go Web 基础 https://github.com/Unknwon/go-web-foundation 这是一套针对 Google 出品的 Go 语言的视频语音教程，主要面向完成《Go 编程基础》教程后希望进一步了解有关 Go Web 开发的学习者。 Go名库讲解 https://github.com/Unknwon/go-rock-libraries-showcases 这是一套针对 Google 出品的 Go 语言的第三方库进行评测讲解的集博客、示例与语音视频为一体的综合教程，适合完成学习完成《Go编程基础》教程的学习者。 Go语言第一课 慕课网上的课程 这个课程的录制者是郝林，如果你是他的粉丝，可能你就不想错过这个课程 社区 Go语言社区（排名不分先后） https://gocn.io http://studygolang.com http://www.golangtc.com http://www.golangweb.com 最后，多多练习，多多实践 Go，只要功夫深，铁杵磨成针！ GitHub Repo：Halfrost-Field Follow: halfrost · GitHub Source: https://halfrost.com/new_gopher/ 结语go语言初学者,个人喜欢goland. 与君共勉!!!","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://www.eumji025.com/tags/golang/"}]},{"title":"HashMap源码分析","slug":"hashmap-analysis","date":"2018-01-06T03:06:50.000Z","updated":"2018-01-21T11:29:56.441Z","comments":true,"path":"2018/01/06/hashmap-analysis/","link":"","permalink":"http://www.eumji025.com/2018/01/06/hashmap-analysis/","excerpt":"","text":"HashMap介绍HashMap是基于hash表的map的实现,使用key-value形式存储键值对，并允许使用 null 值和 null 键,但是key只能有一个为null. Map不保证映射的顺序，其内部是根据hash值去模运算去排列的。HashMap内部使用entry数组作为存储的介质. 本文是基于Java8版本写的,因为Java8对HashMap有较大的改变,采用数组+链表+红黑树方式来记录键值对.而且Java8还重写了resize方法,Java8之前很有可能造成扩容时,链表的循环问题. 源码解读本文中的代码比较多,大多数的说明都在注释上体现了,所以可能文字上表述的不是很多,本文也尽可能介绍了一些java8中的新方法.需要注意的是其中很多地方都进行了修改和补充,看完本篇文章一定和之前看的Java7 HashMap有非常多的不同之处,也可以思考一下为什么Java8要做这么多改变. Node介绍Node是map的接口中的内部接口Map.Entry的实现类,用于存储HashMap中键值对的对象,是HashMap中非常重要的一个内部类,随便提一下,HashMap中有非常多的内部类,本文没做过多的介绍,读者可以自己翻看一下源码,因为篇幅实在太长了…在这里就简单的讲一下,大部分的内部类都是用于集合操作的,如keySet,values,entrySet等方法. 内部组成 12345678910static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//key是不可变的final K key;//valueV value;//指向下一个entry对象,具体作用后面介绍Node&lt;K,V&gt; next;//hash值int hash;&#125; HashMap组成HashMap主要参数 12345678static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //默认初始容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认负载因子,相当于只有多少可用transient Node&lt;K,V&gt;[] table;//要存储值的hash表transient int size; //实际大小int threshold; //阈值final float loadFactor;//负载因子transient int modCount; //记录操作次数的 相比之前版本的HashMap,Java8更钟爱与位操作.>&gt; 表示逻辑右移>&gt;&gt; 表示无符号逻辑右移.高位补零 HashMap构造方法 123456789101112131415161718//为空时候使用默认分配的大小16,负载因子0.75f,默认的容量为12,当size&gt;threshold默认容量时候就会去扩容public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; &#125;//构造方法 初始化负载因子和阈值public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + //容量判断 initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //负载银子判断 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; HashMap方法本文主要挑选几个比较常用且重要的方法进行分析.因为这写方法已经涵盖了大部分的方法调用关系. hash方法使用hashcode 异或 hashcode右移16位 得到hash值,等同于高位都取零随带提一句,int类型的hashcode就是本身.1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; put方法解析put方法,是HashMap中非常重要的方法,其中牵涉到了非常多的知识点,需要仔细的阅读. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * onlyIfAbsent 是否替换,为true时,如果存在值则替换 * evict 主要用于LinkedHashMap移除最近未使用的节点 */final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //未初始化则扩容(扩容包括新建和扩容) if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果不存在,直接put if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //根据条件获取不同的node节点,有可能tab[i]就是存在的元素 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //否则判断是树,添加 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //否则普通的链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; //到尾都没找到,添加一个节点 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //判断是否转化为树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //转换成树的具体内容就不描述了,篇幅太长 treeifyBin(tab, hash); break; &#125; //找到记录 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //存在,替换 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //用于linkedHashMap,本文不做介绍 afterNodeAccess(e); return oldValue; &#125; &#125; //添加成功,判断是否要扩容 ++modCount; if (++size &gt; threshold) resize(); //用于linkedHashMap afterNodeInsertion(evict); return null;&#125; 下面详细介绍一下扩容的方法.看起来非常庞大.其实逻辑不复杂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 有几种情况 * 1.当为空的时候,也就是没有初始化的时候 * 2.当到达最大值时候 * 3.普通扩容时候 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //存在旧值 if (oldCap &gt; 0) &#123; //大于2&lt;&lt;30 最大容量设置为2&lt;&lt;32 - 1 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //但是不移动.,没有空间移动 threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果属于正常范围的扩容 容量 x2 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //用户自己设定了初始化大小 else if (oldThr &gt; 0) &#123; newCap = oldThr; &#125; //如果没使用,使用默认值初始化 else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //用户自定义了map的初始化操作 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //新的容量 threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果是扩容操作 if (oldTab != null) &#123; //遍历map的数据 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果当前位置只有一个元素,直接移动到新的位置 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果是红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //如果没超过8个 是链表 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; //此处的操作是这样子的 因为是扩容一倍的操作,所以与旧的容量进行与操作后只有两个值0 和 1 //如果是0就位置不变,如果是1就移动n+old的位置, //个人认为这么做的好处是: /** * 1.不会像之前1.7发生循环依赖的问题 * 2.从概率的角度上来看可以均匀分配,(一般来说高位和低位比例差不多) * 3.提高效率 */ do &#123; next = e.next; //如果和旧容量位运算后的值是0,记得当前节点和存放在链表的尾部 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //同上 else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //为0的还是存放在当前位置 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //为1的就放在扩容的j + oldCap那边去 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 因为不像Java8之前的HashMap有初始化操作,此处选择将初始化和扩容放在了一起,并且又增加了红黑树的概念,所以导致整个方法的判断次数非常多,也是这个方法比较庞大的主要原因. 值得一体的是,在扩容后重新计算位置的时候,对链表进行优化,有兴趣可以搜索一下HashMap导致cpu百分之百的问题而在Java中通过巧妙的进行&amp;操作,然后获得高位是为0还是1.最终移动的位置就是低位的链表留在原地,高位的放在index+oldsize的地方就可以了,不用为每一个元素计算hash值,然后移动到对应的位置,再判断是否是链表,是否需要转换成树的操作.如下所示.12hashcode: 1111111111111101212oldcap: 0000000000000010000 很容易知道这个&amp;操作之后就是为0,因为oldcap都是2的倍数,只有高位为1,所以通过&amp;确认高位要比%取余高效.此时在看一下上面的扩容操作也许就更清晰了. 下面介绍一些newNode方法.就是新建一个节点.可以思考一下为什么要把newNode抽离出来?文章末尾给答案.123Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next);&#125; 添加节点到红黑树的方法是Java8中新添加的,需要满足链表的长度到8,才会转换成红黑树,其主要目的是防止某个下标处的链表太长,导致在找到的时候速度很慢,下面看一下实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//尝试着往树节点添加值final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; //找到根节点 TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; //存在的话直接返回,用于替换 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; //判断节点类型是否相同,不相同 else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; //没有搜索过,搜索子节点,搜过了说明没有就跳过. if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; //去子节点去找 if (((ch = p.left) != null &amp;&amp;(q = ch.find(h, k, kc)) != null) ||((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; //对比hash值,决定查找的方向 dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; //找到子节点为空,就可以加进去,设置层级关系 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125;&#125; 这里简单的梳理一下流程.1.从根节点查找,找到了返回,如果没找到,找字节点2.判断往哪个方向去查找3.如果不存在,在子节点末端添加新节点 下面再看一下树的split方法,主要是扩容操作,重新结算位置需要分裂树,之前讲过,扩容会根据和旧map容量进行&amp;操作,移动高位为1的节点.并且验证新的节点列表是否需要重新转换成链表的形式. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // 设置记录高低位的node,和链表一样都是计算高位是0还是1 TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; //还是和旧的容量做位运算,为0的放在lo中 if ((e.hash &amp; bit) == 0) &#123; //判断是否为头部 if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; //获取为1的放在hi中 else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; //lo链表的处理 if (loHead != null) &#123; //如果小于7,那么当做链表处理 if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; //转换成树 tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; //同上 if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125;//把树转换成链表final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd;&#125; 转化成红黑树的详情本文就没详细介绍了,我相信很容易看懂.这里借｀美团点评技术团队｀的一张图来展示一下put方法的流程 get方法 逻辑其实很简单,就是首先通过hashcode确认位置,然后分数据结构类型继续不同方式的查找1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //找到位置,并且当且位置存在元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp;((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //链表或者树,遍历子节点 if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; remove方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;/** * 1.寻找是否存在,如果存在分数据类型分别处理 * 2.如果为树,稍微复杂一点,需要判断是否要转换成链表,然后就是树的移动 */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //找到节点 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; //从树节点获取 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //找到了对应的节点 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; //树节点处理 主要是两点,存在删除,删除了是否需要转换成链表 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); //一个元素 else if (node == p) tab[index] = node.next; else //指向node的下一个 p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 本文就不看树的详细删除过程了,内容太多太长.可以自己想象一下树的删除过程.replace方法12345678910111213@Overridepublic V replace(K key, V value) &#123; Node&lt;K,V&gt; e; //找到节点替换 if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; //与linkedHashMap有关 afterNodeAccess(e); return oldValue; &#125; return null;&#125; 从基本的方法中我们可以看出,最复杂的就是put方法,put方法设计非常多的方法,后续的get,replace,remove都是建立在put方法基础之上. 补充方法上面介绍了几个基本的方法,另外现在介绍一些有用的小方法.都是在Java8新增的. merge方法merge方法的主要作用是如果不存在就进行添加,如果存在的话按照自己指定的remappingFunction进行操作,如果操作之后value为null的话删除元素,否则替换,下面是代码详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public V merge(K key, V value,BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; //扩容操作 if (size &gt; threshold || (tab = table) == null ||(n = tab.length) == 0) n = (tab = resize()).length; //通过key找到元素,分为树和链表两种情况 if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; //存在旧的结点,进行合并操作 if (old != null) &#123; V v; if (old.value != null) //具体的合并操作 v = remappingFunction.apply(old.value, value); else v = value; //合并成功,执行afterNodeAccess方法,子类linkedHashMap有用 if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; //合并之后没有值,删除元素 else removeNode(hash, key, null, false, true); return v; &#125; //没有旧结点,直接添加,考虑扩容,链表和树的情况 if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value;&#125; compute方法123456789101112131415161718192021public V compute(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; //省略部分基本和merge方法的前半段一直,不重复展示 //获取旧元素 V oldValue = (old == null) ? null : old.value; //计算出新值 V v = remappingFunction.apply(key, oldValue); //存在旧元素,旧赋值到旧元素上 if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; //计算结果为空则删除 else removeNode(hash, key, null, false, true); &#125; //r如果没有旧元素,但计算出的值不为空,添加操作,和merge方法相同,省略 return v;&#125; 看到这里我相信大家都有疑问,为什么要放两个几乎相同的两个方法, 我们详细对比一下两个方法,发现会有几点不同: 参数不同,merge方法要求value不为null,compute方法没有要求; merge方法要求old.value也不为null.compute的方法依然没有要求. 另外compute还有两个扩展方法,简单介绍一下. computeIfAbsent方法如果oldvalue不为null就不替换,如果计算后的值不存在直接返回,否则如果old不为null,通过key计算出值替换,否则添加到map中12345678910111213141516171819public V computeIfAbsent(K key,Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; //扩容等操作省略,同上 V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; //注意这里 V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; //添加操作省略&#125; computeIfPresent方法不进行扩容的判断(因为不存在找不到就添加这样的操作).直接通过key查找,如果找到,且计算的结果不为null,替换,否则就直接删除12345678910111213141516171819public V computeIfPresent(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; //注意这里 V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; 再次总结一下三个compute方法的异同点 compute方法和computeIfPresent方法都需要oldValue,computeIfAbsent不需要 compute的remappingFunction.apply方法不限制oldvalue是否为null,但是computeIfPresent限制必须不为null才进行,computeIfAbsent方法必须要old或者oldvalue为null才会进行后续操作 computeIfPresent只有oldvalue存在则进行apply方法,然后根据条件替换或者删除操作,而compute和computeIfAbsent方法则是如果old不存在,还会根据条件额外进行添加操作 简单点说就是: 如果是不存在oldvalue才进行操作,这也可以认为我们在声明了String a = null这样的操作,现在需要进行初始化,选择computeIfAbsent方法, 如果必须存在oldvalue才操作,而且只进行删除或者修改的操作则选择computeIfPresent方法,类似看看还有没有修改的价值,没价值就干掉了. 其他选择compute方法 快速失败和安全失败问题 12345678910一：快速失败（fail—fast） 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。二：安全失败（fail—safe） 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 解答解释一下刚才在文章设置的悬念,为什么要把newNode方法单独提出来,其实这里很大一部分原因是因为Linkedhashnap会需要重写此方法进行额外的操作.具体是什么可以自己查看一下源码,或者看我的另一篇文章,map集合类总结. 总结改版后的HashMap看起来更加的庞大和神秘了,因为相比之前看起来可能方法更大而且还有红黑树这个数据结构,看到代码就会让人感觉好难受,同时也呼吁每个人都不要写这么庞大的方法.尽可能将方法拆小.变得更加的简洁明了.但是Java8对HashMap的改变,使得HashMap在一定程度上提升了性能,并且还新填了不少的方法. 当然本文只是个人的一些看法,如果存在不足或者错误的地方,欢迎大家指正!!! 结语与君共勉!!!","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"动态代理及Proxy源码分析","slug":"dynamic-proxy","date":"2018-01-02T03:23:46.000Z","updated":"2018-01-04T12:40:21.614Z","comments":true,"path":"2018/01/02/dynamic-proxy/","link":"","permalink":"http://www.eumji025.com/2018/01/02/dynamic-proxy/","excerpt":"","text":"前言 代理是java中非常重要的一种设计模式,动态代理则可以认为是一种动态代理的最佳实践,本文将由浅及深的介绍动态代理及其proxy源码分析,文章写的不一定都对,请各位看官带着批判的态度阅读此文章. 代理模式是设计模式中的一种,而且在实际的开发中使用的频率非常高 ,比如spring AOP,mybatis代理都是我们经常使用的. 代理模式的定义: 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。 静态代理从上面的介绍中可以看出代理模式其实本意是为了解决访问存在困难或者为了保证透明性的一种工具,有点类似于我们无法访问google,需要一个中间代理商的帮助是一致的.下面通过一个简单的例子来介绍: 12345678910111213141516171819202122232425262728293031323334353637383940public class ProxyDemo &#123; static interface BaseUser&#123; void info(); void real(); &#125; static class ProxyUser implements BaseUser&#123; BaseUser baseUser; public ProxyUser(BaseUser baseUser) &#123; this.baseUser = baseUser; &#125; public void info() &#123; System.out.println(\"I'm Proxy,I can help you\"); &#125; public void real() &#123; System.out.println(\"I will help you visit google\"); baseUser.real(); System.out.println(\"I had help you visit google\"); &#125; &#125; static class TargetUser implements BaseUser&#123; public void info() &#123; System.out.println(\"I'm google,what you what do?\"); &#125; public void real() &#123; System.out.println(\"I.m google,this is searched info\"); &#125; &#125; public static void main(String[] args) &#123; BaseUser targetUser = new TargetUser(); BaseUser proxyUser = new ProxyUser(targetUser); proxyUser.info(); proxyUser.real(); &#125;&#125; 在这里我们也可以认为代理者是两者访问或者交互的载体,需要对双方都非常的熟悉,才能帮你做具体的事,就像如果我现在需要代购,可能就需要找新的代理人!!! 这里也就是我们所说的静态代理 虽然静态代理也能帮我实现一些功能,但是只能说不够强大,此时我们就可以使用动态代理来帮我们更加灵活的去搞事情 动态代理动态代理的优势：1. 降低各个功能模块之间的耦合度，提高开发的效率和方便程序的维护度。 2. 减少代码量。 3. 不关注目标的具体实现。 动态代理的实现JDK动态代理 jdk自带的动态代理主要是通过实现InvocationHandler InvocationHandler的主要方法 Object invoke(Object proxy, Method method,Object[] args)throws Throwable 在代理实例上处理方法调用并返回结果。在与方法关联的代理实例上调用方法时，将在调用处理程序上调用此方法。即调用真实业务的方法都会进入到此invoke方法,至于为什么,稍后再说明 方法详细介绍 参数：proxy - 调用方法的代理实例对象 method - 代理实例对象调用的接口方法的 Method 实例对象。 Method-指代具体被代理的方法。 args -包含传入代理实例上方法调用的参数，如果接口方法不使用参数，则为 null。 return：从代理实例的方法调用返回的值。 throws： Throwable - 从代理实例上的方法调用抛出的异常。 ​ 案例本案例演示的是最常用的拦截方法然后记录日志的功能。 3.1 业务接口 123public interface Base &#123; public void hello(String name);&#125; 3.2 业务实现类 LoginImpl 123456public class LoginImpl implements Base&#123; @Override public void hello(String name) &#123; System.out.println(&quot;welcome &quot;+name+&quot;, success !!1&quot;); &#125;&#125; 3.3 代理类 LoginProxy 123456789101112131415161718192021222324252627282930313233343536373839404142class DynamicProxy implements InvocationHandler &#123; Object originalObj; Object bind(Object originalObj) &#123; this.originalObj = originalObj; return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this); &#125; /** * 切入点 对所有对象的方法都进行调用 * method.invoke方法对应代理对象调用login方法 * @param proxy 代理对象 * @param method 代理对象的方法 * @param args 代理对象调用接口方法的参数值 * @return 代理对象调用方法的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object invoke = method.invoke(originalObj, args); if (invoke != null)&#123; result(invoke); &#125; after(); return invoke; &#125; private void before() &#123; System.out.println(&quot;方法执行之前&quot;); &#125; private void after() &#123; System.out.println(&quot;方法执行之后&quot;); &#125; private void result(Object o) &#123; o.toString(); &#125;&#125; 3.4 测试类 LoginClient 1234567public class LoginClient &#123; public static void main(String[] args) &#123; //用于生成代理文件 //System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;); Base hello = (Base) new DynamicProxy().bind(new LoginImpl()); hello.hello(&quot;zhangsan&quot;); &#125;&#125; 3.5 执行结果： 123方法执行之前Hello zhangsan方法执行之后 从上面的例子我们可以看到动态代理有效的减少了各个模块的耦合度,用于实现日志功能的代码和用于实现登陆功能的代码相互隔离。对两者都没有条件限制,.只有在真正调用业务的时候并需要日志功能时候二者才发生联系。任何业务需要日志功能只需要通过代理类创建代理对象即可,不需要重复创建代理类. 究其原理System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);取消掉此方法的注释,我们运行或编译代码后将生成代理的文件,默认是项目根目录下的于包名同名的文件夹下。下面我们看一下生成的代理类反编译后的内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import ProxyDemo.Base;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;//$Proxy0是生成代理的格式决定的final class $Proxy0 extends Proxy implements Base &#123; //将基础的tostring,equils,hashcode,还有base接口的方法生成method的对象 private static Method m1; private static Method m2; private static Method m4; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void out() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; //具体的实现 static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m4 = Class.forName(\"ProxyDemo$Base\").getMethod(\"hello\", Class.forName(\"java.lang.String\")); m3 = Class.forName(\"ProxyDemo$Base\").getMethod(\"out\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 首先从类的继承关系就很容易理解Proxy.newProxyInstance(originalObj.getClass().getClassLoader(),originalObj.getClass().getInterfaces(), this);方法的作用了. 即继承了proxy类也实现了Base接口.这也是Base hello = (Base) new DynamicProxy().bind(new LoginImpl());这也是为什么可以强转为Base对象的原因.同时在代理中将object类中的equils,tostring,hashcode以及所有base接口的方法生成对应的代理方法. 以hello方法为例介绍一下,h表示的是proxy类中的InvocationHandler其实也就是指代我们之前的DynamicProxy对象,然后调用invoke方法就回到DynamicProxy的invoke方法.我们就可以再次做很多中间的操作。 12345678910public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125;&#125; Proxy解读看完了代理类的内容后,接下来我们就需要去详细的看一下Proxy是如何生成$Proxy0这个代理类的.了解一下其中的工作流程和原理。 首先看newProxyInstance方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); //获取需要代理类的所有实现的接口 final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; //检查是否有生成代理类的权限 checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; //查找或者生成代理类 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //生成构造函数 try &#123; if (sm != null) &#123; //检查是否有权限 checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; //public $Proxy0(InvocationHandler var1) final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; //访问修饰符设置 if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; //返回代理类的对象 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException | InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; 具体的实现逻辑在getProxyClass0方法中，最外面的方法只是描述了生成代理后然后创建对应的代理对象。首先看一下checkProxyAccess方法的具体内容 123456789101112131415161718192021222324252627282930//主要作用检查权限是否可以操作 private static void checkProxyAccess(Class&lt;?&gt; caller, ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader ccl = caller.getClassLoader(); //classloader验证 if (VM.isSystemDomainLoader(loader) &amp;&amp; !VM.isSystemDomainLoader(ccl)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; // ReflectUtil.checkProxyPackageAccess(ccl, interfaces); &#125; &#125; //检查接口的包权限 public static void checkProxyPackageAccess(ClassLoader var0, Class... var1) &#123; SecurityManager var2 = System.getSecurityManager(); if (var2 != null) &#123; Class[] var3 = var1; int var4 = var1.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; Class var6 = var3[var5]; ClassLoader var7 = var6.getClassLoader(); if (needsPackageAccessCheck(var0, var7)) &#123; checkPackageAccess(var6); &#125; &#125; &#125; &#125; 当验证完权限之后,查看如何获取代理类的getProxyClass0方法123456789private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; //从缓存中获取,如果不存在就创建 return proxyClassCache.get(loader, interfaces); &#125; 使用proxyClassCache做缓存，其目的是为了复用，同时防止多线程重复创建。在weekCache类中使用了多个map进行记录,稍后我们再做详细介绍. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//获取或生成代理类 此处因为不是线程安全的做了多次判断public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); //删除过期条目 expungeStaleEntries(); //创建cacheKey Object cacheKey = CacheKey.valueOf(key, refQueue); //查看key是否已经存在valuemaps中 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; //不存在的话通过,再次尝试尝试获取,如果没有就插入 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; //生成代理对象的key 为弱引用类型 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); //尝试从valuemap中获取 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; //如果确实已经有线程创建了 if (supplier != null) &#123; //直接获取 supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; //最终返回value return value; &#125; &#125; // 不存在创建一个supplier factory实现了supplier if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; //如果不存在则保存到valuemap中 supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // 添加成功 supplier = factory; &#125; // 创建的时候发现已经有了,尝试替换 &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; //替换成功 supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125;&#125; get方法首先去查看是否存在缓存过期的情况,存在则清除掉.如果不存在,尝试的生成key和value的相关元数据, 下面介绍key的生成方法KeyFactory.apply方法123456789//根据接口个数的不同选择生成不同的key对象public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125;&#125; 然后在判断是否存在同时其他线程生成,然后就是尝试着保存添加信息,如果已经有了就尝试替换.最终通过supplier.get()方法获取,最终实际的逻辑在supplier.get()方法中,下面看一下具体的过程123456789101112131415161718192021222324252627282930313233public synchronized V get() &#123; // serialize access // 再次检查是否匹配 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; //因为此方法调用之前有可能发生valuesMap.replace(subKey, supplier, factory) return null; &#125; // 创建 V value = null; try &#123; //真正的逻辑,重点方法 value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // 如果最终没能生成代理对象,从valuemap移除 valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; //包装value为acacheValue CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // 保存到reverseMap reverseMap.put(cacheValue, Boolean.TRUE); // 尝试这替换valuemap中的cacheValue if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError(\"Should not reach here\"); &#125; return value; &#125; 下面详细介绍value的ProxyClassFactory.apply方法.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 //apply方法详解public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; Class&lt;?&gt; interfaceClass = null; try &#123; //使用给定的类加载器加载接口 interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; //验证是否为接口 if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; //验证接口不是重复的 if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; //修饰符 int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * 验证接口的可见性 * 如果不是public类型的接口又不在同一个包下抛出异常 */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; //如果不是public类型的接口又不在同一个包下抛出异常 else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // 没有包使用默认的包 com.sun.proxy proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * 代理类的名称 按顺序递增 =&gt; $proxy0 */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * 生成代理类的字节数组 */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; //调用native方法生成Class return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125; 主要的步骤如下 1.尝试着用现有的类加载器加载接口,如果成功 2.验证是否为接口,接口是否重复 ,如果成功 3.验证接口访问权限,如果成功 4.获取包的信息,和类名设置, 5.生成代理的字节数组 6.通过native方法defineClass0获取字节数字的具体的Class 这里着重讲解一下如何生成字节数组的 1234567891011121314151617181920212223242526272829303132333435363738394041 //生成代理类public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123; ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2); /** * 生成具体文件字节数组 * 1.找到所有接口的方法 * 2.添加object类的三个方法 tostring hashcode equils * 3.遍历生成具体的代理方法,代理方法的逻辑都想似,回调我们的代理类 */ final byte[] var4 = var3.generateClassFile(); // private static final boolean saveGeneratedFiles = GetBooleanAction(\"sun.misc.ProxyGenerator.saveGeneratedFiles\"))).booleanValue(); //这就是我们为什么设置sun.misc.ProxyGenerator.saveGeneratedFiles = true的原因,设置后就会生成代理类的文件 if (saveGeneratedFiles) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int var1 = var0.lastIndexOf(46); Path var2; if (var1 &gt; 0) &#123; //生成path 将.替换成系统文件分隔符 Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar)); //创建文件夹 Files.createDirectories(var3); //具体文件 var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + \".class\"); &#125; else &#123; //没包就放在项目根目录下 var2 = Paths.get(var0 + \".class\"); &#125; //写入到文件中 Files.write(var2, var4, new OpenOption[0]); return null; &#125; catch (IOException var4x) &#123; throw new InternalError(\"I/O exception saving generated file: \" + var4x); &#125; &#125; &#125;); &#125; return var4;&#125; 主要的方法是通过ProxyGenerator对象生成字节数组,具体生成的步骤可以如下几步: 1231.找到所有接口的方法2.添加object类的三个方法 tostring hashcode equils3.遍历生成具体的代理方法,代理方法的逻辑都想似,回调我们的代理类 我可以通过之前展示的一个代理方法即可才想到其中的大概流程. 123456789public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; 最主要不同的地方就是方法名,方法参数,invoke方法的参数。其他的几乎都相同。本文就不做代码上的具体介绍. 然后通过sun.misc.ProxyGenerator.saveGeneratedFiles 的值,来决定是否生成代理文件到磁盘. 如果生成,则生成包信息,类信息,然后将字节数组写入到文件中.默认情况下和在项目的根据下,创建和包名的文件夹和$proxy+i的代理文件. 缓存从我们的代码中我们可以看到WeekCache中使用多个map进行记录12345678910111213//cachekey的引用队列,于JVM关系密切详细介绍请看这篇文章http://blog.csdn.net/u012332679/article/details/57489179private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;(); // 最外层map,key=&gt;cacheKey,value =&gt; valueMap private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;(); //记录保存value的Supplier对象map private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;(); //key生成对象 private final BiFunction&lt;K, P, ?&gt; subKeyFactory; //value生成对象 private final BiFunction&lt;K, P, V&gt; valueFactory; map中的key是cacheKey,是一种弱应用类型的对象,reverseMap的key是cacheValue,同为一种弱应用类型的对象.两者也同时为内存回收的主要对象,当某个map中的key失效的时候,在下一次进行get,containsValue,size三个方法的时候都会触发expungeStaleEntries方法,然后将value从reverseMap中清除,valuemap从map中清除.而refQueue的回收,是由Reference中ReferenceHandler轮询去回收的.如果回收了,refQueue.poll会成功触发,然后就想清除操作.1234567891011121314151617181920private void expungeStaleEntries() &#123; CacheKey&lt;K&gt; cacheKey; while ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != null) &#123; cacheKey.expungeFrom(map, reverseMap); &#125;&#125;void expungeFrom(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map, ConcurrentMap&lt;?, Boolean&gt; reverseMap) &#123; // removing just by key is always safe here because after a CacheKey // is cleared and enqueue-ed it is only equal to itself // (see equals method)... ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(this); // remove also from reverseMap if needed if (valuesMap != null) &#123; for (Object cacheValue : valuesMap.values()) &#123; //移除弱应用CacheValue reverseMap.remove(cacheValue); &#125; &#125;&#125; valueMap是回记录真正的代理类相关信息key =&gt; subKeyFactory.apply(key, parameter) 通过classLoader和interface[]组成value=&gt; supplier=&gt;Factory 或者 CacheValue valuemap中value的两种形式1.刚创建时为factory对象2.factory.applay方法执行后会替换为CacheValue,并且将CacheValue保存到reverseMap中 小结总体的逻辑就是这样子, 通过源代码的阅读,对JDK的动态代理实现清晰很多。也从根本上对动态代理的实现过程有了更深的理解，我们此时就可以自己尝试着思考Spring AOP的具体实现。本文没有对缓存和代理生成的细节做详细分析和总结,还需要深入的研究 结语由于个人的能力有限，文章中存在错误的地方或者有宝贵的意见，欢迎大家留言评论。 之后会写Spring AOP 和 cglib动态代理的相关文章。 与君共勉！！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"展望2018","slug":"2018-target","date":"2017-12-31T16:08:47.000Z","updated":"2018-01-01T10:14:54.051Z","comments":true,"path":"2018/01/01/2018-target/","link":"","permalink":"http://www.eumji025.com/2018/01/01/2018-target/","excerpt":"","text":"总结2017 懵懵懂懂又一年,总的来说离目标还有一些距离. 展望2018往往都是计划赶不上变化,18年,还是把自己关键的主题方向列出来,某些具体的技术栈就随时间推荐进行学习.go和docker是必须要掌握的. 概括 该做的事情还是得做 该看的书籍还是得看 该敲的代码还是得敲 该学的东西还是得学 基础目标1.go语言及爬虫 2.docker三件套学习 3.java虚拟机 4.spring源码阅读 5.还是开发一个开源项目 6.技术类文章30篇(保质保量) 7.沉淀自己 总结新的一年,新的开始,也应该做一些新的尝试. 前路漫漫,且行且思.","categories":[{"name":"其他","slug":"其他","permalink":"http://www.eumji025.com/categories/其他/"}],"tags":[{"name":"target","slug":"target","permalink":"http://www.eumji025.com/tags/target/"}]},{"title":"spring-boot跳转页面","slug":"springboot-indexPage","date":"2017-03-26T00:04:54.000Z","updated":"2018-01-02T03:29:09.176Z","comments":true,"path":"2017/03/26/springboot-indexPage/","link":"","permalink":"http://www.eumji025.com/2017/03/26/springboot-indexPage/","excerpt":"","text":"前言 本篇博客记录spring boot如何跳转到静态首页.因为是初学的关系很多知识点都不懂,而且spring boot的项目没有webapp也没有配置文件.所以思考蛮久,经过查阅资料最终找到方法,做一次学习记录. Demo其实配置起来相对简单,只是一直没有找到配置的方法,翻看了官方文档,眼拙也没找到. 其实只需要在resources目录下新建static文件夹,并把html文件放在其中即可. 目录配置 Controller12345678@Controllerpublic class PageController &#123; @RequestMapping(\"indexPage\") public String indexPage()&#123; return \"index.html\"; &#125;&#125; 注: 在我暂时的尝试中,只能跳转一个页面,配多个也没用,可能是我自己学习的不够到位.后续学习中再做修改. 结果展示 结语与君共勉! BGM","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-customport","slug":"spring-boot-customport","date":"2017-02-26T12:19:56.000Z","updated":"2018-01-02T03:29:09.184Z","comments":true,"path":"2017/02/26/spring-boot-customport/","link":"","permalink":"http://www.eumji025.com/2017/02/26/spring-boot-customport/","excerpt":"","text":"Spring boot 自定义端口前言spring boot本身内置tomcat,我们不需要进行tomcat的配置,只需要引入tomcat的依赖即可. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt; 自定义端口1.spring boot中自定义端口需要入口类实现ConfigurableEmbeddedServletContainer接口.如下代码 1234567891011121314151617181920@RestController@EnableAutoConfigurationpublic class CustomPortController implements EmbeddedServletContainerCustomizer &#123; /** * 自定义端口 * @param container */ public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8888); &#125; @RequestMapping(\"/\") public String setPort()&#123; return \"自定义端口:8888\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(CustomPortController.class,args); &#125;&#125; 2.直接自定义ConfigurableEmbeddedServletContainer.通过自己注册TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory 12345678@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory(); factory.setPort(9000); factory.setSessionTimeout(10, TimeUnit.MINUTES); factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, \"/notfound.html\"); return factory;&#125; 结语长路漫漫,与君共勉!","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-helloworld","slug":"spring-boot-helloworld","date":"2017-02-26T02:32:34.000Z","updated":"2018-01-02T03:29:09.180Z","comments":true,"path":"2017/02/26/spring-boot-helloworld/","link":"","permalink":"http://www.eumji025.com/2017/02/26/spring-boot-helloworld/","excerpt":"","text":"Spring boot介绍 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 Spring boot 特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 Spring boot第一个demo说明本文采用maven方式构建项目.(maven学习地址) 开发环境 maven intellij idea java8 (推荐java7及以上版本) 构建项目第一个项目相对简单,我们不做过多的配置,只需要简单的引入spring-boot提供默认parent就可以了. 123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot.demo&lt;/groupId&gt; &lt;artifactId&gt;FirstDemo&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;FirstDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--内置tomcat和springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;FirstDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 代码编写123456789101112@RestController@EnableAutoConfigurationpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String helloWorld()&#123; return \"Hello world!\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldController.class,args); &#125;&#125; 注: 1.@RestController和@RequestMapping注解是springMVC的注解,分别用来注册controller类和映射对应地址的http请求. 2.@EnableAutoConfiguration注解,Spring Boot根据添加的jar依赖自动配置spring. 3.main方法通过调用run， 将业务委托给了Spring Boot的SpringApplication类。 SpringApplication将引导我们的应用， 启动Spring， 相应地启动被自动配置的Tomcat web服务器。 启动服务12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.4.1.RELEASE)2017-02-26 10:51:44.822 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Starting HelloWorldController on EumJi025 with PID 456 (E:\\workspace\\ideaWork\\Spring-boot\\FirstDemo\\target\\classes started by EumJi in E:\\workspace\\ideaWork\\Spring-boot)2017-02-26 10:51:44.833 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : No active profile set, falling back to default profiles: default2017-02-26 10:51:44.934 INFO 456 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:46.571 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-02-26 10:51:46.594 INFO 456 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-02-26 10:51:46.595 INFO 456 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.52017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1768 ms2017-02-26 10:51:46.813 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-02-26 10:51:47.044 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:47.099 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.springboot.demo.controller.HelloWorldController.helloWorld()2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.163 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.315 INFO 456 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-02-26 10:51:47.373 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-02-26 10:51:47.377 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Started HelloWorldController in 3.327 seconds (JVM running for 4.128) 测试 结语长路漫漫,与君共勉!","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"checksty配置","slug":"checkstyle","date":"2017-01-18T14:39:13.000Z","updated":"2018-01-02T03:29:09.164Z","comments":true,"path":"2017/01/18/checkstyle/","link":"","permalink":"http://www.eumji025.com/2017/01/18/checkstyle/","excerpt":"","text":"配置文件由于checkstyle默认是使用google的开发规范,相对来说比较严格,因此采用自定义的规范.本文的配置文件来源于网络,后续将会进行改动. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\" \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\"&gt;&lt;module name=\"Checker\"&gt; &lt;!-- 消息提示等级 --&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;!-- 字符集限制 --&gt; &lt;property name=\"charset\" value=\"UTF-8\"/&gt; &lt;module name=\"TreeWalker\"&gt; &lt;!-- javadoc的检查 --&gt; &lt;!-- 检查所有的interface和class --&gt; &lt;module name=\"JavadocType\"/&gt; &lt;!-- 检查所有方法的javadoc，可以不声明RuntimeException --&gt; &lt;module name=\"JavadocMethod\"&gt; &lt;property name=\"allowUndeclaredRTE\" value=\"true\"/&gt; &lt;property name=\"allowMissingPropertyJavadoc\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 检查变量的javadoc --&gt; &lt;module name=\"JavadocVariable\"&gt; &lt;property name=\"scope\" value=\"public\"/&gt; &lt;/module&gt; &lt;!-- 命名方面的检查，它们都使用了Sun官方定的规则。 --&gt; &lt;!-- 类名(class 或interface) 的检查 --&gt; &lt;module name=\"TypeName\"/&gt; &lt;!-- 变量的检查 --&gt; &lt;module name=\"MemberName\"/&gt; &lt;!-- 方法名的检查 --&gt; &lt;module name=\"MethodName\"/&gt; &lt;!-- 方法的参数名 --&gt; &lt;module name=\"ParameterName \"/&gt; &lt;!-- 常量名的检查 --&gt; &lt;module name=\"ConstantName\"/&gt; &lt;!-- 长度方面的检查 --&gt; &lt;!-- 文件长度不超过1500行 --&gt; &lt;!-- 每行不超过120个字--&gt; &lt;module name=\"LineLength\"&gt; &lt;property name=\"max\" value=\"120\"/&gt; &lt;/module&gt; &lt;!-- 方法不超过30行 --&gt; &lt;module name=\"MethodLength\"&gt; &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt; &lt;property name=\"max\" value=\"30\"/&gt; &lt;/module&gt; &lt;!-- 方法的参数个数不超过3个。 --&gt; &lt;module name=\"ParameterNumber\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 多余的关键字 --&gt; &lt;module name=\"RedundantModifier\"/&gt; &lt;!-- 对区域的检查 --&gt; &lt;!-- 不能出现空白区域 --&gt; &lt;module name=\"EmptyBlock\"/&gt; &lt;!-- 所有区域都要使用大括号。 --&gt; &lt;module name=\"NeedBraces\"/&gt; &lt;!-- 多余的括号 --&gt; &lt;module name=\"AvoidNestedBlocks\"&gt; &lt;property name= \"allowInSwitchCase\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 编码方面的检查 --&gt; &lt;!-- 不许出现空语句 --&gt; &lt;module name=\"EmptyStatement\"/&gt; &lt;!-- 每个类都实现了equals()和hashCode() --&gt; &lt;module name=\"EqualsHashCode\"/&gt; &lt;!-- 不许使用switch --&gt; &lt;module name=\"IllegalToken\"&gt; &lt;property name=\"tokens\" value=\"LITERAL_SWITCH\"/&gt; &lt;/module&gt; &lt;!-- 不许内部赋值 --&gt; &lt;module name=\"InnerAssignment\"/&gt; &lt;!-- 绝对不能容忍魔法数 --&gt; &lt;module name=\"MagicNumber\"/&gt; &lt;!-- 循环控制变量不能被修改 --&gt; &lt;module name=\"ModifiedControlVariable\"/&gt; &lt;!-- 多余的throw --&gt; &lt;!-- &lt;module name=\"RedundantThrows\"/&gt; --&gt; &lt;!-- 不许使用未被简化的条件表达式 --&gt; &lt;module name=\"SimplifyBooleanExpression\"/&gt; &lt;!-- 不许使用未被简化的布尔返回值 --&gt; &lt;module name=\"SimplifyBooleanReturn\"/&gt; &lt;!-- String的比较不能用!= 和 == --&gt; &lt;module name=\"StringLiteralEquality\"/&gt; &lt;!-- if最多嵌套3层 --&gt; &lt;module name=\"NestedIfDepth\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- try最多被嵌套1层 --&gt; &lt;module name=\"NestedTryDepth\"/&gt; &lt;!-- clone方法必须调用了super.clone() --&gt; &lt;module name=\"SuperClone\"/&gt; &lt;!-- finalize 必须调用了super.finalize() --&gt; &lt;module name=\"SuperFinalize\"/&gt; &lt;!-- 不能catch java.lang.Exception --&gt; &lt;module name=\"IllegalCatch\"&gt; &lt;property name=\"illegalClassNames\" value=\"java.lang.Exception\"/&gt; &lt;/module&gt; &lt;!-- JUnitTestCase 的核心方法存在。 --&gt; &lt;!-- &lt;module name=\"JUnitTestCase\"/&gt; --&gt; &lt;!-- 一个方法中最多有3个return --&gt; &lt;module name=\"ReturnCount\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 不许对方法的参数赋值 --&gt; &lt;module name=\"ParameterAssignment\"/&gt; &lt;!-- 不许有同样内容的String --&gt; &lt;module name=\"MultipleStringLiterals\"/&gt; &lt;!-- 同一行不能有多个声明 --&gt; &lt;module name=\"MultipleVariableDeclarations\"/&gt; &lt;!-- 各种量度 --&gt; &lt;!-- 布尔表达式的复杂度，不超过3 --&gt; &lt;module name=\"BooleanExpressionComplexity\"/&gt; &lt;!-- 类数据的抽象耦合，不超过7 --&gt; &lt;module name=\"ClassDataAbstractionCoupling\"/&gt; &lt;!-- 类的分散复杂度，不超过20 --&gt; &lt;module name=\"ClassFanOutComplexity\"/&gt; &lt;!-- 函数的分支复杂度，不超过10 --&gt; &lt;module name=\"CyclomaticComplexity\"/&gt; &lt;!-- NPath复杂度，不超过200 --&gt; &lt;module name=\"NPathComplexity\"/&gt; &lt;!-- 杂项 --&gt; &lt;!-- 禁止使用System.out.println --&gt; &lt;!-- &lt;module name=\"GenericIllegalRegexp\"&gt; &lt;property name=\"format\" value=\"System\\.out\\.println\"/&gt; &lt;property name=\"ignoreComments\" value=\"true\"/&gt; &lt;/module&gt; --&gt; &lt;!-- 不许使用与代码同行的注释 --&gt; &lt;module name=\"TrailingComment\"/&gt; &lt;!-- 不允许存在todo标签 --&gt; &lt;module name=\"TodoComment\"&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;property name=\"format\" value=\"TODO\"/&gt; &lt;/module&gt; &lt;/module&gt; &lt;module name=\"FileLength\"&gt; &lt;property name=\"max\" value=\"1500\"/&gt; &lt;/module&gt; &lt;!-- 检查翻译文件 --&gt; &lt;module name=\"Translation\"/&gt;&lt;/module&gt; 注未完待续","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://www.eumji025.com/tags/tools/"}]},{"title":"web开发常用注解","slug":"annotation","date":"2017-01-11T15:14:31.000Z","updated":"2018-01-14T02:56:23.850Z","comments":true,"path":"2017/01/11/annotation/","link":"","permalink":"http://www.eumji025.com/2017/01/11/annotation/","excerpt":"","text":"简介概念 Annotation(注解)是JDK1.5及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。另外，你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。 分类①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 WEB开发中常用的注解Spring篇@Controller@Controller 定义控制器，映射页面URL的请求,只有被@Controller声明的类才会到对应类下找到对应@Requestmapping配置的URL 开启扫描@Controller注解需要在spring-mvc.xml中配置 1234&lt;!-- 扫描web相关的Bean 使用Annotation自动注册Bean,只扫描@Controller --&gt; &lt;context:component-scan base-package=\"com.jsu.controller\" use-default-filters=\"false\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!-- 子标签是用来添加扫描注解的 --&gt; &lt;/context:component-scan&gt; 简化配置版 1&lt;context:component-scan base-package=\"com.jsu.controller\"/&gt; ### @RequestMapping @RequestMapping 注解将类似 “/index”这样的URL映射到整个类或特定的处理方法上。类级别的注解映射特定的请求路径到表单控制器上，而方法级别的注解只是映射为一个特定的HTTP方法请求（“GET”，“POST”等）或HTTP请求参数。简而言之,公共的请求路径使用@RequestMapping放在类声明上,而特有的请求放在方法上,如下例: 12345678910111213141516@RequestMapping(\"/perm/permission\")public class PermissionController extends BaseController &#123; @Autowired private IPermissionService permissionService; @RequestMapping(\"/list\") public String list(Model model) &#123; return \"/permission/list\"; &#125; @RequestMapping(\"/getPermissionList\") @ResponseBody public String getPermissionList() &#123; Page&lt;Permission&gt; page = getPage(); return jsonPage(permissionService.selectPage(page, null)); &#125;&#125; 补充:随着Spring的发展,在@RequestMapping的注解基础之上又发展了几个新的类似注解: @GetMapping =&gt; get方式的请求表示;@PustMapping =&gt; post方式的请求;@DeleteMapping =&gt; delete方式的请求;@PutMapping =&gt; put方式的请求;@PatchMapping =&gt; patch方式的请求. @PathVariableURI 模版是一个类似于 URI 的字符串，其中包含了一个或多个变量。当你将这些变量替换掉市，就变回了 URI。 URI 模版格式 proposed RFC 定义了如何参数化 URI。比如，URI 模版 http://www.example.com/users/{userId}，包含了变量 userId，设置此变量为 __fred，就会变成http://www.example.com/users/fred。 可在方法入参上使用注解 @PathVariable 绑定 URI 的模版参数: 123456@RequestMapping(value=\"/owners/&#123;ownerId&#125;\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) &#123; Owner owner = ownerService.findOwner(ownerId); model.addAttribute(\"owner\", owner); return \"displayOwner\";&#125; @PathVariable 参数可以是任意的简单类型（如 int，long，Date 等），Spring 会自动将其进行类型转换，转换出错会抛出 TypeMismatchException. @RequestBody常用语接受前台请求的json格式数据,可以转化成对象接受. 12345@Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) &#123; // 实现省略&#125; @ResponseBody@ResponseBody 的使用类似于 @RequestBody。此注解用在方法上，用来表示直接将返回数据写到 HTTP 响应体里。注意，不是将数据放到 Model 中，或解析为视图名称。如下例: 12345@RequestMapping(value = \"/something\", method = RequestMethod.PUT)@ResponseBodypublic String helloWorld() &#123; return \"Hello World\";&#125; 常用于ajax请求. Bean相关@Service,@Controller,@Repository,@Component@Service =&gt; 通常用于服务层声明Bean@Controller =&gt; 通常用于控制层声明Bean@Repository =&gt; 用于持久层声明Bean(是JPA的注解)@Component =&gt; 声明通用Bean,也就是当你无法把一个Bean合理归类到上述三种情况时,使用此注解. @Bean@Bean是一种代替xml声明Bean的方式,具体如下所示:1234@Beanpublic HelloServiceImpl transferService()&#123; return new HelloServiceImpl();&#125; 上述描述就等同于如下的xml123&lt;beans&gt; &lt;bean id=\"helloServiceImpl\" class=\"com.eumji.HelloServiceImpl\"/&gt;&lt;/beans&gt; 因为Spring4之后,鼓励大家使用注解的方式去声明一些Bean. 详情请参考spring官方文档-bean @Autowire@Autowire是spring官方提供的一种装配方式。(默认byType) ＠Resource＠Resource是java自带的一种装配方式。默认按名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。 ## @Qualifier正因为＠Autowired注解使用的byType方式进行注入的,所以当如果一个Service有多个实现类的时候,就会出现不知所措的局面,因此@Qualifier的主要目的就是指定Bean的名称. 所以选择使用那种注解,需要自己去权衡. JPA实体类注解### @Entity 标注于实体类上，通常和@Table是结合使用的，代表是该类是实体类 @Table标注在实体类上,表示该实体类对应数据库中的一张表 @Id 标注于属性上，通常是在get方法上，也可以在属性的声明上。用于表示该属性作为ID主键. @GeneratedValue12345678910//源码@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface GeneratedValue &#123; GenerationType strategy() default AUTO; //默认是AUTO String generator() default \"\";&#125; 12345678910111213141516171819202122public enum GenerationType &#123; /** * 自增长 */ TABLE, /** * 通过序列 */ SEQUENCE, /** * 由数据库维护 */ IDENTITY, /** * 自动选择合适的方案分配 */ AUTO&#125; 即主键生成策略,通常和@Id配合使用. @Column标注于属性上，有很多功能，例如指定长度、是否为空，列名以及对应到数据库汇中的类型等,具体如下源码所示 12345678910111213141516@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface Column &#123; //设置对应数据库名 String name() default \"\"; //是否唯一 boolean unique() default false; //是否可以为空 boolean nullable() default true; //是否可以掺入 boolean insertable() default true; //设置长度 int precision() default 0; //精度 int scale() default 0;&#125; @OrderBy设置排序.ASC和DESC.默认ASC 12345@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface OrderBy &#123; String value() default \"\";&#125; ### @ManyToMany&amp;&amp;@OneToMany 设置对应关系,多对多,一对多 @DateTimeFormat格式化时间,放在属性上 1234567891011121314151617181920@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)public @interface DateTimeFormat &#123; String style() default \"SS\"; DateTimeFormat.ISO iso() default DateTimeFormat.ISO.NONE; String pattern() default \"\"; public static enum ISO &#123; DATE, //日期 TIME, //时间 DATE_TIME, //时间+日期 NONE; //无 private ISO() &#123; &#125; &#125;&#125; ## Jackson注解 JsonProperty设置某个属性在转成json后的名称 1234public class Name &#123; @JsonProperty(\"sex\") public String t_sex;&#125; 转化成json格式后是这样的: 将会生成如下所示的JSON数据结果：{ “sex” : “man” } @JsonIgnoreProperties此注解是类注解，作用是json序列化时将Java bean中的一些属性忽略掉，序列化和反序列化都受影响. @JsonIgnore 此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。示例: 12345public class KeyValue &#123; public int value; @JsonIgnore public int key;&#125; 12转成json字符串后://将会忽略key&#123; &quot;value&quot; : 42 &#125; @JsonFormat此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，比如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”) @JsonSerialize 此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码. @JsonDeserialize 此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码. Mybatis注解### @Alias ＠Alias是mybatis中一个注解,类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。xml中通常这样配置. 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"com.eumji025.vo.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"com.eumji025.vo.Blog\"/&gt;&lt;/typeAliases&gt; 也可以在xml中直接指定包名如下: 123&lt;typeAliases&gt; &lt;package name=\"com.eumji025.vo\"/&gt;&lt;/typeAliases&gt; 每一个在包 com.eumji025.vo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。比如 com.eumji025.vo.Author 的别名为 author 如通过注解已经设置别名则按照注解的别名来使用: 1234@Alias(\"author\")public class Author &#123; ...&#125; 当然mybatis为了使用方便,已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。具体如下: 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 注后续继续补充","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"Idea-Maven项目的创建和部署","slug":"Idea-Maven项目的创建和部署","date":"2016-11-21T12:12:40.000Z","updated":"2018-01-01T10:14:54.099Z","comments":true,"path":"2016/11/21/Idea-Maven项目的创建和部署/","link":"","permalink":"http://www.eumji025.com/2016/11/21/Idea-Maven项目的创建和部署/","excerpt":"","text":"前言由于Intellij Idea创建项目方式和eclipse有一定的区别，所有maven项目也是一样。 目的学会使用idea创建和部署Maven项目。 过程创建空的项目 创建maven module1.点击+号创建 2.选择maven webapp 3输入groupId和ArtifactId 4.陪著maven相关信息。 5设置名字 完成。6.等待一段时间，maven自动加载web项目相关的配置7 修改pom文件 注意添加packaging 8 修改项目配置 提示maven-tomcat插件配置 发布 右键项目 run maven-maven-tomcat即可 结语 与君共勉！","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://www.eumji025.com/tags/Intellij-Idea/"}]},{"title":"推荐的markdown编辑器","slug":"推荐的markdown编辑器","date":"2016-11-05T01:26:54.000Z","updated":"2018-01-02T03:29:09.172Z","comments":true,"path":"2016/11/05/推荐的markdown编辑器/","link":"","permalink":"http://www.eumji025.com/2016/11/05/推荐的markdown编辑器/","excerpt":"","text":"介绍Typora是一款非常优雅的markdown编辑器 因为它将「写字」和「预览」合并，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。 一切都变得如此干净、纯粹。 官网 传送门： hexo官网 安装windows 下载地址 安装没有难度 linux sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys BA300B7755AFCFAE sudo add-apt-repository ‘deb https://typora.io ./linux/‘ sudo apt-get update sudo apt-get install typora mac 解压安装 功能介绍表格编辑其他的markdown表格编辑方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 十分复杂的操作有木有 Typora表格操作方式 CTRL+T快捷键直接生成 图片操作插入图片的语法 1![logo](http://typora.io/img/favicon-128.png) typora语法 CTRL+SHIFT+I 更简单的直接将图片拖拽进来即可。 目录大纲 Typora 还可以根据当前文档的标题层级，自动生成显示大纲， 点击软件左下角圆圈即可，就会出现字数统计和大纲预览。 圆圈旁边是切换视图按钮。 主题 ypora 默认提供了六套主题样式： Github风格、 默认主题 Gothic、 出版风格的 Newsprint、 夜间模式 Night、 Pixyll、 Whitey. 结语与君共勉！！！","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"写作","slug":"写作","permalink":"http://www.eumji025.com/tags/写作/"}]},{"title":"springMVC 几种页面跳转方式","slug":"springMVC-几种页面跳转方式","date":"2016-10-28T04:45:00.000Z","updated":"2018-01-02T03:29:09.176Z","comments":true,"path":"2016/10/28/springMVC-几种页面跳转方式/","link":"","permalink":"http://www.eumji025.com/2016/10/28/springMVC-几种页面跳转方式/","excerpt":"","text":"前言前面已经了解了Controller的几种配置方式今天主要写一下响应界面跳转的几种方式 在注解的方式中通过HttpServletResponse的API直接输出（不需要配置渲染器）controller类的主要代码 12345678@Controllerpublic class RequestController&#123; @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.getWriter().println(\"hello HttpServletResponse\"); &#125; web.xml配置 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; dispatcher-servlet.xml主要代码 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--作用是扫描指定包下所有的包含注解的类--&gt; &lt;context:component-scan base-package=\"com.jsu.mvc\"/&gt;&lt;/beans&gt; 使用HttpServletResponse 重定向到另一个视图(其他不变 )1234567 @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.sendRedirect(\"index.jsp\"); &#125;&#125; 使用HttpServletRequest 转发（默认访问/下的index.jsp页面 不受渲染器的影响）12345@RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; req.setAttribute(\"message\",\"it's forword \"); req.getRequestDispatcher(\"index.jsp\").forward(req,resp); &#125; 直接返回jsp页面的名称（无渲染器）其他的配置不变 123456789@RequestMapping(\"/nice\") public String hello1()&#123;//转发方式1 return \"home.jsp\"; //转发方式2 return \"forward:index.jsp\"; //重定向方式 return \"redirect:index.jsp\"; &#125; 当有渲染器指定123456789@RequestMapping(\"/nice\") public String hello1()&#123; //转发方式1 return \"home\"; //转发方式2 return \"forward:index\"; //重定向方式 hello指的是requsrmapping return \"redirect:hello\"; &#125; 使用view使用modelandview需要视图解析器 能指定跳转页面 12345678910111213141516public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); //封装要显示到视图的数据 mv.addObject(\"msg\",\"hello myfirst mvc\"); //视图名 mv.setViewName(\"hello\"); return mv; &#125;&#125; [servlet-name]-servlet.xml 12345678910111213&lt;!--配置渲染器--&gt; &lt;!--配置hellocontroller中页面的位置--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--结果视图的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--结果视图的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; &lt;bean name=\"/hello.do\" class=\"com.jsu.mvc.HelloController\"&gt;&lt;/bean&gt; 使用modelview不需要视图解析器 不能指定跳转页面 12345678//通过modelmap方式 @RequestMapping(\"/modelmap\") public String modelHello(String name,ModelMap map)&#123; map.addAttribute(\"name\",name); System.out.println(name); return \"index.jsp\"; &#125; 结语与君共勉！","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.eumji025.com/tags/Spring-MVC/"}]},{"title":"使用idea开发srpingMVC第一个Demo","slug":"使用idea开发srpingMVC第一个Demo","date":"2016-10-28T04:24:48.000Z","updated":"2018-01-14T02:21:37.350Z","comments":true,"path":"2016/10/28/使用idea开发srpingMVC第一个Demo/","link":"","permalink":"http://www.eumji025.com/2016/10/28/使用idea开发srpingMVC第一个Demo/","excerpt":"","text":"主要目的是熟悉intellij的web项目操作和springMVC的基本概念,纯属个人学习的笔记,有写的不当的地方欢迎指正 ###操作环境说明操作系统： win10ide版本： 2017.1.5 开发过程本文原始的版本是在个人学习写的，所以很多东西写的不够详细。本次重新归纳总结，下面开始具体操作： 创建项目创建一个empty projectFile -&gt; new -&gt; project -&gt; empty project ###创建module说明一下，在实际开发中我们喜欢一个项目一个project，但是学习之中，为了方便来回切换，所以我们每一个demo都写成module的形式。 创建 module(在此之前需要创建entity project)在新版本中，会提示你是下载勾选的mvc的依赖。 然后填写module名 点击确认 module创建完毕（作者因为乱码的关系 ￥代表 /） 结构预览并修改配置在module的web-WEB-INF下新建 classes和lib文件夹（新版本中的lib在根目录下） 1.IDEA默认是不会像eclipse那样在web-inf下生成lib文件夹和classes文件夹的的，需要我们手动的创建，并将我们根目录下的lib目录下的内容复制到web-inf/lib文件夹内。并且还需要进行额外配置。 点击file-&gt;Project Struture 修改Modules下的paths 修改完毕点击OK（主要是为了跟ecilpse结构相似，也可以不改） 2.然后点击dependencis - &gt; 绿色的+ -&gt; 选择第一项，选择刚才我们在WEB-INF下创建的lib文件夹，和eclipse的导包一个性质。 3.回到主界面，配置tomcat 点击run-&gt;edit configurations‘点绿色的十字图标 创建tomcat并配置 选择自己的tomcat位置点击deployment -&gt; 绿色+号 -&gt; 选择我们的项目 代码编写 web,xml 不需要进行修改，有默认的就行了。 修改dispatcjer-servlet.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--对应src下的报名，需要自己新建--&gt; &lt;context:component-scan base-package=\"com.eumji.mvc\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;!--jsp文件夹需要自己手动创建--&gt; &lt;value&gt;/WEB-INF/jsp/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.在jsp目录下新建hello.jsp123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello mvc&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg &#125;&lt;/body&gt;&lt;/html&gt; 4.在src中编写controller类需要和dispatcher-servlet.xml配置的路径一致12345678@Controllerpublic class HelloController &#123; @RequestMapping(value=&quot;/hello&quot;,method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute(&quot;msg&quot;, &quot;Spring 3 MVC Hello World&quot;); return &quot;hello&quot;; &#125;&#125; 5.点击右上角的绿色三角形进行运行，最后进行测试 第一个小demo到此结束！ 最后说几句Intellij IDEA和eclipse的使用有很大的不同，本文只是带领着使用IDEA进行web项目的创建和测试。并没有对spring MVC框架本身的内容进行过多的讲解。IDEA创建普通的web 项目确实比较麻烦，使用maven的方式更佳。 补充还是补充一下创建maven项目的姿势 创建maven module 1.点击+号创建 2.选择maven webapp3输入groupId和ArtifactId4.陪著maven相关信息。最好是设置一下maven的setting文件,无论是自带的还是自己配置的maven,修改一下maven的镜像地址.在maven的settings.xml 文件里配置mirrors的子节点，添加如下mirror &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 5.文件夹名称,创建完成.6.加载 等待一段时间，maven自动加载web项目相关的配置 7 .修改pom文件注意添加packaging8 修改项目配置 maven-tomcat插件配置 发布右键项目 run maven-maven-tomcat即可 spring boot特别推荐一下使用spring boot,对新手非常友好,而且可以使用spring initialize生成项目,并且不需要配置tomcat. 源码地址https://github.com/eumji025/my-demo/tree/master/hello-mvc","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://www.eumji025.com/tags/Intellij-Idea/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.eumji025.com/tags/Spring-MVC/"}]}]}