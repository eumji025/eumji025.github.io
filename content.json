{"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-12-31T16:08:16.263Z","updated":"2017-09-16T11:09:26.060Z","comments":false,"path":"/404.html","permalink":"http://blog.eumji025.com//404.html","excerpt":"","text":""},{"title":"About","date":"2017-12-31T16:08:16.299Z","updated":"2017-09-16T11:09:26.071Z","comments":false,"path":"about/index.html","permalink":"http://blog.eumji025.com/about/index.html","excerpt":"","text":"个人简介"},{"title":"Categories","date":"2017-12-31T16:08:16.379Z","updated":"2017-09-16T11:09:26.077Z","comments":false,"path":"categories/index.html","permalink":"http://blog.eumji025.com/categories/index.html","excerpt":"","text":""},{"title":"Books","date":"2017-12-31T16:08:16.343Z","updated":"2017-09-16T11:09:26.074Z","comments":false,"path":"books/index.html","permalink":"http://blog.eumji025.com/books/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-12-31T16:08:16.411Z","updated":"2017-09-16T11:09:26.081Z","comments":true,"path":"links/index.html","permalink":"http://blog.eumji025.com/links/index.html","excerpt":"","text":""},{"title":"Repository","date":"2017-12-31T16:08:16.107Z","updated":"2017-09-16T11:09:26.085Z","comments":false,"path":"repository/index.html","permalink":"http://blog.eumji025.com/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-31T16:08:16.163Z","updated":"2017-09-16T11:09:26.090Z","comments":false,"path":"tags/index.html","permalink":"http://blog.eumji025.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"展望2018","slug":"2018-target","date":"2017-12-31T16:08:47.000Z","updated":"2017-12-31T16:19:09.144Z","comments":true,"path":"2018/01/01/2018-target/","link":"","permalink":"http://blog.eumji025.com/2018/01/01/2018-target/","excerpt":"","text":"总结2017 懵懵懂懂又一年,总的来说离目标还有一些距离. 展望2018 该做的事情还是得做 该看的书籍还是得看 该敲的代码还是得敲 该学的东西还是得学 基础目标1.go语言入门 2.docker入门 3.java虚拟机入门 4.spring 源码该读了 5.还是一个开源项目 6.技术类文章30篇(保质保量) 7.沉淀 结语新的一年,新的开始,也应该做一些新的尝试. 前路漫漫,且行且思.","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"target","slug":"target","permalink":"http://blog.eumji025.com/tags/target/"}]},{"title":"oracle中dual表介绍","slug":"dual-introduce","date":"2017-12-31T16:08:14.547Z","updated":"2017-02-26T02:32:51.211Z","comments":true,"path":"2018/01/01/dual-introduce/","link":"","permalink":"http://blog.eumji025.com/2018/01/01/dual-introduce/","excerpt":"","text":"oracle dual表dual表是oracle提供的最小表，只有一行一列，具有一些 特殊用途。善用dual表能为开发带来极大的便利。 dual 用途充当伪列。在批量插入中常使用这种方式。 insert into user(name,age) select &apos;zhangsan&apos;,18 from dual select &apos;lisi&apos;,29 from dual 调用系统函数获取系统时间。 select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual 更多场景可以自己测试。 结语最近在使用批量插入数据时接触到dual表，发现是非常有用的一张表，值得我们去学习使用。","categories":[{"name":"databasse","slug":"databasse","permalink":"http://blog.eumji025.com/categories/databasse/"}],"tags":[{"name":"dual","slug":"dual","permalink":"http://blog.eumji025.com/tags/dual/"},{"name":"oracle","slug":"oracle","permalink":"http://blog.eumji025.com/tags/oracle/"}]},{"title":"spring-boot跳转页面","slug":"springboot-indexPage","date":"2017-03-26T00:04:54.000Z","updated":"2017-03-26T00:40:31.212Z","comments":true,"path":"2017/03/26/springboot-indexPage/","link":"","permalink":"http://blog.eumji025.com/2017/03/26/springboot-indexPage/","excerpt":"","text":"前言 本篇博客记录spring boot如何跳转到静态首页.因为是初学的关系很多知识点都不懂,而且spring boot的项目没有webapp也没有配置文件.所以思考蛮久,经过查阅资料最终找到方法,做一次学习记录. Demo其实配置起来相对简单,只是一直没有找到配置的方法,翻看了官方文档,眼拙也没找到. 其实只需要在resources目录下新建static文件夹,并把html文件放在其中即可. 目录配置 Controller12345678@Controllerpublic class PageController &#123; @RequestMapping(\"indexPage\") public String indexPage()&#123; return \"index.html\"; &#125;&#125; 注: 在我暂时的尝试中,只能跳转一个页面,配多个也没用,可能是我自己学习的不够到位.后续学习中再做修改. 结果展示 结语与君共勉! BGM","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://blog.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-customport","slug":"spring-boot-customport","date":"2017-02-26T12:19:56.000Z","updated":"2017-02-26T12:36:21.704Z","comments":true,"path":"2017/02/26/spring-boot-customport/","link":"","permalink":"http://blog.eumji025.com/2017/02/26/spring-boot-customport/","excerpt":"","text":"Spring boot 自定义端口前言spring boot本身内置tomcat,我们不需要进行tomcat的配置,只需要引入tomcat的依赖即可. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt; 自定义端口1.spring boot中自定义端口需要入口类实现ConfigurableEmbeddedServletContainer接口.如下代码 1234567891011121314151617181920@RestController@EnableAutoConfigurationpublic class CustomPortController implements EmbeddedServletContainerCustomizer &#123; /** * 自定义端口 * @param container */ public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8888); &#125; @RequestMapping(\"/\") public String setPort()&#123; return \"自定义端口:8888\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(CustomPortController.class,args); &#125;&#125; 2.直接自定义ConfigurableEmbeddedServletContainer.通过自己注册TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory 12345678@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory(); factory.setPort(9000); factory.setSessionTimeout(10, TimeUnit.MINUTES); factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, \"/notfound.html\"); return factory;&#125; 结语长路漫漫,与君共勉!","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://blog.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-helloworld","slug":"spring-boot-helloworld","date":"2017-02-26T02:32:34.000Z","updated":"2017-02-26T02:57:36.123Z","comments":true,"path":"2017/02/26/spring-boot-helloworld/","link":"","permalink":"http://blog.eumji025.com/2017/02/26/spring-boot-helloworld/","excerpt":"","text":"Spring boot介绍 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 Spring boot 特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 Spring boot第一个demo说明本文采用maven方式构建项目.(maven学习地址) 开发环境 maven intellij idea java8 (推荐java7及以上版本) 构建项目第一个项目相对简单,我们不做过多的配置,只需要简单的引入spring-boot提供默认parent就可以了. 123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot.demo&lt;/groupId&gt; &lt;artifactId&gt;FirstDemo&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;FirstDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--内置tomcat和springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;FirstDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 代码编写123456789101112@RestController@EnableAutoConfigurationpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String helloWorld()&#123; return \"Hello world!\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldController.class,args); &#125;&#125; 注: 1.@RestController和@RequestMapping注解是springMVC的注解,分别用来注册controller类和映射对应地址的http请求. 2.@EnableAutoConfiguration注解,Spring Boot根据添加的jar依赖自动配置spring. 3.main方法通过调用run， 将业务委托给了Spring Boot的SpringApplication类。 SpringApplication将引导我们的应用， 启动Spring， 相应地启动被自动配置的Tomcat web服务器。 启动服务12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.4.1.RELEASE)2017-02-26 10:51:44.822 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Starting HelloWorldController on EumJi025 with PID 456 (E:\\workspace\\ideaWork\\Spring-boot\\FirstDemo\\target\\classes started by EumJi in E:\\workspace\\ideaWork\\Spring-boot)2017-02-26 10:51:44.833 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : No active profile set, falling back to default profiles: default2017-02-26 10:51:44.934 INFO 456 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:46.571 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-02-26 10:51:46.594 INFO 456 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-02-26 10:51:46.595 INFO 456 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.52017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1768 ms2017-02-26 10:51:46.813 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-02-26 10:51:47.044 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:47.099 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.springboot.demo.controller.HelloWorldController.helloWorld()2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.163 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.315 INFO 456 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-02-26 10:51:47.373 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-02-26 10:51:47.377 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Started HelloWorldController in 3.327 seconds (JVM running for 4.128) 测试 结语长路漫漫,与君共勉!","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://blog.eumji025.com/tags/spring-boot/"}]},{"title":"redis应用场景","slug":"redis-use","date":"2017-02-19T11:04:52.000Z","updated":"2017-02-26T02:32:51.213Z","comments":true,"path":"2017/02/19/redis-use/","link":"","permalink":"http://blog.eumji025.com/2017/02/19/redis-use/","excerpt":"","text":"redis应用场景大对象存储可以存储例如文章这样的大对象。 使用最简单的String就可以。 消息队列利用redis中list类型，双向列表的作用，可以做先进先出的消息队列，最简单的例子就是点菜。按时间进行进入队列。 排行榜（微博热搜榜）利用redis中的sorted set的特性，可以对每种话题进行设置，然后可以排序取出最大的前几个。","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.eumji025.com/tags/redis/"}]},{"title":"ｒｅｄｉｓ服务器配置","slug":"redis-set","date":"2017-02-10T12:20:15.000Z","updated":"2017-02-26T02:32:51.213Z","comments":true,"path":"2017/02/10/redis-set/","link":"","permalink":"http://blog.eumji025.com/2017/02/10/redis-set/","excerpt":"","text":"redis服务器配置修改配置文件123456#端口号 不推荐使用默认端口.防攻击port 6996#绑定ipbind 192.168.1.111#口令requirepass eumji 更多详情的配置介绍请查看配置介绍 远程链接测试 链接失败原因总结1.没有安装openssh 2.可能由于防火墙拦截 3.可能连接信息错误","categories":[{"name":"redis","slug":"redis","permalink":"http://blog.eumji025.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.eumji025.com/tags/redis/"}]},{"title":"union","slug":"union","date":"2017-02-09T14:13:25.000Z","updated":"2017-02-26T02:32:51.216Z","comments":true,"path":"2017/02/09/union/","link":"","permalink":"http://blog.eumji025.com/2017/02/09/union/","excerpt":"","text":"union 操作符UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 union用法123select name from user1unionselect name from user2 user1表数据 id name 1 zhangsan 2 zhangsan1 3 zhangsan1 4 zhangsan2 5 zhangsan4 user2表数据 id name 1 zhangsan 2 lisi 3 wangwu 结果 name zhangsan zhangsan1 zhangsan2 zhangsan4 lisi wangwu 注释：UNION 操作符选取不同的值。 使用 UNION ALL 命令列出所有的值,包括相同的。 SQL UNION ALL 语法123select name from user1union allselect name from user2 结果 name zhangsan zhangsan1 zhangsan1 zhangsan2 zhangsan4 zhangsan lisi wangwu 注释：UNION 操作符选取所有的值。 结语union在后续的数据抽取中非常的重要。","categories":[{"name":"database","slug":"database","permalink":"http://blog.eumji025.com/categories/database/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://blog.eumji025.com/tags/sql/"}]},{"title":"checksty配置","slug":"checkstyle","date":"2017-01-18T14:39:13.000Z","updated":"2017-02-26T02:32:51.210Z","comments":true,"path":"2017/01/18/checkstyle/","link":"","permalink":"http://blog.eumji025.com/2017/01/18/checkstyle/","excerpt":"","text":"配置文件由于checkstyle默认是使用google的开发规范,相对来说比较严格,因此采用自定义的规范.本文的配置文件来源于网络,后续将会进行改动. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\" \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\"&gt;&lt;module name=\"Checker\"&gt; &lt;!-- 消息提示等级 --&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;!-- 字符集限制 --&gt; &lt;property name=\"charset\" value=\"UTF-8\"/&gt; &lt;module name=\"TreeWalker\"&gt; &lt;!-- javadoc的检查 --&gt; &lt;!-- 检查所有的interface和class --&gt; &lt;module name=\"JavadocType\"/&gt; &lt;!-- 检查所有方法的javadoc，可以不声明RuntimeException --&gt; &lt;module name=\"JavadocMethod\"&gt; &lt;property name=\"allowUndeclaredRTE\" value=\"true\"/&gt; &lt;property name=\"allowMissingPropertyJavadoc\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 检查变量的javadoc --&gt; &lt;module name=\"JavadocVariable\"&gt; &lt;property name=\"scope\" value=\"public\"/&gt; &lt;/module&gt; &lt;!-- 命名方面的检查，它们都使用了Sun官方定的规则。 --&gt; &lt;!-- 类名(class 或interface) 的检查 --&gt; &lt;module name=\"TypeName\"/&gt; &lt;!-- 变量的检查 --&gt; &lt;module name=\"MemberName\"/&gt; &lt;!-- 方法名的检查 --&gt; &lt;module name=\"MethodName\"/&gt; &lt;!-- 方法的参数名 --&gt; &lt;module name=\"ParameterName \"/&gt; &lt;!-- 常量名的检查 --&gt; &lt;module name=\"ConstantName\"/&gt; &lt;!-- 长度方面的检查 --&gt; &lt;!-- 文件长度不超过1500行 --&gt; &lt;!-- 每行不超过120个字--&gt; &lt;module name=\"LineLength\"&gt; &lt;property name=\"max\" value=\"120\"/&gt; &lt;/module&gt; &lt;!-- 方法不超过30行 --&gt; &lt;module name=\"MethodLength\"&gt; &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt; &lt;property name=\"max\" value=\"30\"/&gt; &lt;/module&gt; &lt;!-- 方法的参数个数不超过3个。 --&gt; &lt;module name=\"ParameterNumber\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 多余的关键字 --&gt; &lt;module name=\"RedundantModifier\"/&gt; &lt;!-- 对区域的检查 --&gt; &lt;!-- 不能出现空白区域 --&gt; &lt;module name=\"EmptyBlock\"/&gt; &lt;!-- 所有区域都要使用大括号。 --&gt; &lt;module name=\"NeedBraces\"/&gt; &lt;!-- 多余的括号 --&gt; &lt;module name=\"AvoidNestedBlocks\"&gt; &lt;property name= \"allowInSwitchCase\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 编码方面的检查 --&gt; &lt;!-- 不许出现空语句 --&gt; &lt;module name=\"EmptyStatement\"/&gt; &lt;!-- 每个类都实现了equals()和hashCode() --&gt; &lt;module name=\"EqualsHashCode\"/&gt; &lt;!-- 不许使用switch --&gt; &lt;module name=\"IllegalToken\"&gt; &lt;property name=\"tokens\" value=\"LITERAL_SWITCH\"/&gt; &lt;/module&gt; &lt;!-- 不许内部赋值 --&gt; &lt;module name=\"InnerAssignment\"/&gt; &lt;!-- 绝对不能容忍魔法数 --&gt; &lt;module name=\"MagicNumber\"/&gt; &lt;!-- 循环控制变量不能被修改 --&gt; &lt;module name=\"ModifiedControlVariable\"/&gt; &lt;!-- 多余的throw --&gt; &lt;!-- &lt;module name=\"RedundantThrows\"/&gt; --&gt; &lt;!-- 不许使用未被简化的条件表达式 --&gt; &lt;module name=\"SimplifyBooleanExpression\"/&gt; &lt;!-- 不许使用未被简化的布尔返回值 --&gt; &lt;module name=\"SimplifyBooleanReturn\"/&gt; &lt;!-- String的比较不能用!= 和 == --&gt; &lt;module name=\"StringLiteralEquality\"/&gt; &lt;!-- if最多嵌套3层 --&gt; &lt;module name=\"NestedIfDepth\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- try最多被嵌套1层 --&gt; &lt;module name=\"NestedTryDepth\"/&gt; &lt;!-- clone方法必须调用了super.clone() --&gt; &lt;module name=\"SuperClone\"/&gt; &lt;!-- finalize 必须调用了super.finalize() --&gt; &lt;module name=\"SuperFinalize\"/&gt; &lt;!-- 不能catch java.lang.Exception --&gt; &lt;module name=\"IllegalCatch\"&gt; &lt;property name=\"illegalClassNames\" value=\"java.lang.Exception\"/&gt; &lt;/module&gt; &lt;!-- JUnitTestCase 的核心方法存在。 --&gt; &lt;!-- &lt;module name=\"JUnitTestCase\"/&gt; --&gt; &lt;!-- 一个方法中最多有3个return --&gt; &lt;module name=\"ReturnCount\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 不许对方法的参数赋值 --&gt; &lt;module name=\"ParameterAssignment\"/&gt; &lt;!-- 不许有同样内容的String --&gt; &lt;module name=\"MultipleStringLiterals\"/&gt; &lt;!-- 同一行不能有多个声明 --&gt; &lt;module name=\"MultipleVariableDeclarations\"/&gt; &lt;!-- 各种量度 --&gt; &lt;!-- 布尔表达式的复杂度，不超过3 --&gt; &lt;module name=\"BooleanExpressionComplexity\"/&gt; &lt;!-- 类数据的抽象耦合，不超过7 --&gt; &lt;module name=\"ClassDataAbstractionCoupling\"/&gt; &lt;!-- 类的分散复杂度，不超过20 --&gt; &lt;module name=\"ClassFanOutComplexity\"/&gt; &lt;!-- 函数的分支复杂度，不超过10 --&gt; &lt;module name=\"CyclomaticComplexity\"/&gt; &lt;!-- NPath复杂度，不超过200 --&gt; &lt;module name=\"NPathComplexity\"/&gt; &lt;!-- 杂项 --&gt; &lt;!-- 禁止使用System.out.println --&gt; &lt;!-- &lt;module name=\"GenericIllegalRegexp\"&gt; &lt;property name=\"format\" value=\"System\\.out\\.println\"/&gt; &lt;property name=\"ignoreComments\" value=\"true\"/&gt; &lt;/module&gt; --&gt; &lt;!-- 不许使用与代码同行的注释 --&gt; &lt;module name=\"TrailingComment\"/&gt; &lt;!-- 不允许存在todo标签 --&gt; &lt;module name=\"TodoComment\"&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;property name=\"format\" value=\"TODO\"/&gt; &lt;/module&gt; &lt;/module&gt; &lt;module name=\"FileLength\"&gt; &lt;property name=\"max\" value=\"1500\"/&gt; &lt;/module&gt; &lt;!-- 检查翻译文件 --&gt; &lt;module name=\"Translation\"/&gt;&lt;/module&gt; 注未完待续","categories":[{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/categories/java/"}],"tags":[{"name":"properties","slug":"properties","permalink":"http://blog.eumji025.com/tags/properties/"}]},{"title":"redis配置文件介绍","slug":"redis-conf","date":"2017-01-15T05:13:47.000Z","updated":"2017-02-26T02:32:51.213Z","comments":true,"path":"2017/01/15/redis-conf/","link":"","permalink":"http://blog.eumji025.com/2017/01/15/redis-conf/","excerpt":"","text":"redis配置文件reids配置文件具体如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程daemonize no#当 Redis 以守护进程的方式运行的时候，Redis 默认会把 pid 文件放在/var/run/redis.pid#可配置到其他地址，当运行多个 redis 服务时，需要指定不同的 pid 文件和端口pidfile /var/run/redis.pid#端口port 6379#指定Redis可接收请求的IP地址,不设置将处理所有请求,建议生产环境中设置# bind 127.0.0.1#客户端连接的超时时间,单位为秒,超时后会关闭连接timeout 0# Set server verbosity to &apos;debug&apos;# it can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)#日志记录等级，loglevel notice#配置 log 文件地址,默认打印在命令行终端的窗口上，也可设为/dev/null屏蔽日志、logfile stdout#设置数据库的个数,可以使用 SELECT 命令来切换数据库。databases 16#设置 Redis 进行数据库镜像的频率。保存数据到disk的策略#900秒之内有1个keys发生变化时#30秒之内有10个keys发生变化时#60秒之内有10000个keys发生变化时save 900 1save 300 10save 60 10000#在进行镜像备份时,是否进行压缩rdbcompression yes#镜像备份文件的文件名dbfilename dump.rdb#数据库镜像备份的文件放置的路径#路径跟文件名分开配置是因为 Redis 备份时，先会将当前数据库的状态写入到一个临时文件#等备份完成时，再把该临时文件替换为上面所指定的文件#而临时文件和上面所配置的备份文件都会放在这个指定的路径当中#默认值为 ./dir /var/lib/redis/#设置该数据库为其他数据库的从数据库#slaveof &lt;masterip&gt; &lt;masterport&gt; 当本机为从服务时，设置主服务的IP及端口# slaveof#指定与主数据库连接时需要的密码验证#masterauth &lt;master-password&gt; 当本机为从服务时，设置主服务的连接密码# masterauth#当slave丢失与master的连接时，或slave仍然在于master进行数据同步时（未与master保持一致）#slave可有两种方式来响应客户端请求：#1)如果 slave-serve-stale-data 设置成 &apos;yes&apos;(默认)，slave仍会响应客户端请求,此时可能会有问题#2)如果 slave-serve-stale-data 设置成 &apos;no&apos;，slave会返回&quot;SYNC with master in progress&quot;错误信息，但 INFO 和SLAVEOF命令除外。slave-serve-stale-data yes#设置客户端连接后进行任何其他指定前需要使用的密码#redis速度相当快，一个外部用户在一秒钟进行150K次密码尝试，需指定强大的密码来防止暴力破解requirepass foobared#限制同时连接的客户数量。#当连接数超过这个值时，redis 将不再接收其他连接请求，客户端尝试连接时将收到 error 信息# maxclients 128#设置redis能够使用的最大内存。#达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key（设置过expire信息的key）#在删除时,按照过期时间进行删除，最早将要被过期的key将最先被删除#如果已到期或即将到期的key删光，仍进行set操作，那么将返回错误#此时redis将不再接收写请求,只接收get请求。#maxmemory的设置比较适合于把redis当作于类似memcached 的缓存来使用# maxmemory &lt;bytes&gt;#redis 默认每次更新操作后会在后台异步的把数据库镜像备份到磁盘，但该备份非常耗时，且备份不宜太频繁#redis 同步数据文件是按上面save条件来同步的#如果发生诸如拉闸限电、拔插头等状况,那么将造成比较大范围的数据丢失#所以redis提供了另外一种更加高效的数据库备份及灾难恢复方式#开启append only 模式后,redis 将每一次写操作请求都追加到appendonly.aof 文件中#redis重新启动时,会从该文件恢复出之前的状态。#但可能会造成 appendonly.aof 文件过大，所以redis支持BGREWRITEAOF 指令，对appendonly.aof重新整理appendonly no# The name of the append only file (default: &quot;appendonly.aof&quot;)##更新日志文件名，默认值为appendonly.aof# appendfilename appendonly.aof#设置对 appendonly.aof 文件进行同步的频率#always 表示每次有写操作都进行同步,everysec 表示对写操作进行累积,每秒同步一次。#no表示等操作系统进行数据缓存同步到磁盘，都进行同步,everysec 表示对写操作进行累积,每秒同步一次# appendfsync alwaysappendfsync everysec# appendfsync no#是否开启虚拟内存支持。#redis 是一个内存数据库，当内存满时,无法接收新的写请求,所以在redis2.0后,提供了虚拟内存的支持#但需要注意的，redis 所有的key都会放在内存中，在内存不够时,只把value 值放入交换区#虽使用虚拟内存，但性能基本不受影响，需要注意的是要把vm-max-memory设置到足够来放下所有的keyvm-enabled no# vm-enabled yes#设置虚拟内存的交换文件路径，不可多个Redis实例共享vm-swap-file /tmp/redis.swap##设置开启虚拟内存后,redis将使用的最大物理内存大小。#默认为0，redis将把他所有能放到交换文件的都放到交换文件中，以尽量少的使用物理内存#即当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘#在生产环境下,需要根据实际情况设置该值,最好不要使用默认的 0vm-max-memory 0#设置虚拟内存的页大小如果 value 值比较大,如要在 value 中放置博客、新闻之类的所有文章内容，就设大一点vm-page-size 32#设置交换文件的总的 page 数量#注意page table信息是放在物理内存中，每8个page 就会占据RAM中的 1 个 byte#总的虚拟内存大小 = vm-page-size * vm-pagesvm-pages 134217728#设置 VM IO 同时使用的线程数量。vm-max-threads 4#redis 2.0后引入了 hash 数据结构。 #hash 中包含超过指定元素个数并且最大的元素当没有超过临界时，hash 将以zipmap来存储#zipmap又称为 small hash，可大大减少内存的使用hash-max-zipmap-entries 512hash-max-zipmap-value 64#是否重置Hash表#设置成yes后redis将每100毫秒使用1毫秒CPU时间来对redis的hash表重新hash，可降低内存的使用#当使用场景有较为严格的实时性需求,不能接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。#如果没有这么严格的实时性要求,可以设置为 yes,以便能够尽可能快的释放内存activerehashing yes 结语根据自己不同的需求，设置不同的redis-conf","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.eumji025.com/tags/redis/"}]},{"title":"初识redis","slug":"redis-one","date":"2017-01-14T13:54:56.000Z","updated":"2017-02-26T02:32:51.213Z","comments":true,"path":"2017/01/14/redis-one/","link":"","permalink":"http://blog.eumji025.com/2017/01/14/redis-one/","excerpt":"","text":"前言再学redis以前在学校也稍微接触过一点redis,只是是纯命令的方式,了解的redis的基本操作.事实证明,长时间不用会忘记的. 由于工作上的需要,这几天又重新学习redis. redis简介redis是一种非关系型数据库,采用key-value的方式存储数据,可存储的格式包括:String,list,set,zset,hash.Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便. redis数据类型 string set zset(有序set) list hash redis性能官方数据 测试完成了50个并发执行100000个请求。 设置和获取的值是一个256字节字符串。 Linux box是运行Linux 2.6,这是X3320 Xeon 2.5 ghz。 文本执行使用loopback接口(127.0.0.1)。 结果:读的速度是110000次/s,写的速度是81000次/s 安装1.ubuntu安装 sudo apt-install redis 2.centos安装 下载redis源码 wget http://download.redis.io/relesases/redis-3.2.6.tar.gz 解压redis **tar -xzvf redis-3.2.6.tar.gz -C ~/home cd redis-3.2.6 注意:编译redis需要先安装gcc yum install gcc 编译 make&amp;&amp;make install 运行服务器 src/redis-server 运行客户端 src/redis-cli src/redis-cli -h ip -p port -a password ##","categories":[{"name":"database","slug":"database","permalink":"http://blog.eumji025.com/categories/database/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.eumji025.com/tags/redis/"}]},{"title":"zTree_begin","slug":"zTree-begin","date":"2017-01-12T14:49:53.000Z","updated":"2017-02-26T02:32:51.217Z","comments":true,"path":"2017/01/12/zTree-begin/","link":"","permalink":"http://blog.eumji025.com/2017/01/12/zTree-begin/","excerpt":"","text":"前言zTree 是一个依靠 jQuery 实现的多功能 “树插件”。优异的性能、灵活的配置、多种功能的组合是 zTree 最大优点。支持静态 和 Ajax 异步加载节点数据.在开发中我们常需要用到树状的展示. 下载地址zTree 静态zTree开发流程引入资源123&lt;link rel=\"stylesheet\" href=\"../../../css/zTreeStyle/zTreeStyle.css\" type=\"text/css\"&gt;&lt;script type=\"text/javascript\" src=\"../../../js/jquery-1.4.4.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"../../../js/jquery.ztree.core.js\"&gt;&lt;/script&gt; html元素123&lt;div&gt; &lt;ul id=\"treeDemo\" class=\"ztree\"&gt;&lt;/ul&gt;&lt;/div&gt; JS方式一-简单json数据格式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;SCRIPT type=\"text/javascript\"&gt; &lt;!-- var setting = &#123; data: &#123; simpleData: &#123; enable: true &#125; &#125; &#125;; var zNodes =[ &#123; id:1, pId:0, name:\"父节点1 - 展开\", open:true&#125;, &#123; id:11, pId:1, name:\"父节点11 - 折叠\"&#125;, &#123; id:111, pId:11, name:\"叶子节点111\"&#125;, &#123; id:112, pId:11, name:\"叶子节点112\"&#125;, &#123; id:113, pId:11, name:\"叶子节点113\"&#125;, &#123; id:114, pId:11, name:\"叶子节点114\"&#125;, &#123; id:12, pId:1, name:\"父节点12 - 折叠\"&#125;, &#123; id:121, pId:12, name:\"叶子节点121\"&#125;, &#123; id:122, pId:12, name:\"叶子节点122\"&#125;, &#123; id:123, pId:12, name:\"叶子节点123\"&#125;, &#123; id:124, pId:12, name:\"叶子节点124\"&#125;, &#123; id:13, pId:1, name:\"父节点13 - 没有子节点\", isParent:true&#125;, &#123; id:2, pId:0, name:\"父节点2 - 折叠\"&#125;, &#123; id:21, pId:2, name:\"父节点21 - 展开\", open:true&#125;, &#123; id:211, pId:21, name:\"叶子节点211\"&#125;, &#123; id:212, pId:21, name:\"叶子节点212\"&#125;, &#123; id:213, pId:21, name:\"叶子节点213\"&#125;, &#123; id:214, pId:21, name:\"叶子节点214\"&#125;, &#123; id:22, pId:2, name:\"父节点22 - 折叠\"&#125;, &#123; id:221, pId:22, name:\"叶子节点221\"&#125;, &#123; id:222, pId:22, name:\"叶子节点222\"&#125;, &#123; id:223, pId:22, name:\"叶子节点223\"&#125;, &#123; id:224, pId:22, name:\"叶子节点224\"&#125;, &#123; id:23, pId:2, name:\"父节点23 - 折叠\"&#125;, &#123; id:231, pId:23, name:\"叶子节点231\"&#125;, &#123; id:232, pId:23, name:\"叶子节点232\"&#125;, &#123; id:233, pId:23, name:\"叶子节点233\"&#125;, &#123; id:234, pId:23, name:\"叶子节点234\"&#125;, &#123; id:3, pId:0, name:\"父节点3 - 没有子节点\", isParent:true&#125; ]; $(document).ready(function()&#123; $.fn.zTree.init($(\"#treeDemo\"), setting, zNodes); &#125;); //--&gt; &lt;/SCRIPT&gt; JS方式二-标准json数据格式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;SCRIPT type=\"text/javascript\"&gt; &lt;!-- var setting = &#123; &#125;; var zNodes =[ &#123; name:\"父节点1 - 展开\", open:true, children: [ &#123; name:\"父节点11 - 折叠\", children: [ &#123; name:\"叶子节点111\"&#125;, &#123; name:\"叶子节点112\"&#125;, &#123; name:\"叶子节点113\"&#125;, &#123; name:\"叶子节点114\"&#125; ]&#125;, &#123; name:\"父节点12 - 折叠\", children: [ &#123; name:\"叶子节点121\"&#125;, &#123; name:\"叶子节点122\"&#125;, &#123; name:\"叶子节点123\"&#125;, &#123; name:\"叶子节点124\"&#125; ]&#125;, &#123; name:\"父节点13 - 没有子节点\", isParent:true&#125; ]&#125;, &#123; name:\"父节点2 - 折叠\", children: [ &#123; name:\"父节点21 - 展开\", open:true, children: [ &#123; name:\"叶子节点211\"&#125;, &#123; name:\"叶子节点212\"&#125;, &#123; name:\"叶子节点213\"&#125;, &#123; name:\"叶子节点214\"&#125; ]&#125;, &#123; name:\"父节点22 - 折叠\", children: [ &#123; name:\"叶子节点221\"&#125;, &#123; name:\"叶子节点222\"&#125;, &#123; name:\"叶子节点223\"&#125;, &#123; name:\"叶子节点224\"&#125; ]&#125;, &#123; name:\"父节点23 - 折叠\", children: [ &#123; name:\"叶子节点231\"&#125;, &#123; name:\"叶子节点232\"&#125;, &#123; name:\"叶子节点233\"&#125;, &#123; name:\"叶子节点234\"&#125; ]&#125; ]&#125;, &#123; name:\"父节点3 - 没有子节点\", isParent:true&#125; ]; $(document).ready(function()&#123; $.fn.zTree.init($(\"#treeDemo\"), setting, zNodes); &#125;); //--&gt; &lt;/SCRIPT&gt; 异步zTree加载前面的配置相同,在此不再阐述.主要是js不同. 异步JS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var setting = &#123; //可勾选 check: &#123; enable: true &#125;, data : &#123; simpleData : &#123; enable : true &#125; &#125;&#125;; function initTree()&#123; var payFreq = $(\"#payFreq\").val(); var fyType = $('#fyType').val(); var setHzType = $('#setHzType').val(); $.ajax(&#123; url : \"/demo/initTree\", data : &#123;payFreq:payFreq, fyType:fyType, setHzType:setHzType &#125;, success: function(object)&#123; var nodes = \"\"; //拼接simple格式的json字符串 $.each(object.data, function(i,item) &#123; nodes+=\"&#123;id:'\"+item.id+\"', pId:'\"+item.pid+\"', name:'\"+item.name+\"', isParent:'\"+item.isParent+\"'&#125;,\"; &#125;); var zNodes = \"[\"+nodes+\"]\"; var json = eval('(' + zNodes + ')'); //console.log(json); zTreeInit(json); &#125; &#125;); &#125; /* 初始化树 */ function zTreeInit(json) &#123; $.fn.zTree.init($(\"#treeDemo\"), setting, json); var zTree = $.fn.zTree.getZTreeObj(\"treeDemo\"); //全部展开 zTree.expandAll(true); //Y代表勾选时,N代表取消勾选 p代表父节点,s代表字节点 setting.check.chkboxType = &#123; \"Y\" : \"ps\", \"N\" : \"ps\" &#125;; &#125; java代码Controller层12345678910@RequestMapping(\"initTree\") @ResponseBody public DataMessage initTree(String setHzType,String payFreq,String fyType)&#123; params.put(\"setHzType\", setHzType); params.put(\"fyType\", fyType); params.put(\"fkmattr_xt\", fkmattr_xt); //获取treeinfo列表 List&lt;TreeInfo&gt; treeInfos = feeTransferService.initTree(params); return DataMessage.successData(treeInfos); &#125; tree实体类1234567public class TreeInfo &#123; private String id; private String pid; private String name; private String isParent; &#125; 说明更多实例可以参看zTree中文文档或参见zTree GitHub里面更多的示例和说明. 结语与君共勉!","categories":[{"name":"js","slug":"js","permalink":"http://blog.eumji025.com/categories/js/"}],"tags":[{"name":"zTree","slug":"zTree","permalink":"http://blog.eumji025.com/tags/zTree/"}]},{"title":"web开发常用注解","slug":"annotation","date":"2017-01-11T15:14:31.000Z","updated":"2017-02-26T02:32:51.210Z","comments":true,"path":"2017/01/11/annotation/","link":"","permalink":"http://blog.eumji025.com/2017/01/11/annotation/","excerpt":"","text":"简介概念 Annotation(注解)是JDK1.5及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。另外，你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。 分类①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 WEB开发中常用的注解Spring篇@Controller@Controller 定义控制器，映射页面URL的请求,只有被@Controller声明的类才会到对应类下找到对应@Requestmapping配置的URL 开启扫描@Controller注解需要在spring-mvc.xml中配置 1234&lt;!-- 扫描web相关的Bean 使用Annotation自动注册Bean,只扫描@Controller --&gt; &lt;context:component-scan base-package=\"com.jsu.controller\" use-default-filters=\"false\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!-- 子标签是用来添加扫描注解的 --&gt; &lt;/context:component-scan&gt; 简化配置版 1&lt;context:component-scan base-package=\"com.jsu.controller\"/&gt; ### @Requestmapping @RequestMapping 注解将类似 “/index”这样的URL映射到整个类或特定的处理方法上。类级别的注解映射特定的请求路径到表单控制器上，而方法级别的注解只是映射为一个特定的HTTP方法请求（“GET”，“POST”等）或HTTP请求参数。简而言之,公共的请求路径使用@RequestMapping放在类声明上,而特有的请求放在方法上,如下例: 12345678910111213141516@RequestMapping(\"/perm/permission\")public class PermissionController extends BaseController &#123; @Autowired private IPermissionService permissionService; @RequestMapping(\"/list\") public String list(Model model) &#123; return \"/permission/list\"; &#125; @RequestMapping(\"/getPermissionList\") @ResponseBody public String getPermissionList() &#123; Page&lt;Permission&gt; page = getPage(); return jsonPage(permissionService.selectPage(page, null)); &#125;&#125; @PathVariableURI 模版是一个类似于 URI 的字符串，其中包含了一个或多个变量。当你将这些变量替换掉市，就变回了 URI。 URI 模版格式 proposed RFC 定义了如何参数化 URI。比如，URI 模版 http://www.example.com/users/{userId}，包含了变量 userId，设置此变量为 __fred，就会变成http://www.example.com/users/fred。 可在方法入参上使用注解 @PathVariable 绑定 URI 的模版参数: 123456@RequestMapping(value=\"/owners/&#123;ownerId&#125;\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) &#123; Owner owner = ownerService.findOwner(ownerId); model.addAttribute(\"owner\", owner); return \"displayOwner\";&#125; @PathVariable 参数可以是任意的简单类型（如 int，long，Date 等），Spring 会自动将其进行类型转换，转换出错会抛出 TypeMismatchException. @RequestBody常用语接受前台请求的json格式数据,可以转化成对象接受. 12345@Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) &#123; // 实现省略&#125; @ResponseBody@ResponseBody 的使用类似于 @RequestBody。此注解用在方法上，用来表示直接将返回数据写到 HTTP 响应体里。注意，不是将数据放到 Model 中，或解析为视图名称。如下例: 12345@RequestMapping(value = \"/something\", method = RequestMethod.PUT)@ResponseBodypublic String helloWorld() &#123; return \"Hello World\";&#125; 常用于ajax请求. Bean自动装配 @Autowire@autowired是spring官方提供的一种装配方式。 ### ＠Resource @resource是java自带的一种装配方式。 两种方式的功能大致相同，默认推荐使用@Resource方式，这是j2ee原生的方式。能降低和spring的耦合度。 关于两种方式的详细介绍,参考:http://jsu.eumji025.top/2016/11/autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/ JPA实体类注解### @Entity 标注于实体类上，通常和@Table是结合使用的，代表是该类是实体类 @table标注在实体类上,表示该实体类对应数据库中的一张表 @Id 标注于属性上，通常是在get方法上，也可以在属性的声明上。用于表示该属性作为ID主键. @GeneratedValue123456789101112131415161718192021//源码@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface GeneratedValue &#123; /** * (Optional) The primary key generation strategy * that the persistence provider must use to * generate the annotated entity primary key. */ GenerationType strategy() default AUTO; //默认是AUTO /** * (Optional) The name of the primary key generator * to use as specified in the &#123;@link SequenceGenerator&#125; * or &#123;@link TableGenerator&#125; annotation. * &lt;p&gt; Defaults to the id generator supplied by persistence provider. */ String generator() default \"\";&#125; 123456789101112131415161718192021222324252627282930313233343536public enum GenerationType &#123; /** * Indicates that the persistence provider must assign * primary keys for the entity using an underlying * database table to ensure uniqueness. * 自增长 */ TABLE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database sequence. * 通过序列 */ SEQUENCE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database identity column. * 由数据库维护 */ IDENTITY, /** * Indicates that the persistence provider should pick an * appropriate strategy for the particular database. The * &lt;code&gt;AUTO&lt;/code&gt; generation strategy may expect a database * resource to exist, or it may attempt to create one. A vendor * may provide documentation on how to create such resources * in the event that it does not support schema generation * or cannot create the schema resource at runtime. 自动选择合适的方案分配 */ AUTO&#125; @Column标注于属性上，有很多功能，例如指定长度、是否为空，列名以及对应到数据库汇中的类型等,具体如下源码所示 12345678910111213141516@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface Column &#123; //设置对应数据库名 String name() default \"\"; //是否唯一 boolean unique() default false; //是否可以为空 boolean nullable() default true; //是否可以掺入 boolean insertable() default true; //设置长度 int precision() default 0; //精度 int scale() default 0;&#125; @OrderBy设置排序.ASC和DESC.默认ASC 12345678910111213@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface OrderBy &#123; /** * &lt;p&gt; If &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; is not specified, * &lt;code&gt;ASC&lt;/code&gt; (ascending order) is assumed. * * &lt;p&gt; If the ordering element is not specified, ordering by * the primary key of the associated entity is assumed. */ String value() default \"\";&#125; ### @ManyToMany&amp;&amp;@OneToMany 设置对应关系,多对多,一对多 @DateTimeFormat格式化时间,放在属性上 1234567891011121314151617181920@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)public @interface DateTimeFormat &#123; String style() default \"SS\"; DateTimeFormat.ISO iso() default DateTimeFormat.ISO.NONE; String pattern() default \"\"; public static enum ISO &#123; DATE, //日期 TIME, //时间 DATE_TIME, //时间+日期 NONE; //无 private ISO() &#123; &#125; &#125;&#125; ## Jackson注解 JsonProperty设置某个属性在转成json后的名称 1234public class Name &#123; @JsonProperty(\"sex\") public String t_sex; &#125; 转化成json格式后是这样的: 将会生成如下所示的JSON数据结果：{ “sex” : “man” } @JsonIgnoreProperties此注解是类注解，作用是json序列化时将Java bean中的一些属性忽略掉，序列化和反序列化都受影响. @JsonIgnore 此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。示例: 12345public class KeyValue &#123; public int value; @JsonIgnore public int key; &#125; 12转成json字符串后://将会忽略key&#123; &quot;value&quot; : 42 &#125; @JsonFormat此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，比如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”) @JsonSerialize 此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码. @JsonDeserialize 此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码. Mybatis注解### @Alias ＠Alias是mybatis中一个注解,类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。xml中通常这样配置. 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"com.eumji025.vo.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"com.eumji025.vo.Blog\"/&gt;&lt;/typeAliases&gt; 也可以在xml中直接指定包名如下: 123&lt;typeAliases&gt; &lt;package name=\"com.eumji025.vo\"/&gt;&lt;/typeAliases&gt; 每一个在包 com.eumji025.vo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。比如 com.eumji025.vo.Author 的别名为 author 如通过注解已经设置别名则按照注解的别名来使用: 1234@Alias(\"author\")public class Author &#123; ...&#125; 当然mybatis为了使用方便,已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。具体如下: 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 注后续继续补充","categories":[{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/tags/java/"},{"name":"annotation","slug":"annotation","permalink":"http://blog.eumji025.com/tags/annotation/"}]},{"title":"浅谈微信小程序","slug":"wechat-talk","date":"2017-01-09T15:10:39.000Z","updated":"2017-02-26T02:32:51.217Z","comments":true,"path":"2017/01/09/wechat-talk/","link":"","permalink":"http://blog.eumji025.com/2017/01/09/wechat-talk/","excerpt":"","text":"小程序定义微信小程序，简称CX，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 2017年1月9号正式上线. 几个试用过的小程序### 小程序示例 这是一个微信自己官方提供的demo. 主要介绍了微信小程序的组件.和接口. ### 携程酒店机票火车票 携程APP的缩水版,提供酒店,火车票,汽车票,飞机票的查询订购功能. 实习委员深圳地区的实习招聘和简历投递的软件,和其他招聘网站很类似, 西窗诗词一个将古诗词分类的小程序,可以根据关键词搜索,没事时候可以看看. 一起UP一个卡片传递的分享小程序,比较有意思. 浅谈优势1.使用优势,对于不常使用的应用来说,通过小程序能够减少用户的时间和手机空间的损耗,即开即用,用完就走. 2.对于开发人员来说,更专注与产品本身. 3.对于公司来说,随着小程序的潮流,更容易推广自己的APP,并减少开发成本. 不足 小程序所包含的内容有限,属于原生APP的阉割版.功能相对简单. 小程序还不够成熟,短期内肯定需要大量的维护和升级 暂时个人无法开发使用,而且需要内容审核. 不能模糊查询,也不能分享朋友圈(也许是腾讯有自己的看法) ​","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://blog.eumji025.com/tags/wechat/"}]},{"title":"展望2017","slug":"NewYear","date":"2017-01-01T01:38:34.000Z","updated":"2017-02-26T02:32:51.209Z","comments":true,"path":"2017/01/01/NewYear/","link":"","permalink":"http://blog.eumji025.com/2017/01/01/NewYear/","excerpt":"","text":"前言2016年已经成为历史,2017年已经来临,我们需要规划自己的2017年.让自己有更清晰的方向. 123在过去的2016年,感觉比较混乱.没有一个很好的规划.2017年,需要更加的有条理.2017年,需要更加的努力. 正题所要学习的技术 HTML5 Bootstrap Python redis spring boot dubbo 所要看的书籍 深入理解java虚拟机 java并发编程实战 effactive java 敏捷软件开发 重构,改善既有代码的设计 大型网站技术架构 所要做的事情 技术博文60篇 git commit 1000次 完成自己的第一个上线作品 如果可以,我希望有一把HHKB 尾声概括 新年需要奋斗,更需要目标. 不能浑浑噩噩,得过且过. 也不能因为生活的压力,失去自己的梦想. 相信自己,一定可以. 结语与君共勉","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"target","slug":"target","permalink":"http://blog.eumji025.com/tags/target/"}]},{"title":"2016自我总结","slug":"summary","date":"2016-12-24T07:17:32.000Z","updated":"2017-02-26T02:32:51.216Z","comments":true,"path":"2016/12/24/summary/","link":"","permalink":"http://blog.eumji025.com/2016/12/24/summary/","excerpt":"","text":"前言12在2016年里,个人学习了很多,也进步了很多,也失去了很多,也得到了很多.前路漫漫,且行且思. 基础篇书籍篇 java核心技术 卷1 java核心技术 卷2 (未看完) Think in java 第四版(未看完) 大话设计模式 java多线程编程核心技术 java并发编程的艺术(有难度未看完) 深入理解Java虚拟机:JVM高级特性与最佳实践(粗略的看一遍) Effective java (只看了10节) 重构:改善既代码的设计(看了2掌,没时间) 知识篇 hadoop(学习周期3个月,掌握基本理论知识,实现有待提升) core java(基础有比较大的提升) html(有比较明显的进步) linux(有很大的提升) javaScript(仍需努力,提升实际开发能力) php(小打小闹的玩了一周) python(小打小闹的玩了10天) 框架篇 spring(提升较大) mybatis(提升较大,编码能力有明显进步) struts2(未过多去研究) hibernate(仍需努力) ehcache(只会简单的使用) shiro(通过文档掌握了内部实现流程,使用待提升) 番外篇 2016年应该尝试过debian,ubuntu,centos,redhat,linux mint,manjaro,deepin(国产,还不错)等linux操作系统 2016年开始书写个人博客(以前都是写在为知笔记上) 2016年开始使用了hexo静态博客. 2016年也开始使用了google,stackoverflow,codeproject. 2016年开始关注掘金,简书,csdn,oschina,google+,segmentfault等. 2016年开通个人微信公众号. 2016年使用工具的改变 intellij idea 开发java webstorm 开发html atom 打酱油 FS Capture 截图 为知笔记 记录东西 typora markdown写作编辑器 IDM 下载 everything 查找文件 sublime text3 文本编辑 virtual box 虚拟机 potplayer 视频播放 eclipse 打酱油 android studio android开发 mysql+Navicat for mysql 数据库+可视化工具 chrome 浏览器+个人收藏夹 google keep 备忘录 UItraISO 操作系统镜像刻录 网易云音乐 听见好时光 小计追忆篇 大学从遥遥无期到转瞬即逝, 学习从一筹莫展到突飞猛进, 在2016年里, 虽然有很多的不足, 但还是有非常大的进步. 各方面的技术都有很大的提升, 各方面的见识也越来越广阔, 但是在各方面都还有很大的提升空间, 知识的深度上还有待进一步提升. 希望2017年的自己,能做得更好. 结语与君共勉!! ​ ​ ​","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"summary","slug":"summary","permalink":"http://blog.eumji025.com/tags/summary/"}]},{"title":"面试心得","slug":"interview","date":"2016-12-11T12:52:12.000Z","updated":"2017-02-26T02:32:51.211Z","comments":true,"path":"2016/12/11/interview/","link":"","permalink":"http://blog.eumji025.com/2016/12/11/interview/","excerpt":"","text":"谈一谈我的面试经历基本介绍 时间: 2016.11.28日开始 这是一个非常尴尬的时期.因为校招基本都结束了,当时自己也没准备校招.直接准备社招的. 状况1-3天 毫无收获,基本面试的都是些培训机构.偶尔有一两家想让你去转型做其他的实习工作. 第4天 迎来我第一次比较正规的面试. PS.不是想敷衍了事的公司.确实招人 这家公司也是我现在就职的公司.是一个创业公司. 当天我面试的表现并不好.因为第一次比较正规面试.问的问题和前面几天面试公司的难度不在一个档次.回答的不是很好.而且知识面很广. 第五天(周六) 还是去面试了.非常恼火的面试. 第一家说经理不在,直接叫我等笔试.然后就没有然后了. 第二家 做摄影相关的公司. 问了我怎么解决重复点击按钮的提交问题. 然后还问了如何实现10天内免登陆. 或许我回答的不够完善,也没有复试. 第六天(星期天放假) 总结了前几天面试的经验.转换投简历的地方. 大家应该都知道培训公司这么一说,深圳的培训公司都是有套路的.先是放出一些工资高要求低的岗位. 然后电话通知你面试.你问是不是要实习前先培训,他说他们有直招的,达到要求就能上岗. 你去过之后就给你说你没经历,公司不可能话大价钱去培养你的.花式让你培训. 第七天 参加一个复试. 依旧是技术面.这天主要问的是关于计算机网络相关问题.根本不知道怎么回答.其他的内容基本没什么新东西. 8-9天 由于个人情况,未参加面试 第十天 上午面试了一家公司.感觉还可以.面试官很和气.问了一些问题还指点了一下我.叫我等复试. 然后面试完,接到第四天哪家公司的offer.虽然周期很长,但是很开心,而且在我回答不是很好的情况下还选择了我.非常的开心. 中午时候,貌似是我上午面试的公司把我推荐给了另外一个公司.然后跟我滔滔不绝的通话半天,邀请我面试.时间问题一直没去. 下午的时候面试一家做电商网站的公司. 已经有了A或者B轮融资的公司,首先笔试,然后是第一个面试官.是一个非常好的面试官,由于几天经验的积累,觉得我很不错,但是他不推荐我留在公司(ps.他认为去大公司能学到更多的东西.也描述了他自己的经历.当年就是有家公司录用他他就直接去了.).他说,我的水平肯定能有机会留在公司,但还是希望找自己兴趣点的大公司实习. 第二轮是他们的经理.跟我较劲.一个劲的问个不停.然后一顿BB之后,他说去和人事谈一下,然后回来跟我说(你不是很优秀,我在你身上找不到闪光点.反正说了一大堆),最后介绍了一下薪资,然后说他还要再面几个人.叫我等通知. 这是我面试最久的一次,快三个小时.口干舌燥. 第11天 上午面了一家医疗类的科技公司.是经理面试我的.一个劲的问我内部实现原理.感受到了打击.还问了一些数据结构的问题. 虽然肯定过不了,也感受到了自己的很多问题.自己是真的菜. 下午面了一家物业公司.先有hr对公司做整体的介绍.随后进行笔试和技术面. 第一轮面试官比较和善.跟我谈笑风生.对我比较满意.问我的问题基本都回答的OK. 第二轮面试官是经理.也是个洒脱的人,问了一些基本情况,没有问什么职业规划.然后很干脆的叫我等通知. 下午面试的人大约有20来个,我题乱做的就是想早点面完回去.我面完的时候是4:30. 我也不知道他们要面到什么时候. 第一份实习 第一份实习的虽然和自己的目标有区别,但是公司还不错,非常上进有潜力的公司. 只工作了6天,主要是以为公司比较偏向只能硬件(嵌入式和单片机方面),安排我学的东西太杂了,感觉自己跟公司的发展方向不太一致,选择了离职. PS. 有嵌入式单片机学的不错或者对微信硬件或者微信公众号有深入了解的可以联系我(可以推荐).没有实力就算了,公司肯定是不招闲人的.创业的关键时期. 重新开始第一天 参加前面公司的复试 比较有缘分,非常感谢HR. 聊的主要是一些主观上的东西,和自己所学的知识没有太大必然的联系. 我觉得主要是看一个人的品质和一个人的可塑造型.目的就是了解更多生活上的东西. 第二天 慧点科技的实习生面试.(笔试+面试) 面试官非常的和蔼友善,做了一套题,非常基础非常细节.有部分我确实忘了.太久没有练习. 还有就是很多关于oracle数据的题(只会MySQL,按照MySQL的语法写的). 面试的时候主要介绍了公司要驻现场开发,经常出差.知识点问的不是太多.只是大概的了解一下. 应该是驻现场开发的要求跟我不太符合(不包吃住,还有可能在深圳各个地区进行现场开发,对我居住的地方不太友好). 第四天 点将众成的实习生(笔试+面试+面试) 先做了一套题,选择题(单选+多选)很多不是很会,考的偏向于实际运用. 简单题部分还好,有关数据库和前端优化问题不是很会.数据库也是关于oracle的. 第一轮面试,考察了基本的前端知识和linux知识.提及到SVN,maven. 第二轮面试也比较简单,主要是双方合作相关的事情.没太多技术交流. 总结成功都是建立在有准备之上的. 准备越充分成功几率越大. 选择好的招聘网站很重要. 实习推荐网站 拉钩网 实习僧 boss直聘 不推荐网站 智联 前程无忧 58同城 这些都是实习生的噩梦.太多培训机构,就算你没投简历,也会给你打电话叫面试.是最骚的.当然也不是绝对的没有招实习的公司,只是要找起来比较费时间和精力. 附录深圳培训机构名单 戳这里 个人面试题集 实现多线程的几种方式(3种) http请求方式(http://blog.sina.com.cn/s/blog_8211f08a0102ve2a.html) http特点 servlet中常用对象及主要方法 集合类部分(list set map都有考到) object类中常用方法 equals和hashcode 重载和重写的区别 向上转型和向下转型的区别 接口和抽象类的区别 接口回调的含义 工厂模式的介绍和优缺点 代理模式和动态代理的介绍 java的主要特征 java动态绑定原理 java动态代理的实现 创建线程的方式 线程的几种状态 线程中sleep方法和wait方法的区别 写一个死锁. 写一个方法展示当前文件夹的目录结构 抽象类和接口的区别 jdbc的创建步骤 开启一个事务的方法 事务的概念 谈一谈对回滚的理解 spring mvc的常用注解 spring mvc如何接受json格式数据 spring mvc工作流程 web项目文件加载步骤 spring的核心部分 spring的aop实现原理 spring ioc实现原理 spring 怎么管理事务 mybatis中#和$的却别 如何防止sql注入 mybatis的缓存机制 mybatis如何实现一对多映射 arraylist和linkedlist的实现原理和区别 hashmap,hashtable和hashset的区别 set是如何保证唯一的(内部实现机制) 如何用集合类实现queue String stringbuilder stringbuffer三者的区别(有可能问内部实现机制) 给一种设计模式让你介绍这个设计模式 基本数据类型和引用类型相关 jsp的九大内置对象 final finally finalize的区别 更深层次 或许会问类加载机制等java虚拟机相关的 或许会问一些前端的东西 或许会问多线程lock锁 或许会问并发 或许会问tomcat相关的知识点 或许会问数据库的优化问题 或许会问算法 或许会问操作系统 或许会问linux操作系统 收集的几篇面试文章 Java面试知识点总结 2016年未，腾讯，百度，华为，搜狗和滴滴面试题汇总 java面试题整理 不费洪荒之力JAVA面试成功_2016最新版 ava面试题总结从基础特性到MySQL数据库到多线程到框架 Java面试一定会遇到的56个面试题 前端开发面试题 PS 很多东西没来得及记录.个人的精力有限.欢迎补充,可以留言或者联系我(email: eumji025@gmail.com) 总之说明一个问题.我们需要把基础掌握的更加透彻.不仅要会用,更要懂实现原理. 不仅要用轮子,更要学会造轮子. 面试准备问题 尽早准备,最好参加8-10月的校招,不要只关注与本校的校招, 当然如果没抓住其他校招的机会,学校的校招也不要放弃,不管你想不想去,学习点经验总是好的. 最后社招的同学们也不要气馁,在面试中总结和成长.相信一定可以找到一份好工作的. 结语与君共勉!","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"interview","slug":"interview","permalink":"http://blog.eumji025.com/tags/interview/"}]},{"title":"Idea-Maven项目的创建和部署","slug":"Idea-Maven项目的创建和部署","date":"2016-11-21T12:12:40.000Z","updated":"2017-02-26T02:32:51.209Z","comments":true,"path":"2016/11/21/Idea-Maven项目的创建和部署/","link":"","permalink":"http://blog.eumji025.com/2016/11/21/Idea-Maven项目的创建和部署/","excerpt":"","text":"前言由于Intellij Idea创建项目方式和eclipse有一定的区别，所有maven项目也是一样。 目的学会使用idea创建和部署Maven项目。 过程创建空的项目 创建maven module1.点击+号创建 2.选择maven webapp 3输入groupId和ArtifactId 4.陪著maven相关信息。 5设置名字 完成。6.等待一段时间，maven自动加载web项目相关的配置7 修改pom文件注意添加packaging 8 修改项目配置 提示maven-tomcat插件配置 发布右键项目 run maven-maven-tomcat即可 结语与君共勉！","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://blog.eumji025.com/tags/idea/"}]},{"title":"springmvc-ajax-jquery 异步校验登录","slug":"springmvc-ajax-jquery-异步校验登录","date":"2016-11-21T11:40:12.000Z","updated":"2017-02-26T02:32:51.215Z","comments":true,"path":"2016/11/21/springmvc-ajax-jquery-异步校验登录/","link":"","permalink":"http://blog.eumji025.com/2016/11/21/springmvc-ajax-jquery-异步校验登录/","excerpt":"","text":"前言一直以来都是直接提交form跳转登录，但是存在一些问题就是当密码错误的时候，又得重新跳转回来。感觉不是很理想。故采用异步校验是比较稳妥的一种处理的方式。 具体过程jsp页面的编写关键性代码如下 1234567891011121314151617&lt;form name=\"subinfo\" class=\"form\" method=\"post\"&gt; &lt;div&gt; &lt;input type=\"text\" required=\"\" id=\"username\" name=\"username\" placeholder=\"username\" class=\"input input_user\"/&gt; &lt;/div&gt; &lt;div class=\"two\"&gt; &lt;input type=\"password\" required=\"\" id=\"password\" name=\"password\" placeholder=\"password\" class=\"input input_password\"/&gt; &lt;/div&gt; &lt;div class=\"error_mes\"&gt; &lt;span class=\"error-icon\"&gt;&lt;/span&gt; &lt;span class=\"error-message\"&gt;用户名或者密码错误，请重新输入&lt;/span&gt; &lt;/div&gt; &lt;button type=\"reset\" class=\"btn-login\" title=\"登录\" &gt;重置&lt;/button&gt; &lt;button type=\"button\" class=\"btn-login\" title=\"登录\" onclick=\"formSubmit()\"&gt;登录&lt;/button&gt;&lt;/form&gt; js代码1234567891011121314151617function formSubmit() &#123; $.ajax(&#123; data:\"username=\" + $(\"#username\").val().toString() + \"&amp;password=\" + $(\"#password\").val().toString()+ \"&amp;type=\" + statu, type:\"post\", url:\"/user/login.do\", success:function (response)&#123; if (response==\"false\") &#123; $(\".error_mes\").css(\"display\", \"block\"); return false; &#125; if (response==\"true\")&#123; window.location = \"index\"; return true; &#125; &#125; springmvc 代码12345678910111213141516 @RequestMapping(\"/user/login.do\") @ResponseBody public String toSearch(User user) &#123; System.out.println(user.getType()); boolean result = loginService.normalLogin(user); if (result)&#123; return \"true\"; &#125; return \"false\"; &#125; @RequestMapping(\"/index\") public String toIndex()&#123; return \"index\"; &#125;&#125; 提示更加纤细的验证过程不在叙述若有问题欢迎留言。 总结关键点在于对ajax异步校验的语法理解。 结语与君共勉！","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/tags/spring/"},{"name":"ajax","slug":"ajax","permalink":"http://blog.eumji025.com/tags/ajax/"}]},{"title":"@autowired和@Resource的区别","slug":"autowired和-Resource的区别","date":"2016-11-21T11:36:39.000Z","updated":"2017-02-26T02:32:51.210Z","comments":true,"path":"2016/11/21/autowired和-Resource的区别/","link":"","permalink":"http://blog.eumji025.com/2016/11/21/autowired和-Resource的区别/","excerpt":"","text":"前言关于注解和xml配置的官方回答 Are annotations better than XML for configuring Spring? The introduction of annotation-based configurations raised the question of whether this approach is ‘better’ than XML. The short answer is it depends. The long answer is that each approach has its pros and cons, and usually it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control. No matter the choice, Spring can accommodate both styles and even mix them together. It’s worth pointing out that through its JavaConfig option, Spring allows annotations to be used in a non-invasive way, without touching the target components source code and that in terms of tooling, all configuration styles are supported by the Spring Tool Suite. 两种注解的说明@autowired简介autowired是spring官方提供的一种装配方式。 使用方法1.使用在方法上: 123456789101112public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; 2.使用在字段上 12@Autowired private MovieCatalog movieCatalog; 说明autowired主要是用bytype的方式注入。 @Resource简介@resource是java自带的一种装配方式。 使用方法与@autowired相似1.指定name属性 1234@Resource(name=\"myMovieFinder\") public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; 2.默认[使用默认提供名称] 1234@Resource public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; 说明@Resource默认按名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。 总结两种方式的功能大致相同，默认推荐使用@Resource方式，这是j2ee生的方式。能降低和spring的耦合度。 更多具体详情请参见官方：http://spring.io 结语与君共勉！","categories":[{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/tags/java/"}]},{"title":"推荐的markdown编辑器","slug":"推荐的markdown编辑器","date":"2016-11-05T01:26:54.000Z","updated":"2017-02-26T02:32:51.217Z","comments":true,"path":"2016/11/05/推荐的markdown编辑器/","link":"","permalink":"http://blog.eumji025.com/2016/11/05/推荐的markdown编辑器/","excerpt":"","text":"介绍Typora是一款非常优雅的markdown编辑器 因为它将「写字」和「预览」合并，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。 一切都变得如此干净、纯粹。 官网 传送门： hexo官网 安装windows 下载地址 安装没有难度 linux sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys BA300B7755AFCFAE sudo add-apt-repository ‘deb https://typora.io ./linux/‘ sudo apt-get update sudo apt-get install typora mac 解压安装 功能介绍表格编辑其他的markdown表格编辑方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 十分复杂的操作有木有 Typora表格操作方式 CTRL+T快捷键直接生成 图片操作插入图片的语法 1![logo](http://typora.io/img/favicon-128.png) typora语法 CTRL+SHIFT+I 更简单的直接将图片拖拽进来即可。 目录大纲 Typora 还可以根据当前文档的标题层级，自动生成显示大纲， 点击软件左下角圆圈即可，就会出现字数统计和大纲预览。 圆圈旁边是切换视图按钮。 主题 ypora 默认提供了六套主题样式： Github风格、 默认主题 Gothic、 出版风格的 Newsprint、 夜间模式 Night、 Pixyll、 Whitey. 结语与君共勉！！！","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://blog.eumji025.com/tags/markdown/"},{"name":"写作","slug":"写作","permalink":"http://blog.eumji025.com/tags/写作/"}]},{"title":"ubuntu下hexo博客搭建","slug":"ubuntu下hexo博客搭建","date":"2016-11-04T13:22:19.000Z","updated":"2017-02-26T02:32:51.216Z","comments":true,"path":"2016/11/04/ubuntu下hexo博客搭建/","link":"","permalink":"http://blog.eumji025.com/2016/11/04/ubuntu下hexo博客搭建/","excerpt":"","text":"nodejs 安装apt方式安装 sudo apt-get install npm 解压安装 nodejs5.7 百度云地址 将下载的nodejs移动到/usr/local目录下 sudo tar xzvf node-v5.7.0-linux-x64.tar.gz -C /usr/local 配置环境变量 sudo vim /etc/profile 在文件末尾追加 export PATH=$PATH:/usr/local/nodejs/bin 此处的nodejs指代你解压的移动的那个目录 检验 source /etc/profile npm -v 结果： 3.6.0 安装hexo1.切换root用户，权限问题，使用root用户更加方便 su root 若未设置过root账户，如下操作 sudo passwd root 安装 npm install -g hexo-cli –registry=https://registry.npm.taobao.org hexo配置 mkdir hexo cd hexo hexo init hexo g hexo setver -p 4080 在浏览器中输入: http://localhost:4080 新建文章 hexo new “文章名” 默认文章是生成在resource/_post/目录下 编辑推荐使用markdown编辑器 vim也可以 标题的#和文字之间需要有一个空格 这是hexo的语法 不然不能正常显示标题 新建photo hexo new photo “名字” 其他说明 后续操作和windows下没有区别 参见中文文档： hexo文档 结语与君共勉！！！","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.eumji025.com/tags/hexo/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.eumji025.com/tags/ubuntu/"}]},{"title":"spring-IOC","slug":"spring-IOC","date":"2016-11-01T08:04:07.000Z","updated":"2017-02-26T02:32:51.214Z","comments":true,"path":"2016/11/01/spring-IOC/","link":"","permalink":"http://blog.eumji025.com/2016/11/01/spring-IOC/","excerpt":"","text":"前言 IoC也被称作 依赖注入 (DI)。它是一个处理对象依赖项的过程，也就是说，和他们一起工作的其他的对象，只有通过构造参数、工厂方法参数或者（属性注入）通过构造参数实例化或通过工厂方法返回对象后再设置属性。当创建bean后，IoC容器再将这些依赖项注入进去。这个过程基本上是反转的，因此得名 控制反转 （IoC）。 Spring IoC配置使用xml方式配置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"...\" class=\"...\"&gt; &lt;!-- 在这里写 bean 的配置和相关引用 --&gt; &lt;/bean&gt; &lt;bean id=\"...\" class=\"...\"&gt; &lt;!-- 在这里写 bean 的配置和相关引用 --&gt; &lt;/bean&gt; &lt;!-- 更多bean的定义写在这里 --&gt;&lt;/beans&gt; 使用注解方式 在spring配置文件中开启注解方式 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 使用spring注解@Autowired 123456public class EventsController &#123; @Autowired private EventsService eventsService; @Autowired private LevelService levelService;&#125; ​ 使用java注解@Resource 1234567public class EventsController &#123; @Resource private EventsService eventsService; @Resource private LevelService levelService;&#125; 实例化Spring提供了默认的ApplicationContext接口的实现。在独立的应用程序中，通常创建ClassPathXmlApplicationContext`或’FileSystemXmlApplicationContext’的实例。 12ApplicationContext context = new ClassPathXmlApplicationContext(new String(\"applicationContext.xml\")); web应用中，在web.xml中声明。 123456&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring/applicationContext-*.xml &lt;/param-value&gt; &lt;/context-param&gt; 使用123456789// 创建并配置beansApplicationContext context = new ClassPathXmlApplicationContext(new String(\"applicationContext.xml\"));// 取得配置的实例PetStoreService service = context.getBean(\"petStore\", PetStoreService.class);// 使用实例List&lt;String&gt; userList = service.getUsernameList(); 实例dao.class1234567891011121314151617181920212223242526public class UserDao &#123;private String name; private String password; public UserImpl(String name) &#123; super(); this.name = name; &#125; public UserImpl(String name, String password) &#123; super(); this.name = name; this.password = password; &#125; public String toString() &#123; return \"username=\"+name+\" password=\"+password; &#125; public void getUser() &#123; System.out.println(toString()); &#125;&#125; server.class12345678910111213public class UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void showService() &#123; userDao.getUser(); &#125;&#125; xml1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--采用有两个参数的构造方法--&gt; &lt;bean id=\"user\" class=\"com.jsu.dao.UserDao\"&gt; &lt;constructor-arg index=\"0\" value=\"zhangsan\"/&gt; &lt;constructor-arg index=\"1\" value=\"123\"/&gt; &lt;/bean&gt; &lt;bean id=\"service\" class=\"com.jsu.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"user\"/&gt; &lt;/bean&gt; &lt;!--配置别名--&gt; &lt;alias name=\"service\" alias=\"sc\"/&gt; &lt;!--id是唯一的 此时name 相当于别名 name 可用空格 逗号 分号 分割 假如没配置id 则获取直接获取name constructor-arg 当只有一个时候 直接输入value 当有多个时候需要用下标指定 --&gt; &lt;bean id=\"users\" name=\"user3\" class=\"com.jsu.dao.UserDao\"&gt; &lt;constructor-arg value=\"lisi\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试12345678910public class SpirngTest &#123; public static void main(String[] args) &#123; //解析xml文件 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //获取对象 UserService service = (UserService) context.getBean(\"service\"); service.showService(); &#125;&#125; 结果 username=zhangsan password=123 结语与君共勉！！","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/tags/spring/"}]},{"title":"shadowsocks","slug":"shadowsocks","date":"2016-11-01T07:22:49.000Z","updated":"2017-02-26T02:32:51.214Z","comments":true,"path":"2016/11/01/shadowsocks/","link":"","permalink":"http://blog.eumji025.com/2016/11/01/shadowsocks/","excerpt":"","text":"前言工欲善其事，必先利其器。 世界那么大，程序员必须去看看。google search，google communities，stack overflow，github(虽然国内网可以进，速度是有目共睹的) 更多的自己去挖掘，会有意外收获。 正题资源下载 传送门: shadowsocks download 配置 免费shadowsocks地址一个 传送门:iss_homepage 详细配置如下： 开启服务 测试 结语指路到此结束！！！ 与君共勉！！！","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://blog.eumji025.com/tags/shadowsocks/"},{"name":"vpn","slug":"vpn","permalink":"http://blog.eumji025.com/tags/vpn/"}]},{"title":"mybatis大于小于符号处理","slug":"mybatis大于小于符号处理","date":"2016-10-30T06:37:57.000Z","updated":"2017-02-26T02:32:51.212Z","comments":true,"path":"2016/10/30/mybatis大于小于符号处理/","link":"","permalink":"http://blog.eumji025.com/2016/10/30/mybatis大于小于符号处理/","excerpt":"","text":"问题在数据库操作中我们经常要进行比较，但是在使用mybatis时。 在xml文件中通常&gt;,&lt;等符号都会被转义，在有数字比较时候就会出现问题。 解决方式第一种​ 常规的解决方式，使用转义字符替换。 &amp;lt； &lt; 小于号 &amp;gt； &gt; 大于号 &amp;amp； &amp; 和 &amp;apos； ‘ 单引号 &amp;quot； “ 双引号 第二种通过使用防解析标记 &lt;![CDATA[ 具体内容写这里 ]]&gt; 结语与君共勉！","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://blog.eumji025.com/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://blog.eumji025.com/tags/mybatis/"}]},{"title":"ehcache初探","slug":"ehcache初探","date":"2016-10-30T04:07:05.000Z","updated":"2017-02-26T02:32:51.211Z","comments":true,"path":"2016/10/30/ehcache初探/","link":"","permalink":"http://blog.eumji025.com/2016/10/30/ehcache初探/","excerpt":"","text":"前言​ Ehcache是轻量级缓存框架，目的是为了减少应用程序对物理数据源访问的次数，从而提高应用程序的运行性能. 缓存设想内存是有限的，缓存的时效性也是有限的，所以可以设定内存数量的大小，可以执行失效算法 ，可以在内存满了的时候，按照最少访问等算法将缓存直接移除或切换到硬盘上。 正文ecache资源配置Ehcache 3 with clustering support ehcache3.0下载地址 Maven Snippet123456&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.1.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; ehcache配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://www.ehcache.org/ehcache.xsd\" updateCheck=\"false\" monitoring=\"autodetect\" dynamicConfig=\"true\"&gt; &lt;diskStore path=\"java.io.tmpdir\"/&gt;&lt;!-- name:缓存名称。 maxElementsInMemory：缓存最大个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。 仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。 仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 maxElementsOnDisk：硬盘最大缓存个数。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。 默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 --&gt; &lt;defaultCache name=\"defaultCache\" maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" overflowToDisk=\"false\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\" /&gt; &lt;cache name=\"testCache\" maxElementsInMemory=\"50000\" eternal=\"false\" timeToIdleSeconds=\"300\" timeToLiveSeconds=\"300\" overflowToDisk=\"false\" memoryStoreEvictionPolicy=\"LRU\" /&gt;&lt;/ehcache&gt; java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class EhcacheUtil &#123; public static CacheManager manager = CacheManager.create(); /** * 获取缓存 * @param cacheName 缓存名 * @param key 缓存的key * @return */ public static Object get(String cacheName,Object key)&#123; Cache cache = manager.getCache(cacheName); if (cache!=null)&#123; Element element = cache.get(key); if (element != null)&#123; return element.getObjectValue(); &#125; &#125; return null; &#125; /** * 设置缓存 * @param cacheName 缓存名 * @param key 缓存的key * @param value 缓存的值 */ public static void put(String cacheName,Object key,Object value)&#123; Cache cache = manager.getCache(cacheName); if (cache!=null)&#123; cache.put(new Element(key,value)); &#125; &#125; /** * 移除缓存 * @param cacheName * @param key * @return */ public static boolean remove(String cacheName,Object key)&#123; Cache cache = manager.getCache(cacheName); if (cache != null)&#123; cache.remove(key); return true; &#125; return false; &#125;&#125; 测试类1234567public static void main(String[] args) &#123; String key = \"key\"; String value = \"hello\"; EhcacheUtil.put(\"testCache\",key,value); System.out.println(EhcacheUtil.get(\"testCache\",key));&#125; 输出结果 hello 与web结合在spring配置文件中添加 123456789&lt;bean id=\"cacheManagerFactory\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\" p:configLocation=\"classpath:ehcache.xml\"&gt;&lt;/bean&gt;&lt;bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\" p:cacheManager-ref=\"cacheManagerFactory\"&gt;&lt;/bean&gt; 本人构建的是maven项目，ehcache在resource根目录下。 结语与君共勉！","categories":[{"name":"ehcache","slug":"ehcache","permalink":"http://blog.eumji025.com/categories/ehcache/"}],"tags":[{"name":"ehcache","slug":"ehcache","permalink":"http://blog.eumji025.com/tags/ehcache/"}]},{"title":" tomcat-虚拟目录配置","slug":"tomcat-虚拟目录配置","date":"2016-10-28T04:52:16.000Z","updated":"2017-02-26T02:32:51.216Z","comments":true,"path":"2016/10/28/tomcat-虚拟目录配置/","link":"","permalink":"http://blog.eumji025.com/2016/10/28/tomcat-虚拟目录配置/","excerpt":"","text":"前言tomcat是我们在web开发中非常重要的web服务器。tomcat虚拟目录则是为了映射相应的资源，通过虚拟目录的方式映射到实际的硬盘文件夹上。 配置默认配置地址默认配置文件tomcat安装文件夹下conf/server.xml 1234567891011&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt;&lt;/Host&gt; 第一种方式修改默认虚拟目录1234567891011//主要是修改webapps &lt;Host name=\"localhost\" appBase=\"E:/mywebapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;/Host&gt; 在webapps目录下新建ROOT文件夹【必须大写】在ROOT文件夹下新建WEB-INF文件夹【必须创建此文件夹 tomcat才能吧ROOT目录视为根目录】新建test.xml文件添加内容：我自定义的虚拟目录E:/mywebapps/ROOT/test.txt文件 测试访问：http://localhost:8080/test.txt 结果 第二种修改虚拟目录123456789&lt;Host name=\"localhost\" appBase=\"E:/mywebapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;Context path=\"/test\" docBase=\"E:/mywebapps\"&gt;&lt;/Context&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;/Host&gt; 新建webapps目录新建test.txt添加内容：我自定义的虚拟目录E:/mywebapps 测试访问：http://localhost:8080/test/test.txt 结果第三种通过修改端口号通过80端口 直接使用ip即可访问 12345678910111213141516171819202122232425262728293031323334353637&lt;Service name=\"Catalina2\"&gt; &lt;Connector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; &lt;Connector port=\"8010\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt; &lt;Engine name=\"Catalina\" defaultHost=\"www.engle.com\"&gt; &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\"/&gt; &lt;/Realm&gt; &lt;Host name=\"www.engle.com\" appBase=\"E:/mywebapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;Context path=\"/static/image\" docBase=\"E:\\pblog\\static\"&gt;&lt;/Context&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log.\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;/Host&gt; &lt;/Engine&gt;&lt;/Service&gt; 修改C:\\Windows\\System32\\drivers\\etc\\hosts添加：127.0.0.1 www.engle.com 测试地址：www.engle.com/test.txt 结果 说明通过设置了80端口 默认的ip即可访问。 结语tomcat是我们在部署web项目中最常用的工具。掌握好tomcat有助于我们开发。","categories":[{"name":"web服务器","slug":"web服务器","permalink":"http://blog.eumji025.com/categories/web服务器/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://blog.eumji025.com/tags/tomcat/"},{"name":"web","slug":"web","permalink":"http://blog.eumji025.com/tags/web/"}]},{"title":"mybatis使用数组批量删除","slug":"mybatis使用数组批量删除","date":"2016-10-28T04:49:11.000Z","updated":"2017-02-26T02:32:51.212Z","comments":true,"path":"2016/10/28/mybatis使用数组批量删除/","link":"","permalink":"http://blog.eumji025.com/2016/10/28/mybatis使用数组批量删除/","excerpt":"","text":"前言最近在使用mybatis做项目中，遇到了很多问题比如说：mybatis关联查询mybatis批量删除。今天就来说一说mybatis批量删除。 正文使用数组进行批量删除mapper.java 1int deletePhotoByArray(String[] photos); mapper.xml 123456&lt;delete id=\"deletePhotoByArray\" parameterType=\"java.lang.String\"&gt; DELETE FROM t_areaphoto WHERE Id in &lt;foreach collection=\"array\" item=\"id\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; 说明知道元素的属性使用数组删除需要用到mybatis的动态sql中的foreach，官方文档如下图所示： 我们很容易知道collection属性可以指代list，array,map.entrylist的方式和array方式一致，只需要修改collection的值即可 使用map删除mapper.java 12345//map的属性集Map&lt;String,String[]&gt; rooms = new HashMap&lt;String, String[]&gt;();roomsId.put(\"roomsId\",id);//mapper接口 int deleteRoomById(Map&lt;String, String[]&gt; rooms); mapper.xml123456&lt;delete id=\"deleteRoomById\" parameterType=\"map\"&gt; DELETE FROM t_room WHERE Id in &lt;foreach collection=\"roomsId\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/delete&gt; 说明和上述的数组差不多，只是此处的collection指的是map里面具体某一个key 结语如有问题欢迎留言和私信 与君共勉！","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://blog.eumji025.com/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://blog.eumji025.com/tags/mybatis/"},{"name":"数据库","slug":"数据库","permalink":"http://blog.eumji025.com/tags/数据库/"}]},{"title":"springMVC 几种页面跳转方式","slug":"springMVC-几种页面跳转方式","date":"2016-10-28T04:45:00.000Z","updated":"2017-02-26T02:32:51.215Z","comments":true,"path":"2016/10/28/springMVC-几种页面跳转方式/","link":"","permalink":"http://blog.eumji025.com/2016/10/28/springMVC-几种页面跳转方式/","excerpt":"","text":"前言前面已经了解了Controller的几种配置方式今天主要写一下响应界面跳转的几种方式 在注解的方式中通过HttpServletResponse的API直接输出（不需要配置渲染器）controller类的主要代码 12345678@Controllerpublic class RequestController&#123; @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.getWriter().println(\"hello HttpServletResponse\"); &#125; web.xml配置 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; dispatcher-servlet.xml主要代码 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--作用是扫描指定包下所有的包含注解的类--&gt; &lt;context:component-scan base-package=\"com.jsu.mvc\"/&gt;&lt;/beans&gt; 使用HttpServletResponse 重定向到另一个视图(其他不变 )1234567 @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.sendRedirect(\"index.jsp\"); &#125;&#125; 使用HttpServletRequest 转发（默认访问/下的index.jsp页面 不受渲染器的影响）12345@RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; req.setAttribute(\"message\",\"it's forword \"); req.getRequestDispatcher(\"index.jsp\").forward(req,resp); &#125; 直接返回jsp页面的名称（无渲染器）其他的配置不变 123456789@RequestMapping(\"/nice\") public String hello1()&#123;//转发方式1 return \"home.jsp\"; //转发方式2 return \"forward:index.jsp\"; //重定向方式 return \"redirect:index.jsp\"; &#125; 当有渲染器指定123456789@RequestMapping(\"/nice\") public String hello1()&#123; //转发方式1 return \"home\"; //转发方式2 return \"forward:index\"; //重定向方式 hello指的是requsrmapping return \"redirect:hello\"; &#125; 使用view使用modelandview需要视图解析器 能指定跳转页面 12345678910111213141516public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); //封装要显示到视图的数据 mv.addObject(\"msg\",\"hello myfirst mvc\"); //视图名 mv.setViewName(\"hello\"); return mv; &#125;&#125; [servlet-name]-servlet.xml 12345678910111213&lt;!--配置渲染器--&gt; &lt;!--配置hellocontroller中页面的位置--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--结果视图的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--结果视图的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; &lt;bean name=\"/hello.do\" class=\"com.jsu.mvc.HelloController\"&gt;&lt;/bean&gt; 使用modelview不需要视图解析器 不能指定跳转页面 12345678//通过modelmap方式 @RequestMapping(\"/modelmap\") public String modelHello(String name,ModelMap map)&#123; map.addAttribute(\"name\",name); System.out.println(name); return \"index.jsp\"; &#125; 结语与君共勉！","categories":[{"name":"spring MVC","slug":"spring-MVC","permalink":"http://blog.eumji025.com/categories/spring-MVC/"}],"tags":[{"name":"spring MVC","slug":"spring-MVC","permalink":"http://blog.eumji025.com/tags/spring-MVC/"}]},{"title":"使用idea开发srpingMVC第一个Demo","slug":"使用idea开发srpingMVC第一个Demo","date":"2016-10-28T04:24:48.000Z","updated":"2017-02-26T02:32:51.217Z","comments":true,"path":"2016/10/28/使用idea开发srpingMVC第一个Demo/","link":"","permalink":"http://blog.eumji025.com/2016/10/28/使用idea开发srpingMVC第一个Demo/","excerpt":"","text":"第一个springMVC例子主要目的是熟悉intellij的web项目操作和springMVC的基本概念 具体操作如下： 创建intellij idea web module 然后填写module名 点击确认 module创建完毕 在module的web-WEB-INF下新建 classes和lib文件夹 修改项目的配置点击file-&gt;Project Struture 修改Modules下的paths 修改完毕点击OK 配置tomcat 点击run-&gt;edit configurations点绿色的十字图标 创建tomcat并配置 首先配置web.xml123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;!--配置dispatcherservlet 以及mapping--&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置mvc-servelet12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;context:component-scan base-package=\"com.jsu.mvc\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;!--jsp文件夹需要自己手动创建--&gt; &lt;value&gt;/WEB-INF/jsp/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在jsp目录下新建hello.jsp123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello mvc&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg &#125;&lt;/body&gt;&lt;/html&gt; 在src中编写controller类12345678@Controllerpublic class HelloController &#123; @RequestMapping(value=\"/hello\",method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute(\"msg\", \"Spring 3 MVC Hello World\"); return \"hello\"; &#125;&#125; 测试 结语第一个小demo到此结束！ 与君共勉！","categories":[{"name":"spring MVC","slug":"spring-MVC","permalink":"http://blog.eumji025.com/categories/spring-MVC/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://blog.eumji025.com/tags/idea/"},{"name":"springMVC","slug":"springMVC","permalink":"http://blog.eumji025.com/tags/springMVC/"}]}]}