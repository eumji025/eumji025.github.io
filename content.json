{"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-01-01T08:52:14.476Z","updated":"2018-01-01T08:52:14.476Z","comments":false,"path":"/404.html","permalink":"http://blog.eumji025.com//404.html","excerpt":"","text":""},{"title":"About","date":"2017-12-31T16:08:16.299Z","updated":"2017-09-16T11:09:26.071Z","comments":false,"path":"about/index.html","permalink":"http://blog.eumji025.com/about/index.html","excerpt":"","text":"个人简介"},{"title":"Categories","date":"2017-12-31T16:08:16.379Z","updated":"2017-09-16T11:09:26.077Z","comments":false,"path":"categories/index.html","permalink":"http://blog.eumji025.com/categories/index.html","excerpt":"","text":""},{"title":"Books","date":"2017-12-31T16:08:16.343Z","updated":"2017-09-16T11:09:26.074Z","comments":false,"path":"books/index.html","permalink":"http://blog.eumji025.com/books/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-12-31T16:08:16.411Z","updated":"2017-09-16T11:09:26.081Z","comments":true,"path":"links/index.html","permalink":"http://blog.eumji025.com/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-31T16:08:16.163Z","updated":"2017-09-16T11:09:26.090Z","comments":false,"path":"tags/index.html","permalink":"http://blog.eumji025.com/tags/index.html","excerpt":"","text":""},{"title":"Repository","date":"2017-12-31T16:08:16.107Z","updated":"2017-09-16T11:09:26.085Z","comments":false,"path":"repository/index.html","permalink":"http://blog.eumji025.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"展望2018","slug":"2018-target","date":"2017-12-31T16:08:47.000Z","updated":"2017-12-31T16:19:09.144Z","comments":true,"path":"2018/01/01/2018-target/","link":"","permalink":"http://blog.eumji025.com/2018/01/01/2018-target/","excerpt":"","text":"总结2017 懵懵懂懂又一年,总的来说离目标还有一些距离. 展望2018 该做的事情还是得做 该看的书籍还是得看 该敲的代码还是得敲 该学的东西还是得学 基础目标1.go语言入门 2.docker入门 3.java虚拟机入门 4.spring 源码该读了 5.还是一个开源项目 6.技术类文章30篇(保质保量) 7.沉淀 结语新的一年,新的开始,也应该做一些新的尝试. 前路漫漫,且行且思.","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"target","slug":"target","permalink":"http://blog.eumji025.com/tags/target/"}]},{"title":"spring-boot跳转页面","slug":"springboot-indexPage","date":"2017-03-26T00:04:54.000Z","updated":"2017-03-26T00:40:31.212Z","comments":true,"path":"2017/03/26/springboot-indexPage/","link":"","permalink":"http://blog.eumji025.com/2017/03/26/springboot-indexPage/","excerpt":"","text":"前言 本篇博客记录spring boot如何跳转到静态首页.因为是初学的关系很多知识点都不懂,而且spring boot的项目没有webapp也没有配置文件.所以思考蛮久,经过查阅资料最终找到方法,做一次学习记录. Demo其实配置起来相对简单,只是一直没有找到配置的方法,翻看了官方文档,眼拙也没找到. 其实只需要在resources目录下新建static文件夹,并把html文件放在其中即可. 目录配置 Controller12345678@Controllerpublic class PageController &#123; @RequestMapping(\"indexPage\") public String indexPage()&#123; return \"index.html\"; &#125;&#125; 注: 在我暂时的尝试中,只能跳转一个页面,配多个也没用,可能是我自己学习的不够到位.后续学习中再做修改. 结果展示 结语与君共勉! BGM","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://blog.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-customport","slug":"spring-boot-customport","date":"2017-02-26T12:19:56.000Z","updated":"2017-02-26T12:36:21.704Z","comments":true,"path":"2017/02/26/spring-boot-customport/","link":"","permalink":"http://blog.eumji025.com/2017/02/26/spring-boot-customport/","excerpt":"","text":"Spring boot 自定义端口前言spring boot本身内置tomcat,我们不需要进行tomcat的配置,只需要引入tomcat的依赖即可. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt; 自定义端口1.spring boot中自定义端口需要入口类实现ConfigurableEmbeddedServletContainer接口.如下代码 1234567891011121314151617181920@RestController@EnableAutoConfigurationpublic class CustomPortController implements EmbeddedServletContainerCustomizer &#123; /** * 自定义端口 * @param container */ public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8888); &#125; @RequestMapping(\"/\") public String setPort()&#123; return \"自定义端口:8888\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(CustomPortController.class,args); &#125;&#125; 2.直接自定义ConfigurableEmbeddedServletContainer.通过自己注册TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory 12345678@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory(); factory.setPort(9000); factory.setSessionTimeout(10, TimeUnit.MINUTES); factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, \"/notfound.html\"); return factory;&#125; 结语长路漫漫,与君共勉!","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://blog.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-helloworld","slug":"spring-boot-helloworld","date":"2017-02-26T02:32:34.000Z","updated":"2017-02-26T02:57:36.123Z","comments":true,"path":"2017/02/26/spring-boot-helloworld/","link":"","permalink":"http://blog.eumji025.com/2017/02/26/spring-boot-helloworld/","excerpt":"","text":"Spring boot介绍 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 Spring boot 特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 Spring boot第一个demo说明本文采用maven方式构建项目.(maven学习地址) 开发环境 maven intellij idea java8 (推荐java7及以上版本) 构建项目第一个项目相对简单,我们不做过多的配置,只需要简单的引入spring-boot提供默认parent就可以了. 123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot.demo&lt;/groupId&gt; &lt;artifactId&gt;FirstDemo&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;FirstDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--内置tomcat和springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;FirstDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 代码编写123456789101112@RestController@EnableAutoConfigurationpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String helloWorld()&#123; return \"Hello world!\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldController.class,args); &#125;&#125; 注: 1.@RestController和@RequestMapping注解是springMVC的注解,分别用来注册controller类和映射对应地址的http请求. 2.@EnableAutoConfiguration注解,Spring Boot根据添加的jar依赖自动配置spring. 3.main方法通过调用run， 将业务委托给了Spring Boot的SpringApplication类。 SpringApplication将引导我们的应用， 启动Spring， 相应地启动被自动配置的Tomcat web服务器。 启动服务12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.4.1.RELEASE)2017-02-26 10:51:44.822 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Starting HelloWorldController on EumJi025 with PID 456 (E:\\workspace\\ideaWork\\Spring-boot\\FirstDemo\\target\\classes started by EumJi in E:\\workspace\\ideaWork\\Spring-boot)2017-02-26 10:51:44.833 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : No active profile set, falling back to default profiles: default2017-02-26 10:51:44.934 INFO 456 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:46.571 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-02-26 10:51:46.594 INFO 456 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-02-26 10:51:46.595 INFO 456 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.52017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1768 ms2017-02-26 10:51:46.813 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-02-26 10:51:47.044 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:47.099 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.springboot.demo.controller.HelloWorldController.helloWorld()2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.163 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.315 INFO 456 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-02-26 10:51:47.373 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-02-26 10:51:47.377 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Started HelloWorldController in 3.327 seconds (JVM running for 4.128) 测试 结语长路漫漫,与君共勉!","categories":[{"name":"spring","slug":"spring","permalink":"http://blog.eumji025.com/categories/spring/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://blog.eumji025.com/tags/spring-boot/"}]},{"title":"checksty配置","slug":"checkstyle","date":"2017-01-18T14:39:13.000Z","updated":"2017-02-26T02:32:51.210Z","comments":true,"path":"2017/01/18/checkstyle/","link":"","permalink":"http://blog.eumji025.com/2017/01/18/checkstyle/","excerpt":"","text":"配置文件由于checkstyle默认是使用google的开发规范,相对来说比较严格,因此采用自定义的规范.本文的配置文件来源于网络,后续将会进行改动. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\" \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\"&gt;&lt;module name=\"Checker\"&gt; &lt;!-- 消息提示等级 --&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;!-- 字符集限制 --&gt; &lt;property name=\"charset\" value=\"UTF-8\"/&gt; &lt;module name=\"TreeWalker\"&gt; &lt;!-- javadoc的检查 --&gt; &lt;!-- 检查所有的interface和class --&gt; &lt;module name=\"JavadocType\"/&gt; &lt;!-- 检查所有方法的javadoc，可以不声明RuntimeException --&gt; &lt;module name=\"JavadocMethod\"&gt; &lt;property name=\"allowUndeclaredRTE\" value=\"true\"/&gt; &lt;property name=\"allowMissingPropertyJavadoc\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 检查变量的javadoc --&gt; &lt;module name=\"JavadocVariable\"&gt; &lt;property name=\"scope\" value=\"public\"/&gt; &lt;/module&gt; &lt;!-- 命名方面的检查，它们都使用了Sun官方定的规则。 --&gt; &lt;!-- 类名(class 或interface) 的检查 --&gt; &lt;module name=\"TypeName\"/&gt; &lt;!-- 变量的检查 --&gt; &lt;module name=\"MemberName\"/&gt; &lt;!-- 方法名的检查 --&gt; &lt;module name=\"MethodName\"/&gt; &lt;!-- 方法的参数名 --&gt; &lt;module name=\"ParameterName \"/&gt; &lt;!-- 常量名的检查 --&gt; &lt;module name=\"ConstantName\"/&gt; &lt;!-- 长度方面的检查 --&gt; &lt;!-- 文件长度不超过1500行 --&gt; &lt;!-- 每行不超过120个字--&gt; &lt;module name=\"LineLength\"&gt; &lt;property name=\"max\" value=\"120\"/&gt; &lt;/module&gt; &lt;!-- 方法不超过30行 --&gt; &lt;module name=\"MethodLength\"&gt; &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt; &lt;property name=\"max\" value=\"30\"/&gt; &lt;/module&gt; &lt;!-- 方法的参数个数不超过3个。 --&gt; &lt;module name=\"ParameterNumber\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 多余的关键字 --&gt; &lt;module name=\"RedundantModifier\"/&gt; &lt;!-- 对区域的检查 --&gt; &lt;!-- 不能出现空白区域 --&gt; &lt;module name=\"EmptyBlock\"/&gt; &lt;!-- 所有区域都要使用大括号。 --&gt; &lt;module name=\"NeedBraces\"/&gt; &lt;!-- 多余的括号 --&gt; &lt;module name=\"AvoidNestedBlocks\"&gt; &lt;property name= \"allowInSwitchCase\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 编码方面的检查 --&gt; &lt;!-- 不许出现空语句 --&gt; &lt;module name=\"EmptyStatement\"/&gt; &lt;!-- 每个类都实现了equals()和hashCode() --&gt; &lt;module name=\"EqualsHashCode\"/&gt; &lt;!-- 不许使用switch --&gt; &lt;module name=\"IllegalToken\"&gt; &lt;property name=\"tokens\" value=\"LITERAL_SWITCH\"/&gt; &lt;/module&gt; &lt;!-- 不许内部赋值 --&gt; &lt;module name=\"InnerAssignment\"/&gt; &lt;!-- 绝对不能容忍魔法数 --&gt; &lt;module name=\"MagicNumber\"/&gt; &lt;!-- 循环控制变量不能被修改 --&gt; &lt;module name=\"ModifiedControlVariable\"/&gt; &lt;!-- 多余的throw --&gt; &lt;!-- &lt;module name=\"RedundantThrows\"/&gt; --&gt; &lt;!-- 不许使用未被简化的条件表达式 --&gt; &lt;module name=\"SimplifyBooleanExpression\"/&gt; &lt;!-- 不许使用未被简化的布尔返回值 --&gt; &lt;module name=\"SimplifyBooleanReturn\"/&gt; &lt;!-- String的比较不能用!= 和 == --&gt; &lt;module name=\"StringLiteralEquality\"/&gt; &lt;!-- if最多嵌套3层 --&gt; &lt;module name=\"NestedIfDepth\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- try最多被嵌套1层 --&gt; &lt;module name=\"NestedTryDepth\"/&gt; &lt;!-- clone方法必须调用了super.clone() --&gt; &lt;module name=\"SuperClone\"/&gt; &lt;!-- finalize 必须调用了super.finalize() --&gt; &lt;module name=\"SuperFinalize\"/&gt; &lt;!-- 不能catch java.lang.Exception --&gt; &lt;module name=\"IllegalCatch\"&gt; &lt;property name=\"illegalClassNames\" value=\"java.lang.Exception\"/&gt; &lt;/module&gt; &lt;!-- JUnitTestCase 的核心方法存在。 --&gt; &lt;!-- &lt;module name=\"JUnitTestCase\"/&gt; --&gt; &lt;!-- 一个方法中最多有3个return --&gt; &lt;module name=\"ReturnCount\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 不许对方法的参数赋值 --&gt; &lt;module name=\"ParameterAssignment\"/&gt; &lt;!-- 不许有同样内容的String --&gt; &lt;module name=\"MultipleStringLiterals\"/&gt; &lt;!-- 同一行不能有多个声明 --&gt; &lt;module name=\"MultipleVariableDeclarations\"/&gt; &lt;!-- 各种量度 --&gt; &lt;!-- 布尔表达式的复杂度，不超过3 --&gt; &lt;module name=\"BooleanExpressionComplexity\"/&gt; &lt;!-- 类数据的抽象耦合，不超过7 --&gt; &lt;module name=\"ClassDataAbstractionCoupling\"/&gt; &lt;!-- 类的分散复杂度，不超过20 --&gt; &lt;module name=\"ClassFanOutComplexity\"/&gt; &lt;!-- 函数的分支复杂度，不超过10 --&gt; &lt;module name=\"CyclomaticComplexity\"/&gt; &lt;!-- NPath复杂度，不超过200 --&gt; &lt;module name=\"NPathComplexity\"/&gt; &lt;!-- 杂项 --&gt; &lt;!-- 禁止使用System.out.println --&gt; &lt;!-- &lt;module name=\"GenericIllegalRegexp\"&gt; &lt;property name=\"format\" value=\"System\\.out\\.println\"/&gt; &lt;property name=\"ignoreComments\" value=\"true\"/&gt; &lt;/module&gt; --&gt; &lt;!-- 不许使用与代码同行的注释 --&gt; &lt;module name=\"TrailingComment\"/&gt; &lt;!-- 不允许存在todo标签 --&gt; &lt;module name=\"TodoComment\"&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;property name=\"format\" value=\"TODO\"/&gt; &lt;/module&gt; &lt;/module&gt; &lt;module name=\"FileLength\"&gt; &lt;property name=\"max\" value=\"1500\"/&gt; &lt;/module&gt; &lt;!-- 检查翻译文件 --&gt; &lt;module name=\"Translation\"/&gt;&lt;/module&gt; 注未完待续","categories":[{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/categories/java/"}],"tags":[{"name":"properties","slug":"properties","permalink":"http://blog.eumji025.com/tags/properties/"}]},{"title":"web开发常用注解","slug":"annotation","date":"2017-01-11T15:14:31.000Z","updated":"2017-02-26T02:32:51.210Z","comments":true,"path":"2017/01/11/annotation/","link":"","permalink":"http://blog.eumji025.com/2017/01/11/annotation/","excerpt":"","text":"简介概念 Annotation(注解)是JDK1.5及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。另外，你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。 分类①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 WEB开发中常用的注解Spring篇@Controller@Controller 定义控制器，映射页面URL的请求,只有被@Controller声明的类才会到对应类下找到对应@Requestmapping配置的URL 开启扫描@Controller注解需要在spring-mvc.xml中配置 1234&lt;!-- 扫描web相关的Bean 使用Annotation自动注册Bean,只扫描@Controller --&gt; &lt;context:component-scan base-package=\"com.jsu.controller\" use-default-filters=\"false\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!-- 子标签是用来添加扫描注解的 --&gt; &lt;/context:component-scan&gt; 简化配置版 1&lt;context:component-scan base-package=\"com.jsu.controller\"/&gt; ### @Requestmapping @RequestMapping 注解将类似 “/index”这样的URL映射到整个类或特定的处理方法上。类级别的注解映射特定的请求路径到表单控制器上，而方法级别的注解只是映射为一个特定的HTTP方法请求（“GET”，“POST”等）或HTTP请求参数。简而言之,公共的请求路径使用@RequestMapping放在类声明上,而特有的请求放在方法上,如下例: 12345678910111213141516@RequestMapping(\"/perm/permission\")public class PermissionController extends BaseController &#123; @Autowired private IPermissionService permissionService; @RequestMapping(\"/list\") public String list(Model model) &#123; return \"/permission/list\"; &#125; @RequestMapping(\"/getPermissionList\") @ResponseBody public String getPermissionList() &#123; Page&lt;Permission&gt; page = getPage(); return jsonPage(permissionService.selectPage(page, null)); &#125;&#125; @PathVariableURI 模版是一个类似于 URI 的字符串，其中包含了一个或多个变量。当你将这些变量替换掉市，就变回了 URI。 URI 模版格式 proposed RFC 定义了如何参数化 URI。比如，URI 模版 http://www.example.com/users/{userId}，包含了变量 userId，设置此变量为 __fred，就会变成http://www.example.com/users/fred。 可在方法入参上使用注解 @PathVariable 绑定 URI 的模版参数: 123456@RequestMapping(value=\"/owners/&#123;ownerId&#125;\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) &#123; Owner owner = ownerService.findOwner(ownerId); model.addAttribute(\"owner\", owner); return \"displayOwner\";&#125; @PathVariable 参数可以是任意的简单类型（如 int，long，Date 等），Spring 会自动将其进行类型转换，转换出错会抛出 TypeMismatchException. @RequestBody常用语接受前台请求的json格式数据,可以转化成对象接受. 12345@Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) &#123; // 实现省略&#125; @ResponseBody@ResponseBody 的使用类似于 @RequestBody。此注解用在方法上，用来表示直接将返回数据写到 HTTP 响应体里。注意，不是将数据放到 Model 中，或解析为视图名称。如下例: 12345@RequestMapping(value = \"/something\", method = RequestMethod.PUT)@ResponseBodypublic String helloWorld() &#123; return \"Hello World\";&#125; 常用于ajax请求. Bean自动装配 @Autowire@autowired是spring官方提供的一种装配方式。 ### ＠Resource @resource是java自带的一种装配方式。 两种方式的功能大致相同，默认推荐使用@Resource方式，这是j2ee原生的方式。能降低和spring的耦合度。 关于两种方式的详细介绍,参考:http://jsu.eumji025.top/2016/11/autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/ JPA实体类注解### @Entity 标注于实体类上，通常和@Table是结合使用的，代表是该类是实体类 @table标注在实体类上,表示该实体类对应数据库中的一张表 @Id 标注于属性上，通常是在get方法上，也可以在属性的声明上。用于表示该属性作为ID主键. @GeneratedValue123456789101112131415161718192021//源码@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface GeneratedValue &#123; /** * (Optional) The primary key generation strategy * that the persistence provider must use to * generate the annotated entity primary key. */ GenerationType strategy() default AUTO; //默认是AUTO /** * (Optional) The name of the primary key generator * to use as specified in the &#123;@link SequenceGenerator&#125; * or &#123;@link TableGenerator&#125; annotation. * &lt;p&gt; Defaults to the id generator supplied by persistence provider. */ String generator() default \"\";&#125; 123456789101112131415161718192021222324252627282930313233343536public enum GenerationType &#123; /** * Indicates that the persistence provider must assign * primary keys for the entity using an underlying * database table to ensure uniqueness. * 自增长 */ TABLE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database sequence. * 通过序列 */ SEQUENCE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database identity column. * 由数据库维护 */ IDENTITY, /** * Indicates that the persistence provider should pick an * appropriate strategy for the particular database. The * &lt;code&gt;AUTO&lt;/code&gt; generation strategy may expect a database * resource to exist, or it may attempt to create one. A vendor * may provide documentation on how to create such resources * in the event that it does not support schema generation * or cannot create the schema resource at runtime. 自动选择合适的方案分配 */ AUTO&#125; @Column标注于属性上，有很多功能，例如指定长度、是否为空，列名以及对应到数据库汇中的类型等,具体如下源码所示 12345678910111213141516@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface Column &#123; //设置对应数据库名 String name() default \"\"; //是否唯一 boolean unique() default false; //是否可以为空 boolean nullable() default true; //是否可以掺入 boolean insertable() default true; //设置长度 int precision() default 0; //精度 int scale() default 0;&#125; @OrderBy设置排序.ASC和DESC.默认ASC 12345678910111213@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface OrderBy &#123; /** * &lt;p&gt; If &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; is not specified, * &lt;code&gt;ASC&lt;/code&gt; (ascending order) is assumed. * * &lt;p&gt; If the ordering element is not specified, ordering by * the primary key of the associated entity is assumed. */ String value() default \"\";&#125; ### @ManyToMany&amp;&amp;@OneToMany 设置对应关系,多对多,一对多 @DateTimeFormat格式化时间,放在属性上 1234567891011121314151617181920@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)public @interface DateTimeFormat &#123; String style() default \"SS\"; DateTimeFormat.ISO iso() default DateTimeFormat.ISO.NONE; String pattern() default \"\"; public static enum ISO &#123; DATE, //日期 TIME, //时间 DATE_TIME, //时间+日期 NONE; //无 private ISO() &#123; &#125; &#125;&#125; ## Jackson注解 JsonProperty设置某个属性在转成json后的名称 1234public class Name &#123; @JsonProperty(\"sex\") public String t_sex; &#125; 转化成json格式后是这样的: 将会生成如下所示的JSON数据结果：{ “sex” : “man” } @JsonIgnoreProperties此注解是类注解，作用是json序列化时将Java bean中的一些属性忽略掉，序列化和反序列化都受影响. @JsonIgnore 此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。示例: 12345public class KeyValue &#123; public int value; @JsonIgnore public int key; &#125; 12转成json字符串后://将会忽略key&#123; &quot;value&quot; : 42 &#125; @JsonFormat此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，比如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”) @JsonSerialize 此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码. @JsonDeserialize 此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码. Mybatis注解### @Alias ＠Alias是mybatis中一个注解,类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。xml中通常这样配置. 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"com.eumji025.vo.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"com.eumji025.vo.Blog\"/&gt;&lt;/typeAliases&gt; 也可以在xml中直接指定包名如下: 123&lt;typeAliases&gt; &lt;package name=\"com.eumji025.vo\"/&gt;&lt;/typeAliases&gt; 每一个在包 com.eumji025.vo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。比如 com.eumji025.vo.Author 的别名为 author 如通过注解已经设置别名则按照注解的别名来使用: 1234@Alias(\"author\")public class Author &#123; ...&#125; 当然mybatis为了使用方便,已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。具体如下: 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 注后续继续补充","categories":[{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/categories/java/"}],"tags":[{"name":"annotation","slug":"annotation","permalink":"http://blog.eumji025.com/tags/annotation/"},{"name":"java","slug":"java","permalink":"http://blog.eumji025.com/tags/java/"}]},{"title":"Idea-Maven项目的创建和部署","slug":"Idea-Maven项目的创建和部署","date":"2016-11-21T12:12:40.000Z","updated":"2018-01-01T09:01:56.947Z","comments":true,"path":"2016/11/21/Idea-Maven项目的创建和部署/","link":"","permalink":"http://blog.eumji025.com/2016/11/21/Idea-Maven项目的创建和部署/","excerpt":"","text":"前言由于Intellij Idea创建项目方式和eclipse有一定的区别，所有maven项目也是一样。 目的学会使用idea创建和部署Maven项目。 过程创建空的项目 创建maven module1.点击+号创建 2.选择maven webapp 3输入groupId和ArtifactId 4.陪著maven相关信息。 5设置名字 完成。6.等待一段时间，maven自动加载web项目相关的配置7 修改pom文件注意添加packaging 8 修改项目配置 提示maven-tomcat插件配置 发布右键项目 run maven-maven-tomcat即可 结语与君共勉！","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://blog.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://blog.eumji025.com/tags/Intellij-Idea/"}]},{"title":"推荐的markdown编辑器","slug":"推荐的markdown编辑器","date":"2016-11-05T01:26:54.000Z","updated":"2017-02-26T02:32:51.217Z","comments":true,"path":"2016/11/05/推荐的markdown编辑器/","link":"","permalink":"http://blog.eumji025.com/2016/11/05/推荐的markdown编辑器/","excerpt":"","text":"介绍Typora是一款非常优雅的markdown编辑器 因为它将「写字」和「预览」合并，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。 一切都变得如此干净、纯粹。 官网 传送门： hexo官网 安装windows 下载地址 安装没有难度 linux sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys BA300B7755AFCFAE sudo add-apt-repository ‘deb https://typora.io ./linux/‘ sudo apt-get update sudo apt-get install typora mac 解压安装 功能介绍表格编辑其他的markdown表格编辑方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 十分复杂的操作有木有 Typora表格操作方式 CTRL+T快捷键直接生成 图片操作插入图片的语法 1![logo](http://typora.io/img/favicon-128.png) typora语法 CTRL+SHIFT+I 更简单的直接将图片拖拽进来即可。 目录大纲 Typora 还可以根据当前文档的标题层级，自动生成显示大纲， 点击软件左下角圆圈即可，就会出现字数统计和大纲预览。 圆圈旁边是切换视图按钮。 主题 ypora 默认提供了六套主题样式： Github风格、 默认主题 Gothic、 出版风格的 Newsprint、 夜间模式 Night、 Pixyll、 Whitey. 结语与君共勉！！！","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.eumji025.com/categories/其他/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://blog.eumji025.com/tags/markdown/"},{"name":"写作","slug":"写作","permalink":"http://blog.eumji025.com/tags/写作/"}]},{"title":"springMVC 几种页面跳转方式","slug":"springMVC-几种页面跳转方式","date":"2016-10-28T04:45:00.000Z","updated":"2017-02-26T02:32:51.215Z","comments":true,"path":"2016/10/28/springMVC-几种页面跳转方式/","link":"","permalink":"http://blog.eumji025.com/2016/10/28/springMVC-几种页面跳转方式/","excerpt":"","text":"前言前面已经了解了Controller的几种配置方式今天主要写一下响应界面跳转的几种方式 在注解的方式中通过HttpServletResponse的API直接输出（不需要配置渲染器）controller类的主要代码 12345678@Controllerpublic class RequestController&#123; @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.getWriter().println(\"hello HttpServletResponse\"); &#125; web.xml配置 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; dispatcher-servlet.xml主要代码 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--作用是扫描指定包下所有的包含注解的类--&gt; &lt;context:component-scan base-package=\"com.jsu.mvc\"/&gt;&lt;/beans&gt; 使用HttpServletResponse 重定向到另一个视图(其他不变 )1234567 @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.sendRedirect(\"index.jsp\"); &#125;&#125; 使用HttpServletRequest 转发（默认访问/下的index.jsp页面 不受渲染器的影响）12345@RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; req.setAttribute(\"message\",\"it's forword \"); req.getRequestDispatcher(\"index.jsp\").forward(req,resp); &#125; 直接返回jsp页面的名称（无渲染器）其他的配置不变 123456789@RequestMapping(\"/nice\") public String hello1()&#123;//转发方式1 return \"home.jsp\"; //转发方式2 return \"forward:index.jsp\"; //重定向方式 return \"redirect:index.jsp\"; &#125; 当有渲染器指定123456789@RequestMapping(\"/nice\") public String hello1()&#123; //转发方式1 return \"home\"; //转发方式2 return \"forward:index\"; //重定向方式 hello指的是requsrmapping return \"redirect:hello\"; &#125; 使用view使用modelandview需要视图解析器 能指定跳转页面 12345678910111213141516public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); //封装要显示到视图的数据 mv.addObject(\"msg\",\"hello myfirst mvc\"); //视图名 mv.setViewName(\"hello\"); return mv; &#125;&#125; [servlet-name]-servlet.xml 12345678910111213&lt;!--配置渲染器--&gt; &lt;!--配置hellocontroller中页面的位置--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--结果视图的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--结果视图的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; &lt;bean name=\"/hello.do\" class=\"com.jsu.mvc.HelloController\"&gt;&lt;/bean&gt; 使用modelview不需要视图解析器 不能指定跳转页面 12345678//通过modelmap方式 @RequestMapping(\"/modelmap\") public String modelHello(String name,ModelMap map)&#123; map.addAttribute(\"name\",name); System.out.println(name); return \"index.jsp\"; &#125; 结语与君共勉！","categories":[{"name":"spring MVC","slug":"spring-MVC","permalink":"http://blog.eumji025.com/categories/spring-MVC/"}],"tags":[{"name":"spring MVC","slug":"spring-MVC","permalink":"http://blog.eumji025.com/tags/spring-MVC/"}]},{"title":"使用idea开发srpingMVC第一个Demo","slug":"使用idea开发srpingMVC第一个Demo","date":"2016-10-28T04:24:48.000Z","updated":"2018-01-01T09:18:37.171Z","comments":true,"path":"2016/10/28/使用idea开发srpingMVC第一个Demo/","link":"","permalink":"http://blog.eumji025.com/2016/10/28/使用idea开发srpingMVC第一个Demo/","excerpt":"","text":"#主要目的是熟悉intellij的web项目操作和springMVC的基本概念,纯属个人学习的笔记,有写的不当的地方欢迎指正 ###操作环境说明操作系统： win10ide版本： 2017.1.5 开发过程本文原始的版本是在个人学习写的，所以很多东西写的不够详细。本次重新归纳总结，下面开始具体操作： 创建项目创建一个empty projectFile -&gt; new -&gt; project -&gt; empty project ###创建module说明一下，在实际开发中我们喜欢一个项目一个project，但是学习之中，为了方便来回切换，所以我们每一个demo都写成module的形式。 创建 module(在此之前需要创建entity project)在新版本中，会提示你是下载勾选的mvc的依赖。 然后填写module名 点击确认 module创建完毕（作者因为乱码的关系 ￥代表 /） 结构预览并修改配置在module的web-WEB-INF下新建 classes和lib文件夹（新版本中的lib在根目录下） 1.IDEA默认是不会像eclipse那样在web-inf下生成lib文件夹和classes文件夹的的，需要我们手动的创建，并将我们根目录下的lib目录下的内容复制到web-inf/lib文件夹内。并且还需要进行额外配置。 点击file-&gt;Project Struture 修改Modules下的paths 修改完毕点击OK（主要是为了跟ecilpse结构相似，也可以不改） 2.然后点击dependencis - &gt; 绿色的+ -&gt; 选择第一项，选择刚才我们在WEB-INF下创建的lib文件夹，和eclipse的导包一个性质。 3.回到主界面，配置tomcat 点击run-&gt;edit configurations‘点绿色的十字图标 创建tomcat并配置 选择自己的tomcat位置点击deployment -&gt; 绿色+号 -&gt; 选择我们的项目 代码编写 web,xml 不需要进行修改，有默认的就行了。 修改dispatcjer-servlet.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--对应src下的报名，需要自己新建--&gt; &lt;context:component-scan base-package=\"com.eumji.mvc\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;!--jsp文件夹需要自己手动创建--&gt; &lt;value&gt;/WEB-INF/jsp/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.在jsp目录下新建hello.jsp123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello mvc&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg &#125;&lt;/body&gt;&lt;/html&gt; 4.在src中编写controller类需要和dispatcher-servlet.xml配置的路径一致12345678@Controllerpublic class HelloController &#123; @RequestMapping(value=&quot;/hello&quot;,method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute(&quot;msg&quot;, &quot;Spring 3 MVC Hello World&quot;); return &quot;hello&quot;; &#125;&#125; 5.点击右上角的绿色三角形进行运行，最后进行测试 第一个小demo到此结束！ 最后说几句Intellij IDEA和eclipse的使用有很大的不同，本文只是带领着使用IDEA进行web项目的创建和测试。并没有对spring MVC框架本身的内容进行过多的讲解。IDEA创建普通的web 项目确实比较麻烦，使用maven的方式更佳。 补充还是补充一下创建maven项目的姿势 创建maven module 1.点击+号创建 2.选择maven webapp3输入groupId和ArtifactId4.陪著maven相关信息。最好是设置一下maven的setting文件,无论是自带的还是自己配置的maven,修改一下maven的镜像地址.在maven的settings.xml 文件里配置mirrors的子节点，添加如下mirror &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 5.文件夹名称,创建完成.6.加载 等待一段时间，maven自动加载web项目相关的配置 7 .修改pom文件注意添加packaging8 修改项目配置 maven-tomcat插件配置 发布右键项目 run maven-maven-tomcat即可 spring boot特别推荐一下使用spring boot,对新手非常友好,而且可以使用spring initialize生成项目,并且不需要配置tomcat. 源码地址https://github.com/eumji025/my-demo/tree/master/hello-mvc","categories":[{"name":"spring MVC","slug":"spring-MVC","permalink":"http://blog.eumji025.com/categories/spring-MVC/"}],"tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://blog.eumji025.com/tags/springMVC/"},{"name":"idea","slug":"idea","permalink":"http://blog.eumji025.com/tags/idea/"}]}]}