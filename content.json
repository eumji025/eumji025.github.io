{"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-01-01T08:52:14.476Z","updated":"2018-01-01T08:52:14.476Z","comments":false,"path":"/404.html","permalink":"http://www.eumji025.com//404.html","excerpt":"","text":""},{"title":"About","date":"2017-12-31T16:08:16.299Z","updated":"2017-09-16T11:09:26.071Z","comments":false,"path":"about/index.html","permalink":"http://www.eumji025.com/about/index.html","excerpt":"","text":"个人简介"},{"title":"Books","date":"2017-12-31T16:08:16.343Z","updated":"2017-09-16T11:09:26.074Z","comments":false,"path":"books/index.html","permalink":"http://www.eumji025.com/books/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-12-31T16:08:16.379Z","updated":"2017-09-16T11:09:26.077Z","comments":false,"path":"categories/index.html","permalink":"http://www.eumji025.com/categories/index.html","excerpt":"","text":""},{"title":"Links","date":"2017-12-31T16:08:16.411Z","updated":"2017-09-16T11:09:26.081Z","comments":true,"path":"links/index.html","permalink":"http://www.eumji025.com/links/index.html","excerpt":"","text":""},{"title":"Repository","date":"2017-12-31T16:08:16.107Z","updated":"2017-09-16T11:09:26.085Z","comments":false,"path":"repository/index.html","permalink":"http://www.eumji025.com/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-31T16:08:16.163Z","updated":"2017-09-16T11:09:26.090Z","comments":false,"path":"tags/index.html","permalink":"http://www.eumji025.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"动态代理及Proxy源码分析","slug":"dynamic-proxy","date":"2018-01-02T03:23:46.000Z","updated":"2018-01-04T12:40:21.614Z","comments":true,"path":"2018/01/02/dynamic-proxy/","link":"","permalink":"http://www.eumji025.com/2018/01/02/dynamic-proxy/","excerpt":"","text":"前言 代理是java中非常重要的一种设计模式,动态代理则可以认为是一种动态代理的最佳实践,本文将由浅及深的介绍动态代理及其proxy源码分析,文章写的不一定都对,请各位看官带着批判的态度阅读此文章. 代理模式是设计模式中的一种,而且在实际的开发中使用的频率非常高 ,比如spring AOP,mybatis代理都是我们经常使用的. 代理模式的定义: 当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。 静态代理从上面的介绍中可以看出代理模式其实本意是为了解决访问存在困难或者为了保证透明性的一种工具,有点类似于我们无法访问google,需要一个中间代理商的帮助是一致的.下面通过一个简单的例子来介绍: 12345678910111213141516171819202122232425262728293031323334353637383940public class ProxyDemo &#123; static interface BaseUser&#123; void info(); void real(); &#125; static class ProxyUser implements BaseUser&#123; BaseUser baseUser; public ProxyUser(BaseUser baseUser) &#123; this.baseUser = baseUser; &#125; public void info() &#123; System.out.println(\"I'm Proxy,I can help you\"); &#125; public void real() &#123; System.out.println(\"I will help you visit google\"); baseUser.real(); System.out.println(\"I had help you visit google\"); &#125; &#125; static class TargetUser implements BaseUser&#123; public void info() &#123; System.out.println(\"I'm google,what you what do?\"); &#125; public void real() &#123; System.out.println(\"I.m google,this is searched info\"); &#125; &#125; public static void main(String[] args) &#123; BaseUser targetUser = new TargetUser(); BaseUser proxyUser = new ProxyUser(targetUser); proxyUser.info(); proxyUser.real(); &#125;&#125; 在这里我们也可以认为代理者是两者访问或者交互的载体,需要对双方都非常的熟悉,才能帮你做具体的事,就像如果我现在需要代购,可能就需要找新的代理人!!! 这里也就是我们所说的静态代理 虽然静态代理也能帮我实现一些功能,但是只能说不够强大,此时我们就可以使用动态代理来帮我们更加灵活的去搞事情 动态代理动态代理的优势：1. 降低各个功能模块之间的耦合度，提高开发的效率和方便程序的维护度。 2. 减少代码量。 3. 不关注目标的具体实现。 动态代理的实现JDK动态代理 jdk自带的动态代理主要是通过实现InvocationHandler InvocationHandler的主要方法 Object invoke(Object proxy, Method method,Object[] args)throws Throwable 在代理实例上处理方法调用并返回结果。在与方法关联的代理实例上调用方法时，将在调用处理程序上调用此方法。即调用真实业务的方法都会进入到此invoke方法,至于为什么,稍后再说明 方法详细介绍 参数：proxy - 调用方法的代理实例对象 method - 代理实例对象调用的接口方法的 Method 实例对象。 Method-指代具体被代理的方法。 args -包含传入代理实例上方法调用的参数，如果接口方法不使用参数，则为 null。 return：从代理实例的方法调用返回的值。 throws： Throwable - 从代理实例上的方法调用抛出的异常。 ​ 案例本案例演示的是最常用的拦截方法然后记录日志的功能。 3.1 业务接口 123public interface Base &#123; public void hello(String name);&#125; 3.2 业务实现类 LoginImpl 123456public class LoginImpl implements Base&#123; @Override public void hello(String name) &#123; System.out.println(&quot;welcome &quot;+name+&quot;, success !!1&quot;); &#125;&#125; 3.3 代理类 LoginProxy 123456789101112131415161718192021222324252627282930313233343536373839404142class DynamicProxy implements InvocationHandler &#123; Object originalObj; Object bind(Object originalObj) &#123; this.originalObj = originalObj; return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this); &#125; /** * 切入点 对所有对象的方法都进行调用 * method.invoke方法对应代理对象调用login方法 * @param proxy 代理对象 * @param method 代理对象的方法 * @param args 代理对象调用接口方法的参数值 * @return 代理对象调用方法的返回值 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object invoke = method.invoke(originalObj, args); if (invoke != null)&#123; result(invoke); &#125; after(); return invoke; &#125; private void before() &#123; System.out.println(&quot;方法执行之前&quot;); &#125; private void after() &#123; System.out.println(&quot;方法执行之后&quot;); &#125; private void result(Object o) &#123; o.toString(); &#125;&#125; 3.4 测试类 LoginClient 1234567public class LoginClient &#123; public static void main(String[] args) &#123; //用于生成代理文件 //System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;); Base hello = (Base) new DynamicProxy().bind(new LoginImpl()); hello.hello(&quot;zhangsan&quot;); &#125;&#125; 3.5 执行结果： 123方法执行之前Hello zhangsan方法执行之后 从上面的例子我们可以看到动态代理有效的减少了各个模块的耦合度,用于实现日志功能的代码和用于实现登陆功能的代码相互隔离。对两者都没有条件限制,.只有在真正调用业务的时候并需要日志功能时候二者才发生联系。任何业务需要日志功能只需要通过代理类创建代理对象即可,不需要重复创建代理类. 究其原理System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);取消掉此方法的注释,我们运行或编译代码后将生成代理的文件,默认是项目根目录下的于包名同名的文件夹下。下面我们看一下生成的代理类反编译后的内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import ProxyDemo.Base;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;//$Proxy0是生成代理的格式决定的final class $Proxy0 extends Proxy implements Base &#123; //将基础的tostring,equils,hashcode,还有base接口的方法生成method的对象 private static Method m1; private static Method m2; private static Method m4; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void out() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; //具体的实现 static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m4 = Class.forName(\"ProxyDemo$Base\").getMethod(\"hello\", Class.forName(\"java.lang.String\")); m3 = Class.forName(\"ProxyDemo$Base\").getMethod(\"out\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 首先从类的继承关系就很容易理解Proxy.newProxyInstance(originalObj.getClass().getClassLoader(),originalObj.getClass().getInterfaces(), this);方法的作用了. 即继承了proxy类也实现了Base接口.这也是Base hello = (Base) new DynamicProxy().bind(new LoginImpl());这也是为什么可以强转为Base对象的原因.同时在代理中将object类中的equils,tostring,hashcode以及所有base接口的方法生成对应的代理方法. 以hello方法为例介绍一下,h表示的是proxy类中的InvocationHandler其实也就是指代我们之前的DynamicProxy对象,然后调用invoke方法就回到DynamicProxy的invoke方法.我们就可以再次做很多中间的操作。 12345678910public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125;&#125; Proxy解读看完了代理类的内容后,接下来我们就需要去详细的看一下Proxy是如何生成$Proxy0这个代理类的.了解一下其中的工作流程和原理。 首先看newProxyInstance方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); //获取需要代理类的所有实现的接口 final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; //检查是否有生成代理类的权限 checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; //查找或者生成代理类 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //生成构造函数 try &#123; if (sm != null) &#123; //检查是否有权限 checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; //public $Proxy0(InvocationHandler var1) final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; //访问修饰符设置 if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; //返回代理类的对象 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException | InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; 具体的实现逻辑在getProxyClass0方法中，最外面的方法只是描述了生成代理后然后创建对应的代理对象。首先看一下checkProxyAccess方法的具体内容 123456789101112131415161718192021222324252627282930//主要作用检查权限是否可以操作 private static void checkProxyAccess(Class&lt;?&gt; caller, ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; ClassLoader ccl = caller.getClassLoader(); //classloader验证 if (VM.isSystemDomainLoader(loader) &amp;&amp; !VM.isSystemDomainLoader(ccl)) &#123; sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; // ReflectUtil.checkProxyPackageAccess(ccl, interfaces); &#125; &#125; //检查接口的包权限 public static void checkProxyPackageAccess(ClassLoader var0, Class... var1) &#123; SecurityManager var2 = System.getSecurityManager(); if (var2 != null) &#123; Class[] var3 = var1; int var4 = var1.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; Class var6 = var3[var5]; ClassLoader var7 = var6.getClassLoader(); if (needsPackageAccessCheck(var0, var7)) &#123; checkPackageAccess(var6); &#125; &#125; &#125; &#125; 当验证完权限之后,查看如何获取代理类的getProxyClass0方法123456789private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; //从缓存中获取,如果不存在就创建 return proxyClassCache.get(loader, interfaces); &#125; 使用proxyClassCache做缓存，其目的是为了复用，同时防止多线程重复创建。在weekCache类中使用了多个map进行记录,稍后我们再做详细介绍. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//获取或生成代理类 此处因为不是线程安全的做了多次判断public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); //删除过期条目 expungeStaleEntries(); //创建cacheKey Object cacheKey = CacheKey.valueOf(key, refQueue); //查看key是否已经存在valuemaps中 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; //不存在的话通过,再次尝试尝试获取,如果没有就插入 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; //生成代理对象的key 为弱引用类型 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); //尝试从valuemap中获取 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; //如果确实已经有线程创建了 if (supplier != null) &#123; //直接获取 supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; //最终返回value return value; &#125; &#125; // 不存在创建一个supplier factory实现了supplier if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; //如果不存在则保存到valuemap中 supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // 添加成功 supplier = factory; &#125; // 创建的时候发现已经有了,尝试替换 &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; //替换成功 supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125;&#125; get方法首先去查看是否存在缓存过期的情况,存在则清除掉.如果不存在,尝试的生成key和value的相关元数据, 下面介绍key的生成方法KeyFactory.apply方法123456789//根据接口个数的不同选择生成不同的key对象public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; case 1: return new Key1(interfaces[0]); // the most frequent case 2: return new Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new KeyX(interfaces); &#125;&#125; 然后在判断是否存在同时其他线程生成,然后就是尝试着保存添加信息,如果已经有了就尝试替换.最终通过supplier.get()方法获取,最终实际的逻辑在supplier.get()方法中,下面看一下具体的过程123456789101112131415161718192021222324252627282930313233public synchronized V get() &#123; // serialize access // 再次检查是否匹配 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; //因为此方法调用之前有可能发生valuesMap.replace(subKey, supplier, factory) return null; &#125; // 创建 V value = null; try &#123; //真正的逻辑,重点方法 value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // 如果最终没能生成代理对象,从valuemap移除 valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; //包装value为acacheValue CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // 保存到reverseMap reverseMap.put(cacheValue, Boolean.TRUE); // 尝试这替换valuemap中的cacheValue if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError(\"Should not reach here\"); &#125; return value; &#125; 下面详细介绍value的ProxyClassFactory.apply方法.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 //apply方法详解public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; Class&lt;?&gt; interfaceClass = null; try &#123; //使用给定的类加载器加载接口 interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; //验证是否为接口 if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; //验证接口不是重复的 if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; //修饰符 int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * 验证接口的可见性 * 如果不是public类型的接口又不在同一个包下抛出异常 */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; //如果不是public类型的接口又不在同一个包下抛出异常 else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // 没有包使用默认的包 com.sun.proxy proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * 代理类的名称 按顺序递增 =&gt; $proxy0 */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * 生成代理类的字节数组 */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; //调用native方法生成Class return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125; 主要的步骤如下 1.尝试着用现有的类加载器加载接口,如果成功 2.验证是否为接口,接口是否重复 ,如果成功 3.验证接口访问权限,如果成功 4.获取包的信息,和类名设置, 5.生成代理的字节数组 6.通过native方法defineClass0获取字节数字的具体的Class 这里着重讲解一下如何生成字节数组的 1234567891011121314151617181920212223242526272829303132333435363738394041 //生成代理类public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123; ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2); /** * 生成具体文件字节数组 * 1.找到所有接口的方法 * 2.添加object类的三个方法 tostring hashcode equils * 3.遍历生成具体的代理方法,代理方法的逻辑都想似,回调我们的代理类 */ final byte[] var4 = var3.generateClassFile(); // private static final boolean saveGeneratedFiles = GetBooleanAction(\"sun.misc.ProxyGenerator.saveGeneratedFiles\"))).booleanValue(); //这就是我们为什么设置sun.misc.ProxyGenerator.saveGeneratedFiles = true的原因,设置后就会生成代理类的文件 if (saveGeneratedFiles) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int var1 = var0.lastIndexOf(46); Path var2; if (var1 &gt; 0) &#123; //生成path 将.替换成系统文件分隔符 Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar)); //创建文件夹 Files.createDirectories(var3); //具体文件 var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + \".class\"); &#125; else &#123; //没包就放在项目根目录下 var2 = Paths.get(var0 + \".class\"); &#125; //写入到文件中 Files.write(var2, var4, new OpenOption[0]); return null; &#125; catch (IOException var4x) &#123; throw new InternalError(\"I/O exception saving generated file: \" + var4x); &#125; &#125; &#125;); &#125; return var4;&#125; 主要的方法是通过ProxyGenerator对象生成字节数组,具体生成的步骤可以如下几步: 1231.找到所有接口的方法2.添加object类的三个方法 tostring hashcode equils3.遍历生成具体的代理方法,代理方法的逻辑都想似,回调我们的代理类 我可以通过之前展示的一个代理方法即可才想到其中的大概流程. 123456789public final void hello(String var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; 最主要不同的地方就是方法名,方法参数,invoke方法的参数。其他的几乎都相同。本文就不做代码上的具体介绍. 然后通过sun.misc.ProxyGenerator.saveGeneratedFiles 的值,来决定是否生成代理文件到磁盘. 如果生成,则生成包信息,类信息,然后将字节数组写入到文件中.默认情况下和在项目的根据下,创建和包名的文件夹和$proxy+i的代理文件. 缓存从我们的代码中我们可以看到WeekCache中使用多个map进行记录12345678910111213//cachekey的引用队列,于JVM关系密切详细介绍请看这篇文章http://blog.csdn.net/u012332679/article/details/57489179private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;(); // 最外层map,key=&gt;cacheKey,value =&gt; valueMap private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;(); //记录保存value的Supplier对象map private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;(); //key生成对象 private final BiFunction&lt;K, P, ?&gt; subKeyFactory; //value生成对象 private final BiFunction&lt;K, P, V&gt; valueFactory; map中的key是cacheKey,是一种弱应用类型的对象,reverseMap的key是cacheValue,同为一种弱应用类型的对象.两者也同时为内存回收的主要对象,当某个map中的key失效的时候,在下一次进行get,containsValue,size三个方法的时候都会触发expungeStaleEntries方法,然后将value从reverseMap中清除,valuemap从map中清除.而refQueue的回收,是由Reference中ReferenceHandler轮询去回收的.如果回收了,refQueue.poll会成功触发,然后就想清除操作.1234567891011121314151617181920private void expungeStaleEntries() &#123; CacheKey&lt;K&gt; cacheKey; while ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != null) &#123; cacheKey.expungeFrom(map, reverseMap); &#125;&#125;void expungeFrom(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map, ConcurrentMap&lt;?, Boolean&gt; reverseMap) &#123; // removing just by key is always safe here because after a CacheKey // is cleared and enqueue-ed it is only equal to itself // (see equals method)... ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(this); // remove also from reverseMap if needed if (valuesMap != null) &#123; for (Object cacheValue : valuesMap.values()) &#123; //移除弱应用CacheValue reverseMap.remove(cacheValue); &#125; &#125;&#125; valueMap是回记录真正的代理类相关信息key =&gt; subKeyFactory.apply(key, parameter) 通过classLoader和interface[]组成value=&gt; supplier=&gt;Factory 或者 CacheValue valuemap中value的两种形式1.刚创建时为factory对象2.factory.applay方法执行后会替换为CacheValue,并且将CacheValue保存到reverseMap中 小结总体的逻辑就是这样子, 通过源代码的阅读,对JDK的动态代理实现清晰很多。也从根本上对动态代理的实现过程有了更深的理解，我们此时就可以自己尝试着思考Spring AOP的具体实现。本文没有对缓存和代理生成的细节做详细分析和总结,还需要深入的研究 结语由于个人的能力有限，文章中存在错误的地方或者有宝贵的意见，欢迎大家留言评论。 之后会写Spring AOP 和 cglib动态代理的相关文章。 与君共勉！！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"展望2018","slug":"2018-target","date":"2017-12-31T16:08:47.000Z","updated":"2018-01-01T10:14:54.051Z","comments":true,"path":"2018/01/01/2018-target/","link":"","permalink":"http://www.eumji025.com/2018/01/01/2018-target/","excerpt":"","text":"总结2017 懵懵懂懂又一年,总的来说离目标还有一些距离. 展望2018往往都是计划赶不上变化,18年,还是把自己关键的主题方向列出来,某些具体的技术栈就随时间推荐进行学习.go和docker是必须要掌握的. 概括 该做的事情还是得做 该看的书籍还是得看 该敲的代码还是得敲 该学的东西还是得学 基础目标1.go语言及爬虫 2.docker三件套学习 3.java虚拟机 4.spring源码阅读 5.还是开发一个开源项目 6.技术类文章30篇(保质保量) 7.沉淀自己 总结新的一年,新的开始,也应该做一些新的尝试. 前路漫漫,且行且思.","categories":[{"name":"其他","slug":"其他","permalink":"http://www.eumji025.com/categories/其他/"}],"tags":[{"name":"target","slug":"target","permalink":"http://www.eumji025.com/tags/target/"}]},{"title":"spring-boot跳转页面","slug":"springboot-indexPage","date":"2017-03-26T00:04:54.000Z","updated":"2018-01-02T03:29:09.176Z","comments":true,"path":"2017/03/26/springboot-indexPage/","link":"","permalink":"http://www.eumji025.com/2017/03/26/springboot-indexPage/","excerpt":"","text":"前言 本篇博客记录spring boot如何跳转到静态首页.因为是初学的关系很多知识点都不懂,而且spring boot的项目没有webapp也没有配置文件.所以思考蛮久,经过查阅资料最终找到方法,做一次学习记录. Demo其实配置起来相对简单,只是一直没有找到配置的方法,翻看了官方文档,眼拙也没找到. 其实只需要在resources目录下新建static文件夹,并把html文件放在其中即可. 目录配置 Controller12345678@Controllerpublic class PageController &#123; @RequestMapping(\"indexPage\") public String indexPage()&#123; return \"index.html\"; &#125;&#125; 注: 在我暂时的尝试中,只能跳转一个页面,配多个也没用,可能是我自己学习的不够到位.后续学习中再做修改. 结果展示 结语与君共勉! BGM","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-customport","slug":"spring-boot-customport","date":"2017-02-26T12:19:56.000Z","updated":"2018-01-02T03:29:09.184Z","comments":true,"path":"2017/02/26/spring-boot-customport/","link":"","permalink":"http://www.eumji025.com/2017/02/26/spring-boot-customport/","excerpt":"","text":"Spring boot 自定义端口前言spring boot本身内置tomcat,我们不需要进行tomcat的配置,只需要引入tomcat的依赖即可. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt; 自定义端口1.spring boot中自定义端口需要入口类实现ConfigurableEmbeddedServletContainer接口.如下代码 1234567891011121314151617181920@RestController@EnableAutoConfigurationpublic class CustomPortController implements EmbeddedServletContainerCustomizer &#123; /** * 自定义端口 * @param container */ public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8888); &#125; @RequestMapping(\"/\") public String setPort()&#123; return \"自定义端口:8888\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(CustomPortController.class,args); &#125;&#125; 2.直接自定义ConfigurableEmbeddedServletContainer.通过自己注册TomcatEmbeddedServletContainerFactory，JettyEmbeddedServletContainerFactory或UndertowEmbeddedServletContainerFactory 12345678@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory factory = new TomcatEmbeddedServletContainerFactory(); factory.setPort(9000); factory.setSessionTimeout(10, TimeUnit.MINUTES); factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, \"/notfound.html\"); return factory;&#125; 结语长路漫漫,与君共勉!","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"spring-boot-helloworld","slug":"spring-boot-helloworld","date":"2017-02-26T02:32:34.000Z","updated":"2018-01-02T03:29:09.180Z","comments":true,"path":"2017/02/26/spring-boot-helloworld/","link":"","permalink":"http://www.eumji025.com/2017/02/26/spring-boot-helloworld/","excerpt":"","text":"Spring boot介绍 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 Spring boot 特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 Spring boot第一个demo说明本文采用maven方式构建项目.(maven学习地址) 开发环境 maven intellij idea java8 (推荐java7及以上版本) 构建项目第一个项目相对简单,我们不做过多的配置,只需要简单的引入spring-boot提供默认parent就可以了. 123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot.demo&lt;/groupId&gt; &lt;artifactId&gt;FirstDemo&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;FirstDemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--内置tomcat和springboot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;FirstDemo&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 代码编写123456789101112@RestController@EnableAutoConfigurationpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String helloWorld()&#123; return \"Hello world!\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldController.class,args); &#125;&#125; 注: 1.@RestController和@RequestMapping注解是springMVC的注解,分别用来注册controller类和映射对应地址的http请求. 2.@EnableAutoConfiguration注解,Spring Boot根据添加的jar依赖自动配置spring. 3.main方法通过调用run， 将业务委托给了Spring Boot的SpringApplication类。 SpringApplication将引导我们的应用， 启动Spring， 相应地启动被自动配置的Tomcat web服务器。 启动服务12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.4.1.RELEASE)2017-02-26 10:51:44.822 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Starting HelloWorldController on EumJi025 with PID 456 (E:\\workspace\\ideaWork\\Spring-boot\\FirstDemo\\target\\classes started by EumJi in E:\\workspace\\ideaWork\\Spring-boot)2017-02-26 10:51:44.833 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : No active profile set, falling back to default profiles: default2017-02-26 10:51:44.934 INFO 456 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:46.571 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-02-26 10:51:46.594 INFO 456 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-02-26 10:51:46.595 INFO 456 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.52017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-02-26 10:51:46.700 INFO 456 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1768 ms2017-02-26 10:51:46.813 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-02-26 10:51:46.817 INFO 456 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-02-26 10:51:47.044 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@9225652: startup date [Sun Feb 26 10:51:44 CST 2017]; root of context hierarchy2017-02-26 10:51:47.099 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.springboot.demo.controller.HelloWorldController.helloWorld()2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-02-26 10:51:47.102 INFO 456 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.128 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.163 INFO 456 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-02-26 10:51:47.315 INFO 456 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-02-26 10:51:47.373 INFO 456 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-02-26 10:51:47.377 INFO 456 --- [ main] c.s.d.controller.HelloWorldController : Started HelloWorldController in 3.327 seconds (JVM running for 4.128) 测试 结语长路漫漫,与君共勉!","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"http://www.eumji025.com/tags/spring-boot/"}]},{"title":"checksty配置","slug":"checkstyle","date":"2017-01-18T14:39:13.000Z","updated":"2018-01-02T03:29:09.164Z","comments":true,"path":"2017/01/18/checkstyle/","link":"","permalink":"http://www.eumji025.com/2017/01/18/checkstyle/","excerpt":"","text":"配置文件由于checkstyle默认是使用google的开发规范,相对来说比较严格,因此采用自定义的规范.本文的配置文件来源于网络,后续将会进行改动. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\" \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\"&gt;&lt;module name=\"Checker\"&gt; &lt;!-- 消息提示等级 --&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;!-- 字符集限制 --&gt; &lt;property name=\"charset\" value=\"UTF-8\"/&gt; &lt;module name=\"TreeWalker\"&gt; &lt;!-- javadoc的检查 --&gt; &lt;!-- 检查所有的interface和class --&gt; &lt;module name=\"JavadocType\"/&gt; &lt;!-- 检查所有方法的javadoc，可以不声明RuntimeException --&gt; &lt;module name=\"JavadocMethod\"&gt; &lt;property name=\"allowUndeclaredRTE\" value=\"true\"/&gt; &lt;property name=\"allowMissingPropertyJavadoc\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 检查变量的javadoc --&gt; &lt;module name=\"JavadocVariable\"&gt; &lt;property name=\"scope\" value=\"public\"/&gt; &lt;/module&gt; &lt;!-- 命名方面的检查，它们都使用了Sun官方定的规则。 --&gt; &lt;!-- 类名(class 或interface) 的检查 --&gt; &lt;module name=\"TypeName\"/&gt; &lt;!-- 变量的检查 --&gt; &lt;module name=\"MemberName\"/&gt; &lt;!-- 方法名的检查 --&gt; &lt;module name=\"MethodName\"/&gt; &lt;!-- 方法的参数名 --&gt; &lt;module name=\"ParameterName \"/&gt; &lt;!-- 常量名的检查 --&gt; &lt;module name=\"ConstantName\"/&gt; &lt;!-- 长度方面的检查 --&gt; &lt;!-- 文件长度不超过1500行 --&gt; &lt;!-- 每行不超过120个字--&gt; &lt;module name=\"LineLength\"&gt; &lt;property name=\"max\" value=\"120\"/&gt; &lt;/module&gt; &lt;!-- 方法不超过30行 --&gt; &lt;module name=\"MethodLength\"&gt; &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt; &lt;property name=\"max\" value=\"30\"/&gt; &lt;/module&gt; &lt;!-- 方法的参数个数不超过3个。 --&gt; &lt;module name=\"ParameterNumber\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 多余的关键字 --&gt; &lt;module name=\"RedundantModifier\"/&gt; &lt;!-- 对区域的检查 --&gt; &lt;!-- 不能出现空白区域 --&gt; &lt;module name=\"EmptyBlock\"/&gt; &lt;!-- 所有区域都要使用大括号。 --&gt; &lt;module name=\"NeedBraces\"/&gt; &lt;!-- 多余的括号 --&gt; &lt;module name=\"AvoidNestedBlocks\"&gt; &lt;property name= \"allowInSwitchCase\" value=\"true\"/&gt; &lt;/module&gt; &lt;!-- 编码方面的检查 --&gt; &lt;!-- 不许出现空语句 --&gt; &lt;module name=\"EmptyStatement\"/&gt; &lt;!-- 每个类都实现了equals()和hashCode() --&gt; &lt;module name=\"EqualsHashCode\"/&gt; &lt;!-- 不许使用switch --&gt; &lt;module name=\"IllegalToken\"&gt; &lt;property name=\"tokens\" value=\"LITERAL_SWITCH\"/&gt; &lt;/module&gt; &lt;!-- 不许内部赋值 --&gt; &lt;module name=\"InnerAssignment\"/&gt; &lt;!-- 绝对不能容忍魔法数 --&gt; &lt;module name=\"MagicNumber\"/&gt; &lt;!-- 循环控制变量不能被修改 --&gt; &lt;module name=\"ModifiedControlVariable\"/&gt; &lt;!-- 多余的throw --&gt; &lt;!-- &lt;module name=\"RedundantThrows\"/&gt; --&gt; &lt;!-- 不许使用未被简化的条件表达式 --&gt; &lt;module name=\"SimplifyBooleanExpression\"/&gt; &lt;!-- 不许使用未被简化的布尔返回值 --&gt; &lt;module name=\"SimplifyBooleanReturn\"/&gt; &lt;!-- String的比较不能用!= 和 == --&gt; &lt;module name=\"StringLiteralEquality\"/&gt; &lt;!-- if最多嵌套3层 --&gt; &lt;module name=\"NestedIfDepth\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- try最多被嵌套1层 --&gt; &lt;module name=\"NestedTryDepth\"/&gt; &lt;!-- clone方法必须调用了super.clone() --&gt; &lt;module name=\"SuperClone\"/&gt; &lt;!-- finalize 必须调用了super.finalize() --&gt; &lt;module name=\"SuperFinalize\"/&gt; &lt;!-- 不能catch java.lang.Exception --&gt; &lt;module name=\"IllegalCatch\"&gt; &lt;property name=\"illegalClassNames\" value=\"java.lang.Exception\"/&gt; &lt;/module&gt; &lt;!-- JUnitTestCase 的核心方法存在。 --&gt; &lt;!-- &lt;module name=\"JUnitTestCase\"/&gt; --&gt; &lt;!-- 一个方法中最多有3个return --&gt; &lt;module name=\"ReturnCount\"&gt; &lt;property name=\"max\" value=\"3\"/&gt; &lt;/module&gt; &lt;!-- 不许对方法的参数赋值 --&gt; &lt;module name=\"ParameterAssignment\"/&gt; &lt;!-- 不许有同样内容的String --&gt; &lt;module name=\"MultipleStringLiterals\"/&gt; &lt;!-- 同一行不能有多个声明 --&gt; &lt;module name=\"MultipleVariableDeclarations\"/&gt; &lt;!-- 各种量度 --&gt; &lt;!-- 布尔表达式的复杂度，不超过3 --&gt; &lt;module name=\"BooleanExpressionComplexity\"/&gt; &lt;!-- 类数据的抽象耦合，不超过7 --&gt; &lt;module name=\"ClassDataAbstractionCoupling\"/&gt; &lt;!-- 类的分散复杂度，不超过20 --&gt; &lt;module name=\"ClassFanOutComplexity\"/&gt; &lt;!-- 函数的分支复杂度，不超过10 --&gt; &lt;module name=\"CyclomaticComplexity\"/&gt; &lt;!-- NPath复杂度，不超过200 --&gt; &lt;module name=\"NPathComplexity\"/&gt; &lt;!-- 杂项 --&gt; &lt;!-- 禁止使用System.out.println --&gt; &lt;!-- &lt;module name=\"GenericIllegalRegexp\"&gt; &lt;property name=\"format\" value=\"System\\.out\\.println\"/&gt; &lt;property name=\"ignoreComments\" value=\"true\"/&gt; &lt;/module&gt; --&gt; &lt;!-- 不许使用与代码同行的注释 --&gt; &lt;module name=\"TrailingComment\"/&gt; &lt;!-- 不允许存在todo标签 --&gt; &lt;module name=\"TodoComment\"&gt; &lt;property name=\"severity\" value=\"warning\"/&gt; &lt;property name=\"format\" value=\"TODO\"/&gt; &lt;/module&gt; &lt;/module&gt; &lt;module name=\"FileLength\"&gt; &lt;property name=\"max\" value=\"1500\"/&gt; &lt;/module&gt; &lt;!-- 检查翻译文件 --&gt; &lt;module name=\"Translation\"/&gt;&lt;/module&gt; 注未完待续","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://www.eumji025.com/tags/tools/"}]},{"title":"web开发常用注解","slug":"annotation","date":"2017-01-11T15:14:31.000Z","updated":"2018-01-02T09:47:31.624Z","comments":true,"path":"2017/01/11/annotation/","link":"","permalink":"http://www.eumji025.com/2017/01/11/annotation/","excerpt":"","text":"简介概念 Annotation(注解)是JDK1.5及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。另外，你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。 分类①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 WEB开发中常用的注解Spring篇@Controller@Controller 定义控制器，映射页面URL的请求,只有被@Controller声明的类才会到对应类下找到对应@Requestmapping配置的URL 开启扫描@Controller注解需要在spring-mvc.xml中配置 1234&lt;!-- 扫描web相关的Bean 使用Annotation自动注册Bean,只扫描@Controller --&gt; &lt;context:component-scan base-package=\"com.jsu.controller\" use-default-filters=\"false\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!-- 子标签是用来添加扫描注解的 --&gt; &lt;/context:component-scan&gt; 简化配置版 1&lt;context:component-scan base-package=\"com.jsu.controller\"/&gt; ### @Requestmapping @RequestMapping 注解将类似 “/index”这样的URL映射到整个类或特定的处理方法上。类级别的注解映射特定的请求路径到表单控制器上，而方法级别的注解只是映射为一个特定的HTTP方法请求（“GET”，“POST”等）或HTTP请求参数。简而言之,公共的请求路径使用@RequestMapping放在类声明上,而特有的请求放在方法上,如下例: 12345678910111213141516@RequestMapping(\"/perm/permission\")public class PermissionController extends BaseController &#123; @Autowired private IPermissionService permissionService; @RequestMapping(\"/list\") public String list(Model model) &#123; return \"/permission/list\"; &#125; @RequestMapping(\"/getPermissionList\") @ResponseBody public String getPermissionList() &#123; Page&lt;Permission&gt; page = getPage(); return jsonPage(permissionService.selectPage(page, null)); &#125;&#125; @PathVariableURI 模版是一个类似于 URI 的字符串，其中包含了一个或多个变量。当你将这些变量替换掉市，就变回了 URI。 URI 模版格式 proposed RFC 定义了如何参数化 URI。比如，URI 模版 http://www.example.com/users/{userId}，包含了变量 userId，设置此变量为 __fred，就会变成http://www.example.com/users/fred。 可在方法入参上使用注解 @PathVariable 绑定 URI 的模版参数: 123456@RequestMapping(value=\"/owners/&#123;ownerId&#125;\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) &#123; Owner owner = ownerService.findOwner(ownerId); model.addAttribute(\"owner\", owner); return \"displayOwner\";&#125; @PathVariable 参数可以是任意的简单类型（如 int，long，Date 等），Spring 会自动将其进行类型转换，转换出错会抛出 TypeMismatchException. @RequestBody常用语接受前台请求的json格式数据,可以转化成对象接受. 12345@Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) &#123; // 实现省略&#125; @ResponseBody@ResponseBody 的使用类似于 @RequestBody。此注解用在方法上，用来表示直接将返回数据写到 HTTP 响应体里。注意，不是将数据放到 Model 中，或解析为视图名称。如下例: 12345@RequestMapping(value = \"/something\", method = RequestMethod.PUT)@ResponseBodypublic String helloWorld() &#123; return \"Hello World\";&#125; 常用于ajax请求. Bean自动装配 @Autowire@autowired是spring官方提供的一种装配方式。 ### ＠Resource @resource是java自带的一种装配方式。 两种方式的功能大致相同，默认推荐使用@Resource方式，这是j2ee原生的方式。能降低和spring的耦合度。 关于两种方式的详细介绍,参考:http://jsu.eumji025.top/2016/11/autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB/ JPA实体类注解### @Entity 标注于实体类上，通常和@Table是结合使用的，代表是该类是实体类 @table标注在实体类上,表示该实体类对应数据库中的一张表 @Id 标注于属性上，通常是在get方法上，也可以在属性的声明上。用于表示该属性作为ID主键. @GeneratedValue123456789101112131415161718192021//源码@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface GeneratedValue &#123; /** * (Optional) The primary key generation strategy * that the persistence provider must use to * generate the annotated entity primary key. */ GenerationType strategy() default AUTO; //默认是AUTO /** * (Optional) The name of the primary key generator * to use as specified in the &#123;@link SequenceGenerator&#125; * or &#123;@link TableGenerator&#125; annotation. * &lt;p&gt; Defaults to the id generator supplied by persistence provider. */ String generator() default \"\";&#125; 123456789101112131415161718192021222324252627282930313233343536public enum GenerationType &#123; /** * Indicates that the persistence provider must assign * primary keys for the entity using an underlying * database table to ensure uniqueness. * 自增长 */ TABLE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database sequence. * 通过序列 */ SEQUENCE, /** * Indicates that the persistence provider must assign * primary keys for the entity using a database identity column. * 由数据库维护 */ IDENTITY, /** * Indicates that the persistence provider should pick an * appropriate strategy for the particular database. The * &lt;code&gt;AUTO&lt;/code&gt; generation strategy may expect a database * resource to exist, or it may attempt to create one. A vendor * may provide documentation on how to create such resources * in the event that it does not support schema generation * or cannot create the schema resource at runtime. 自动选择合适的方案分配 */ AUTO&#125; @Column标注于属性上，有很多功能，例如指定长度、是否为空，列名以及对应到数据库汇中的类型等,具体如下源码所示 12345678910111213141516@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface Column &#123; //设置对应数据库名 String name() default \"\"; //是否唯一 boolean unique() default false; //是否可以为空 boolean nullable() default true; //是否可以掺入 boolean insertable() default true; //设置长度 int precision() default 0; //精度 int scale() default 0;&#125; @OrderBy设置排序.ASC和DESC.默认ASC 12345678910111213@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface OrderBy &#123; /** * &lt;p&gt; If &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; is not specified, * &lt;code&gt;ASC&lt;/code&gt; (ascending order) is assumed. * * &lt;p&gt; If the ordering element is not specified, ordering by * the primary key of the associated entity is assumed. */ String value() default \"\";&#125; ### @ManyToMany&amp;&amp;@OneToMany 设置对应关系,多对多,一对多 @DateTimeFormat格式化时间,放在属性上 1234567891011121314151617181920@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)public @interface DateTimeFormat &#123; String style() default \"SS\"; DateTimeFormat.ISO iso() default DateTimeFormat.ISO.NONE; String pattern() default \"\"; public static enum ISO &#123; DATE, //日期 TIME, //时间 DATE_TIME, //时间+日期 NONE; //无 private ISO() &#123; &#125; &#125;&#125; ## Jackson注解 JsonProperty设置某个属性在转成json后的名称 1234public class Name &#123; @JsonProperty(\"sex\") public String t_sex;&#125; 转化成json格式后是这样的: 将会生成如下所示的JSON数据结果：{ “sex” : “man” } @JsonIgnoreProperties此注解是类注解，作用是json序列化时将Java bean中的一些属性忽略掉，序列化和反序列化都受影响. @JsonIgnore 此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。示例: 12345public class KeyValue &#123; public int value; @JsonIgnore public int key;&#125; 12转成json字符串后://将会忽略key&#123; &quot;value&quot; : 42 &#125; @JsonFormat此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，比如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”) @JsonSerialize 此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码. @JsonDeserialize 此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码. Mybatis注解### @Alias ＠Alias是mybatis中一个注解,类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。xml中通常这样配置. 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"com.eumji025.vo.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"com.eumji025.vo.Blog\"/&gt;&lt;/typeAliases&gt; 也可以在xml中直接指定包名如下: 123&lt;typeAliases&gt; &lt;package name=\"com.eumji025.vo\"/&gt;&lt;/typeAliases&gt; 每一个在包 com.eumji025.vo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。比如 com.eumji025.vo.Author 的别名为 author 如通过注解已经设置别名则按照注解的别名来使用: 1234@Alias(\"author\")public class Author &#123; ...&#125; 当然mybatis为了使用方便,已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。具体如下: 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 注后续继续补充","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.eumji025.com/categories/Java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.eumji025.com/tags/java/"}]},{"title":"Idea-Maven项目的创建和部署","slug":"Idea-Maven项目的创建和部署","date":"2016-11-21T12:12:40.000Z","updated":"2018-01-01T10:14:54.099Z","comments":true,"path":"2016/11/21/Idea-Maven项目的创建和部署/","link":"","permalink":"http://www.eumji025.com/2016/11/21/Idea-Maven项目的创建和部署/","excerpt":"","text":"前言由于Intellij Idea创建项目方式和eclipse有一定的区别，所有maven项目也是一样。 目的学会使用idea创建和部署Maven项目。 过程创建空的项目 创建maven module1.点击+号创建 2.选择maven webapp 3输入groupId和ArtifactId 4.陪著maven相关信息。 5设置名字 完成。6.等待一段时间，maven自动加载web项目相关的配置7 修改pom文件 注意添加packaging 8 修改项目配置 提示maven-tomcat插件配置 发布 右键项目 run maven-maven-tomcat即可 结语 与君共勉！","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://www.eumji025.com/tags/Intellij-Idea/"}]},{"title":"推荐的markdown编辑器","slug":"推荐的markdown编辑器","date":"2016-11-05T01:26:54.000Z","updated":"2018-01-02T03:29:09.172Z","comments":true,"path":"2016/11/05/推荐的markdown编辑器/","link":"","permalink":"http://www.eumji025.com/2016/11/05/推荐的markdown编辑器/","excerpt":"","text":"介绍Typora是一款非常优雅的markdown编辑器 因为它将「写字」和「预览」合并，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。 用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。 一切都变得如此干净、纯粹。 官网 传送门： hexo官网 安装windows 下载地址 安装没有难度 linux sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys BA300B7755AFCFAE sudo add-apt-repository ‘deb https://typora.io ./linux/‘ sudo apt-get update sudo apt-get install typora mac 解压安装 功能介绍表格编辑其他的markdown表格编辑方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 十分复杂的操作有木有 Typora表格操作方式 CTRL+T快捷键直接生成 图片操作插入图片的语法 1![logo](http://typora.io/img/favicon-128.png) typora语法 CTRL+SHIFT+I 更简单的直接将图片拖拽进来即可。 目录大纲 Typora 还可以根据当前文档的标题层级，自动生成显示大纲， 点击软件左下角圆圈即可，就会出现字数统计和大纲预览。 圆圈旁边是切换视图按钮。 主题 ypora 默认提供了六套主题样式： Github风格、 默认主题 Gothic、 出版风格的 Newsprint、 夜间模式 Night、 Pixyll、 Whitey. 结语与君共勉！！！","categories":[{"name":"工具专栏","slug":"工具专栏","permalink":"http://www.eumji025.com/categories/工具专栏/"}],"tags":[{"name":"写作","slug":"写作","permalink":"http://www.eumji025.com/tags/写作/"}]},{"title":"springMVC 几种页面跳转方式","slug":"springMVC-几种页面跳转方式","date":"2016-10-28T04:45:00.000Z","updated":"2018-01-02T03:29:09.176Z","comments":true,"path":"2016/10/28/springMVC-几种页面跳转方式/","link":"","permalink":"http://www.eumji025.com/2016/10/28/springMVC-几种页面跳转方式/","excerpt":"","text":"前言前面已经了解了Controller的几种配置方式今天主要写一下响应界面跳转的几种方式 在注解的方式中通过HttpServletResponse的API直接输出（不需要配置渲染器）controller类的主要代码 12345678@Controllerpublic class RequestController&#123; @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.getWriter().println(\"hello HttpServletResponse\"); &#125; web.xml配置 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; dispatcher-servlet.xml主要代码 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--作用是扫描指定包下所有的包含注解的类--&gt; &lt;context:component-scan base-package=\"com.jsu.mvc\"/&gt;&lt;/beans&gt; 使用HttpServletResponse 重定向到另一个视图(其他不变 )1234567 @RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; resp.sendRedirect(\"index.jsp\"); &#125;&#125; 使用HttpServletRequest 转发（默认访问/下的index.jsp页面 不受渲染器的影响）12345@RequestMapping(\"/resp\") public void handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123; req.setAttribute(\"message\",\"it's forword \"); req.getRequestDispatcher(\"index.jsp\").forward(req,resp); &#125; 直接返回jsp页面的名称（无渲染器）其他的配置不变 123456789@RequestMapping(\"/nice\") public String hello1()&#123;//转发方式1 return \"home.jsp\"; //转发方式2 return \"forward:index.jsp\"; //重定向方式 return \"redirect:index.jsp\"; &#125; 当有渲染器指定123456789@RequestMapping(\"/nice\") public String hello1()&#123; //转发方式1 return \"home\"; //转发方式2 return \"forward:index\"; //重定向方式 hello指的是requsrmapping return \"redirect:hello\"; &#125; 使用view使用modelandview需要视图解析器 能指定跳转页面 12345678910111213141516public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); //封装要显示到视图的数据 mv.addObject(\"msg\",\"hello myfirst mvc\"); //视图名 mv.setViewName(\"hello\"); return mv; &#125;&#125; [servlet-name]-servlet.xml 12345678910111213&lt;!--配置渲染器--&gt; &lt;!--配置hellocontroller中页面的位置--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--结果视图的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--结果视图的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; &lt;bean name=\"/hello.do\" class=\"com.jsu.mvc.HelloController\"&gt;&lt;/bean&gt; 使用modelview不需要视图解析器 不能指定跳转页面 12345678//通过modelmap方式 @RequestMapping(\"/modelmap\") public String modelHello(String name,ModelMap map)&#123; map.addAttribute(\"name\",name); System.out.println(name); return \"index.jsp\"; &#125; 结语与君共勉！","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.eumji025.com/tags/Spring-MVC/"}]},{"title":"使用idea开发srpingMVC第一个Demo","slug":"使用idea开发srpingMVC第一个Demo","date":"2016-10-28T04:24:48.000Z","updated":"2018-01-02T03:29:09.172Z","comments":true,"path":"2016/10/28/使用idea开发srpingMVC第一个Demo/","link":"","permalink":"http://www.eumji025.com/2016/10/28/使用idea开发srpingMVC第一个Demo/","excerpt":"","text":"#主要目的是熟悉intellij的web项目操作和springMVC的基本概念,纯属个人学习的笔记,有写的不当的地方欢迎指正 ###操作环境说明操作系统： win10ide版本： 2017.1.5 开发过程本文原始的版本是在个人学习写的，所以很多东西写的不够详细。本次重新归纳总结，下面开始具体操作： 创建项目创建一个empty projectFile -&gt; new -&gt; project -&gt; empty project ###创建module说明一下，在实际开发中我们喜欢一个项目一个project，但是学习之中，为了方便来回切换，所以我们每一个demo都写成module的形式。 创建 module(在此之前需要创建entity project)在新版本中，会提示你是下载勾选的mvc的依赖。 然后填写module名 点击确认 module创建完毕（作者因为乱码的关系 ￥代表 /） 结构预览并修改配置在module的web-WEB-INF下新建 classes和lib文件夹（新版本中的lib在根目录下） 1.IDEA默认是不会像eclipse那样在web-inf下生成lib文件夹和classes文件夹的的，需要我们手动的创建，并将我们根目录下的lib目录下的内容复制到web-inf/lib文件夹内。并且还需要进行额外配置。 点击file-&gt;Project Struture 修改Modules下的paths 修改完毕点击OK（主要是为了跟ecilpse结构相似，也可以不改） 2.然后点击dependencis - &gt; 绿色的+ -&gt; 选择第一项，选择刚才我们在WEB-INF下创建的lib文件夹，和eclipse的导包一个性质。 3.回到主界面，配置tomcat 点击run-&gt;edit configurations‘点绿色的十字图标 创建tomcat并配置 选择自己的tomcat位置点击deployment -&gt; 绿色+号 -&gt; 选择我们的项目 代码编写 web,xml 不需要进行修改，有默认的就行了。 修改dispatcjer-servlet.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;!--对应src下的报名，需要自己新建--&gt; &lt;context:component-scan base-package=\"com.eumji.mvc\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;!--jsp文件夹需要自己手动创建--&gt; &lt;value&gt;/WEB-INF/jsp/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.在jsp目录下新建hello.jsp123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello mvc&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg &#125;&lt;/body&gt;&lt;/html&gt; 4.在src中编写controller类需要和dispatcher-servlet.xml配置的路径一致12345678@Controllerpublic class HelloController &#123; @RequestMapping(value=&quot;/hello&quot;,method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute(&quot;msg&quot;, &quot;Spring 3 MVC Hello World&quot;); return &quot;hello&quot;; &#125;&#125; 5.点击右上角的绿色三角形进行运行，最后进行测试 第一个小demo到此结束！ 最后说几句Intellij IDEA和eclipse的使用有很大的不同，本文只是带领着使用IDEA进行web项目的创建和测试。并没有对spring MVC框架本身的内容进行过多的讲解。IDEA创建普通的web 项目确实比较麻烦，使用maven的方式更佳。 补充还是补充一下创建maven项目的姿势 创建maven module 1.点击+号创建 2.选择maven webapp3输入groupId和ArtifactId4.陪著maven相关信息。最好是设置一下maven的setting文件,无论是自带的还是自己配置的maven,修改一下maven的镜像地址.在maven的settings.xml 文件里配置mirrors的子节点，添加如下mirror &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 5.文件夹名称,创建完成.6.加载 等待一段时间，maven自动加载web项目相关的配置 7 .修改pom文件注意添加packaging8 修改项目配置 maven-tomcat插件配置 发布右键项目 run maven-maven-tomcat即可 spring boot特别推荐一下使用spring boot,对新手非常友好,而且可以使用spring initialize生成项目,并且不需要配置tomcat. 源码地址https://github.com/eumji025/my-demo/tree/master/hello-mvc","categories":[{"name":"Spring专栏","slug":"Spring专栏","permalink":"http://www.eumji025.com/categories/Spring专栏/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://www.eumji025.com/tags/Intellij-Idea/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.eumji025.com/tags/Spring-MVC/"}]}]}